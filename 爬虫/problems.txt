题目：Goldensection(1202)
时间限制：1000 ms
空间限制：65535 ms
题目描述：

It’s known to all that thinking is good at geometry.Fishhead has a problem to him today, make a cylinder in fishhead’s way!
Using a sheet of paper and scissors, you can cut out two faces to form a cylinder in the fishhead’s way:

    Cut the paper horizontally (parallel to the shorter side) to get two rectangular parts. 
    From the first part, cut out a circle of maximum radius. The circle will form the bottom of the cylinder. 
    Roll the second part up in such a way that it has a perimeter of equal length with the circle's circumference, and attach one end of the roll to the circle. Note that the roll may have some overlapping parts in order to get the required length of the perimeter.

Busy as thinking is ,he ask you to fininsh this task.
Given the dimensions of the sheet of paper, can you calculate the biggest possible volume of a cylinder which can be constructedin the fishhead’s way?
题目输入：
The input consists of several test cases. Each test case consists of two numbers w and h (1 ≤ w ≤ h ≤ 100), which indicate the width and height of the sheet of paper.
The last test case is followed by a line containing two zeros.

题目输出：
For each test case, print one line with the biggest possible volume of the cylinder. Round this number to 3 places after the decimal point.
输入样例：
10 10
10 50
10 30
0 0

输出样例：
54.247
785.398
412.095
Hint
In the first case, the optimal cylinder has a radius of about 1.591549, in the second case, the optimal cylinder has a radius of 5, and in the third case, the optimal cylinder has a radius of about 3.621795.

提示：




题目：BarnRepair(1448)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
It was a dark and stormy night that ripped the roof and gates off the stalls that hold Farmer John's cows. Happily, many of the cows were on vacation, so the barn was not completely full. The cows spend the night in stalls that are arranged adjacent to each other in a long line. Some stalls have cows in them; some do not. All stalls are the same width. Farmer John must quickly erect new boards in front of the stalls, since the doors were lost. His new lumber supplier will supply him boards of any length he wishes, but the supplier can only deliver a small number of total boards. Farmer John wishes to minimize the total length of the boards he must purchase. Given M (1 <= M <= 50), the maximum number of boards that can be purchased; S (1 <= S <= 200), the total number of stalls; C (1 <= C <= S) the number of cows in the stalls, and the C occupied stall numbers (1 <= stall_number <= S), calculate the minimum number of stalls that must be blocked in order to block all the stalls that have cows in them. Print your answer as the total number of stalls blocked.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  M, S, and C (space separated)  Lines 2-C+1:  Each line contains one integer, the number of an occupied stall.
题目输出：
A single line with one integer that represents the total number of stalls blocked.
输入样例：
4 50 18
3
4
6
8
14
15
16
17
21
25
26
27
30
31
40
41
42
43
输出样例：
25
提示：
[One minimum arrangement is one board covering stalls 3-8, one covering 14-21, one covering 25-31, and one covering 40-43.]



题目：美食计划(1648)
时间限制：3000 MS
空间限制：65535 KB
题目描述：
有一天，Hdd去吃自助餐。那家餐馆有n种食物可供选择，每种食物分别由不同的厨师供应，由于厨师们水平有限，每分钟只能产生一定数量的食物。某一分钟生产出来的食物Hdd可以自由取用，但是如果他不在这一分钟吃掉，这些食物全部会被别人吃掉。而且厨师只有在固定时间才会上班。既然是自助餐，一定要吃饱，吃好，作为极品吃货的Hdd决定把这n种食物都吃够，他想让我们帮他算算如果他要实现自己的美食计划，他每分钟的食量至少要达到多少，当然Hdd每分钟可以吃多种食物。
题目输入：
	有多组输入数据，以文件尾结束。	每组数据以2个整数开始：N(1<=n<=100)表示有N种食物 ,T(1<=T<=1500)代表Hdd吃自助餐的时间。	后面接着n行，每行有4个整数,Fi，Vi，Si，Ei。Fi(0<=fi<=100,000)代表Hdd准备吃掉Fi个第i种食物,Vi(0<=Vi<=100,000)代表每分钟可以产生Vi个第i种食物,Si,Ei(1<=Si<=Ei<=t)代表这种食物从第Si分钟初开始供应，在第Ei分钟末结束供应。
题目输出：
		每组数据分别输出一行：Hdd每分钟的食量至少要达到多少才能吃够。如果Hdd怎么吃都无法吃够，输出-1。		
输入样例：
3 4
100 50 1 2
100 50 1 2
100 100 4 4
3 4
100 50 1 2
100 50 2 3
100 100 3 3

输出样例：
100
150

提示：
None



题目：A+B(1000)
时间限制：1000 ms
空间限制：65536 ms
题目描述：
Calculate A + B
题目输入：
 2 integers, terminated by EOF
题目输出：
 The sum of the 2 integer
输入样例：
1 2
2 3

输出样例：
3
5

提示：
输入文件里面有很多组测试数据，你需要依次读入求和




题目：HelloST,GoodbyeST(1752)
时间限制：1000MS
空间限制：65535KB
题目描述：
		   高考只是决定了你在哪dota，而大学的考试却决定了你能不能在大学打dota，一旦被学业警示两次，你就不能在宿舍开黑了。因此，从某种意义上而言，大学的绩点变得比较重要。	   某老师在某门比较重要的课，居然卡点给我84，而不是85分。这是非常不能忍的事。因此，我把84和5定为坑数。 给定区间[a,b]，求区间内不包含坑数的个数。例如845，184，15都是坑数，而3834不是坑数，因为84不连续且不包含5。
题目输入：
    输入为多case。每行两个数a,b（1<=a<=b<=2^31-1），输入以0,0结尾
题目输出：
    一个数m，表示不坑的数的个数。
输入样例：
1 100
0 0
输出样例：
80
提示：
None



题目：Puzzle(1548)
时间限制：10000 ms
空间限制：65565 ms
题目描述：
	A children's puzzle that was popular 30 years ago consisted of a 5x5 frame which contained 24 small squares of equal size. A unique letter of the alphabet was printed on each small square. Since there were only 24 squares within the frame, the frame also contained an empty position which was the same size as a small square. A square could be moved into that empty position if it were immediately to the right, to the left, above, or below the empty position. The object of the puzzle was to slide squares into the empty position so that the frame displayed the letters in alphabetical order.	The illustration below represents a puzzle in its original configuration and in its configuration after the following sequence of 6 moves:		1) 		 The square above the empty position moves.	2) 		 The square to the right of the empty position moves.	3) 		 The square to the right of the empty position moves.	4) 		 The square below the empty position moves.	5) 		 The square below the empty position moves.	6) 		 The square to the left of the empty position moves.	 			Write a program to display resulting frames given their initial configurations and sequences of moves.
题目输入：
	Input for your program consists of several puzzles. Each is described by its initial configuration and the sequence of moves on the puzzle. The first 5 lines of each puzzle description are the starting configuration. Subsequent lines give the sequence of moves.	The first line of the frame display corresponds to the top line of squares in the puzzle. The other lines follow in order. The empty position in a frame is indicated by a blank. Each display line contains exactly 5 characters, beginning with the character on the leftmost square (or a blank if the leftmost square is actually the empty frame position). The display lines will correspond to a legitimate puzzle.	The sequence of moves is represented by a sequence of As, Bs, Rs, and Ls to denote which square moves into the empty position. A denotes that the square above the empty position moves; B denotes that the square below the empty position moves; L denotes that the square to the left of the empty position moves; R denotes that the square to the right of the empty position moves. It is possible that there is an illegal move, even when it is represented by one of the 4 move characters. If an illegal move occurs, the puzzle is considered to have no final configuration. This sequence of moves may be spread over several lines, but it always ends in the digit 0. The end of data is denoted by the character Z.	
题目输出：
	Output for each puzzle begins with an appropriately labeled number (Puzzle #1, Puzzle #2, etc.). If the puzzle has no final configuration, then a message to that effect should follow. Otherwise that final configuration should be displayed.	Format each line for a final configuration so that there is a single blank character between two adjacent letters. Treat the empty square the same as a letter. For example, if the blank is an interior position, then it will appear as a sequence of 3 blanks - one to separate it from the square to the left, one for the empty position itself, and one to separate it from the square to the right.	Separate output from different puzzle records by one blank line.	Note: The first record of the sample input corresponds to the puzzle illustrated above.	
输入样例：
TRGSJ
XDOKI
M VLN
WPABE
UQHCF
ARRBBL0
ABCDE
FGHIJ
KLMNO
PQRS 
TUVWX
AAA
LLLL0
ABCDE
FGHIJ
KLMNO
PQRS 
TUVWX
AAAAABBRRRLL0
Z
输出样例：
Puzzle #1:
T R G S J
X O K L I
M D V B N
W P   A E
U Q H C F

Puzzle #2:
  A B C D
F G H I E
K L M N J
P Q R S O
T U V W X

Puzzle #3:
This puzzle has no final configuration.
提示：
None



题目：伊卡路斯的情诗(1344)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
相传古希腊有个这样的故事，艺术大师第达罗斯的儿子伊卡路斯爱上了一个女孩安薇儿，却因为父亲在雅典犯了重罪被迫流亡海外。那天第达罗斯给儿子装上了翅膀，让他逃回家乡。伊卡路斯由于急切飞回家乡看望安薇儿，舞动翅膀飞得太高太快，最终由于太靠近太阳而被融化了翅膀。而伊卡路斯对安薇儿的思念却化作一首情诗，飞到了安薇儿的面前。这首诗由于音节独特而被人广为流传，也出现了很多翻版。但是这些翻版总离不开这些独特的音节。(为了方便我们用字母表示，他们是： "a", "e", "i", "o" , 和"u")每个翻版都是三句话共24个重要音节，其中第一句话包含9个，第二句话包含9个，第三句话包含6个。其中有一个翻版是这么说的：see how much i love youi believe we will meet in the future world 现在，给你很多首翻版诗，每首三句话，要你判断它是不是伊卡路斯情诗的翻版。
 
题目输入：
多测试样例，第一行有个整数t，表示样例数， 每个样例包含三行，每行长度在1~100个字符之间，包括空格和小写英文字母。三行就是这首诗的三行，请注意，第一、二、三行只能分别包含9、9、6个音节，多一个和少一个都不是正确的翻版。
每个样例后面会多一行空格注意处理。
题目输出：
YES，如果它是正确的翻版。
NO，如果它不是正确的翻版。
输入样例：
3
see how much i love you
i believe we will meet 
in the future world 

i think it is an easy problem
is it easy or not for you 
hope you enjoy 

besides earthly clamour clamour
we whether stem what
all difficulties
 

输出样例：
YES
YES
NO
提示：
祝大家比赛愉快！



题目：小岛小岛(1102)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
  某城市有很多小岛组成，现在已知各岛之间的能够联通的距离（有些小岛之间是不能联通的）。市长想要建若干桥梁将各个小岛联通，要求是总的桥梁长度最短。
题目输入：
第一行n(n<=26),代表有n个小岛。接着输入n-1行，每行第一个char代表小岛名字(A,B,C,D,E,F...Z),下一个是非负整数m，代表当前小岛有m条能建造的桥梁。接着有m个可建桥梁（第一个字符是桥梁所连下个小岛名字，下一个整数是距离）。n=0是结束。
题目输出：
将这些小岛联通所需要的最短的桥梁长度。
输入样例：
9
A 2 B 12 I 25
B 3 C 10 H 40 I 8
C 2 D 18 G 55
D 1 E 44
E 2 F 60 G 38
F 0
G 1 H 35
H 1 I 35

3
A 2 B 10 C 40
B 1 C 20
0
输出样例：
216
30
提示：




题目：Cipher(1001)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Bob and Alice started to use a brand-new encoding scheme. Surprisingly it is not a Public Key Cryptosystem, but their encoding and decoding is based on secret keys. They chose the secret key at their last meeting in Philadelphia on February 16th, 1996. They chose as a secret key a sequence of n distinct integers, a1 ; . . .; an, greater than zero and less or equal to n. The encoding is based on the following principle. The message is written down below the key, so that characters in the message and numbers in the key are correspondingly aligned. Character in the message at the position i is written in the encoded message at the position ai, where ai is the corresponding number in the key. And then the encoded message is encoded in the same way. This process is repeated k times. After kth encoding they exchange their message.The length of the message is always less or equal than n. If the message is shorter than n, then spaces are added to the end of the message to get the message with the length n.Help Alice and Bob and write program which reads the key and then a sequence of pairs consisting of k and message to be encoded k times and produces a list of encoded messages.
题目输入：
The input file consists of several blocks. Each block has a number 0 < n <= 200 in the first line. The next line contains a sequence of n numbers pairwise distinct and each greater than zero and less or equal than n. Next lines contain integer number k and one message of ascii characters separated by one space. The lines are ended with eol, this eol does not belong to the message. The block ends with the separate line with the number 0. After the last block there is in separate line the number 0.
题目输出：
Output is divided into blocks corresponding to the input blocks. Each block contains the encoded input messages in the same order as in input file. Each encoded message in the output file has the lenght n. After each block there is one empty line.
输入样例：
10
4 5 3 7 2 8 1 6 10 9
1 Hello Bob
1995 CERC
0
0

输出样例：
BolHeol  b
C RCE
提示：
None



题目：AzoresCabbage的苏州游(1753)
时间限制：1000ms
空间限制：65535KB
题目描述：
    AzoresCabbage假期的时候独自去苏州玩，出发前他想制定一个旅行计划。假设苏州有N个景点，AzoresCabbage给每个景点定义了一个开心值Si，也就是说当他游玩这个景点后他的总开心值会加Si，同时，游玩第i个景点会花费Ci的时间。由于没有妹子陪，所以他想在限定的时间T内，从起始点S，有选择的游览一些景点，最后到达终点E。当然他想让这次旅行所得的开心值最大。    注意，AzoresCabbage可以为了走近路而只是路过一些景点，不去游玩（包括S和E）。而且他有一个怪癖就是要去玩的下一个景点的开心值一定要大于之前玩的景点（例如他游玩景点i获得的开心值为10，那么他游玩的下一个景点的开心值必须大于10）。此外，景点间的路是双向的，路上也要耗费时间。
题目输入：
 有多组测试数据。每组测试数据格式如下： 第一行包括5个整数：N M T S E。N代表景点的数量1<N<100，M代表道路的数量0<M<1000，T代表时间限制0<T<=300，S代表起点，E代表终点，0<=S,E<N。 第二行包括N个整数Ci（0<=Ci<=T）,表示游玩景点i所要花费的时间。 第三行包括N个整数Si（0<=Si<100）,表示游玩景点i可以得到的开心值。 接下来M行，每行包括3个整数u,v,w,表示在u和v间有一条双向路，在路上要耗费w的时间(0<=u,v<N,0<=w<=T)。
题目输出：
 第一行输出case号（格式见样例） 第二行包括一个整数，表示这次旅行可以获得的最大开心值。当然，如果不能再T时间内到达E，只需要输出“0”（没有引号）。 
输入样例：
4 4 22 0 3
1 1 1 1
5 7 9 12
0 1 10
1 3 10
0 2 10
2 3 10
输出样例：
Case #1:
21
提示：
None



题目：HuXinjie’seconomy(1203)
时间限制：6000 ms
空间限制：65535 ms
题目描述：

As the chairman of Technology Association, Xiaoyoulei has Obtained great achievements on the ability of “Huyou”and ,done great contributions on the construction of our school.
Our school is so big that every small costs turns to be huge after being multiplied by the number of people living here and the area of school. As the inflation nowadays, it becomes more and more important to decline the costs.
To reduce the Electric costs of NJUST, Xiaoyouleihas decided to optimize the road lighting. Till now every road was illuminated all night long, which costs 1 yuan per meter and day. To save money, he decided to no longer illuminate every road, but to switch off the road lighting of some streets. To make sure that the inhabitants of NJUST still feel safe, he want to optimize the lighting in such a way, that after darkening some streets at night, there will still be at least one illuminated path from every crossing in NJUST to every other crossing. 
What is the maximum daily amount of money Xiaoyoulei can save, without making their inhabitants feel unsafe? 
题目输入：
The input file contains several test cases. Each test case starts with two numbers m and n, the number of crossings in Byteland and the number of roads in Byteland, respectively. Input is terminated by m=n=0. Otherwise, 1 ≤ m ≤ 200000 and m-1 ≤ n ≤ 200000. Then follow n integer triples x, y, z specifying that there will be a bidirectional road between x and y with length z meters (0 ≤ x, y < m and x ≠ y). The graph specified by each test case is connected. The total length of all roads in each test case is less than 231. 
题目输出：
For each test case print one line containing the maximum daily amount the government can save. 


输入样例：
7 11
0 1 7
0 3 5
1 2 8
1 3 9
1 4 7
2 4 5
3 4 15
3 5 6
4 5 8
4 6 9
5 6 11
0 0


输出样例：
51
提示：




题目：LTJANDGUAISHOUs(1649)
时间限制：1000 MS
空间限制：65535 KB
题目描述：
The hero LTJ has a very powerful skill which will kill all of the GUAISHOU nearby . Now LTJ meet a group of very powerful opponent, he needs to use skill to kill all of the enemy's five GUAISHOUs, and only finishing this leaves the chance to win for him. If we have already got the coordinates of the GUAISHOUs, in where can LTJ put the skill to kill all the GUAISHOUs?
题目输入：
There are several test cases in the input. Each test case begin with an integer R (1 ≤ R ≤ 1000), indicating the range of the skill,all GUAISHOUs are killed if the distance between LTJ and the GUAISHOUs is no larger than R.The following line contains ten integers, indicating the coordinates of the five opponents, and -10000 ≤ x, y ≤ 10000. The input terminates by end of file marker.
题目输出：
For each test case, output one line:If no such point, output "Poor LTJ, maybe 2012 is coming!"If only one such point, output "Only the point (x, y) is for victory." (x, y) that the only point LTJ can sing.If there are plenty of such points, output "The total possible area is X." X indicating the total area LTJ can put skill.All the floating numbers should be rounded to two fractional digits.
输入样例：
1
0 0 0 1 0 2 0 3 0 4
2
0 0 0 1 0 2 0 3 0 4

输出样例：
Poor LTJ, maybe 2012 is coming!
Only the point (0.00, 2.00) is for victory.
提示：
None



题目：Scanner(1549)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	 			A body scanner works by scanning a succession of horizontal slices through the body; the slices are imaged one at a time. The image slices can be reassembled to form a three dimensional model of the object. Write a program to construct a two dimensional image slice using data captured during the scan.								The scanner consists of four arrays of sensors arranged around a 10×15 matrix. Array 1 consists of 10 sensors pointing to the right, array 2 has 24 sensors pointing diagonally to the top right, array 3 has 15 sensors pointing to the top and array 4 has 24 sensors pointing to the top left. Each sensor records the thickness of that portion of the object directly in front of that sensor.				Readings from the arrays of sensors are recorded in counterclockwise order. Within an array of sensors, data are also recorded counterclockwise. A complete scan consists of 73 readings.		
题目输入：
							The input file begins with a line with an integer indicating the number of image slices to follow. For each image slice, there are separate lines with 10, 24, 15, and 24 integers representing sensor data from sensor arrays 1 through 4 respectively. The order of the readings is indicated in the diagram.					
题目输出：
			For each slice, your program should print 10 lines of 15 cells. To indicate that the cell represents a part of the object, print a hash character (#) for the cell; to indicate that the cell is not a part of the object, print a period (.). Between successive output image slices, print a blank line.				It is possible for the result of a scan to be ambiguous, in that case you will have to output a blank picture as shown in the sample output.	
输入样例：
2
10 10 6 4 6 8 13 15 11 6
0 1 2 2 2 2 4 5 5 6 7 6 5 6 6 5 5 6 6 3 2 2 1 0
2 4 5 5 7 6 7 10 10 10 7 3 3 5 5
0 0 1 3 4 4 4 4 3 4 5 7 8 8 9 9 6 4 4 2 0 0 0 0
10 10 6 4 6 8 13 15 11 6
0 1 2 2 2 2 4 5 5 6 7 6 5 6 6 5 5 6 6 3 2 2 1 0
2 4 5 5 7 6 7 10 10 10 7 3 3 5 5
0 0 1 3 4 4 4 4 3 2 5 7 8 8 9 9 6 4 4 2 0 0 0 0
输出样例：
.##########....
.##########....
....######.....
......####.....
.......####..##
.......########
#####..########
###############
..#########..##
....######.....

...............
...............
...............
...............
...............
...............
...............
...............
...............
...............

提示：
None



题目：PrimeCryptarithm(1449)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The following cryptarithm is a multiplication problem that can be solved by substituting digits from a specified set of N digits into the positions marked with *. If the set of prime digits {2,3,5,7} is selected, the cryptarithm is called a PRIME CRYPTARITHM.       * * *   x    * *    -------      * * *         <-- partial product 1    * * *           <-- partial product 2    -------    * * * *Digits can appear only in places marked by `*'. Of course, leading zeroes are not allowed. Note that the 'partial products' are as taught in USA schools. The first partial product is the product of the final digit of the second number and the top number. The second partial product is the product of the first digit of the second number and the top number. Write a program that will find all solutions to the cryptarithm above for any subset of digits from the set {1,2,3,4,5,6,7,8,9}.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  N, the number of digits that will be used Line 2:  N space separated digits with which to solve the cryptarithm
题目输出：
A single line with the total number of unique solutions. Here is the single solution for the sample input:       2 2 2    x   2 2     ------      4 4 4    4 4 4  ---------    4 8 8 4
输入样例：
5
2 3 4 6 8
输出样例：
1
提示：




题目：FindTheMinimumNumberQ(1345)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
对于一个给定的非负整数N，找到一个最小的自然数Q，使得Q的每一位数字的乘积等于N
题目输入：
第一行包含一个整数T，表示测试数据的个数
下面是T行非负整数，即给定的N (0<=N<=10^8) 
题目输出：
对于每个给定的N，输出对应的自然数Q，如果Q不存在，那么就输出‘-1’
输入样例：
3 
1 
10 
12345678

输出样例：
1 
25 
-1

提示：
如果N=0，输出-1



题目：奇怪的DOTA选人规则(1103)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
DotA是一款在大学生中风靡的游戏。messIDou和thinking610也很喜欢。但是作为ACM赛场上并肩作战的队友，他们的DotA水平却是有天壤之别，在两人的中单1V1中，thinking610从未赢过。messIDou为了让比赛有挑战性，就让thinking610帮他选择英雄。选人规则如下：
--在rd模式下20个英雄围成一个圈，我们把他们编号为1-20。从1开始，在第i次的时候报到Ai的英雄被踢出，一直这样下去，最后只剩下一个英雄，就是messIDou需要使用的英雄
题目输入：
第一行是一个整数t，代表有t组数据。
下面的t列，每行有19个整数（A1--A19，Ai≠0且|Ai|＜100，Ai为负表示向反方向）
题目输出：
最后剩下的英雄的标号
输入样例：
3
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
1 2 3 4 5 6 7 8 9 10 -9 -8 -7 -6 -5 -4 -3 -2 -1 
输出样例：
20
2
5

提示：




题目：Department(1002)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The Department of Security has a new headquarters building. The building has several floors, and on each floor there are rooms numbered xxyy where yy stands for the room number and xx for the floor number, 0 < xx; yy <= 10. The building has `pater-noster' elevator, i.e. elevator build up from several cabins running all around. From time to time the agents must visit the headquarters. During their visit they want to visit several rooms and in each room they want to stay for some time. Due to the security reasons, there can be only one agent in the same room at the same time, The same rule applies to the elevators. The visits are planned in the way ensuring they can be accomplished within one day. Each agent visits the headquarters at most once a day.

Each agent enters the building at the 1st floor, passes the reception and then starts to visit the rooms according to his/her list. Agents always visit the rooms by the increasing room numbers. The agents form a linear hierarchy according to which they have assigned their one letter personal codes. The agents with higher seniority have lexicographically smaller codes. No two agents have the same code.

If more then one agent want to enter a room, or an elevator, the agents have to form a queue. In each queue, they always stand according to their codes. The higher the seniority of the agent, the closer to the top of the queue he stands. Every 5 s (seconds) the first agent in the queue in front of the elevator enters the elevator. After visiting the last room in the headquarters each agent uses if necessary elevator to the first floor and exits the building.

The times necessary to move from a certain point in the headquarters to another are set as follows: Entering the building, i.e. passing the reception and reaching the elevator, or a room on the first floor takes 30 s. Exiting the building, i.e. stepping out of the elevator or a room on the first floor and passing the reception takes also 30 s. On the same floor, the transfer from the elevator to the room (or to the queue in front of the room), or from the room to the elevator (or to the queue in front of the elevator), or from one room to another (or to the queue in front of the room) takes 10 s. The transfer from one floor to the next floor above or below in an elevator takes 30 s. Write a program that determines time course of agent's visits in the headquarters. 
题目输入：
The input file contains the descriptions of n >= 0 visits of different agents. The first line of the description of each visit consists of agent's one character code C, C = A, . . ., Z, and the time when the agent enters the headquarters. The time is in the format HH:MM:SS (hours, minutes, seconds). The next lines (there will be at least one) contain the room number, and the length of time intended to stay in the room, time is in seconds. Each room is in a separate line. The list of rooms is sorted according to the increasing room number. The list of rooms ends by the line containing 0. The list of the descriptions of visits ends by the line containing the character dot. 
题目输出：
The output contains detailed records of each agent's visit in the headquarters. For each agent, there will be a block. Blocks are ordered in the order of increasing agent's codes. Blocks are separated by an empty line. After the last block there is an empty line too. The first line of a block contains the code of agent. Next lines contain the starting and ending time (in format HH:MM:SS) and the descriptions of his/her activity. Time data will be separated by one blank character. Description will be separated from time by one blank character. Description will have a form Entry, Exit or Message. The Message can be one of the following: Waiting in elevator queue, Waiting in front of room RoomNumber, Transfer from room RoomNumber to room RoomNumber, Transfer from elevator to room RoomNumber, Transfer from RoomNumber to elevator, Stay in room RoomNumber, Stay in elevator. 
输入样例：
A 10:00:00
0101 100
0110 50
0202 90
0205 50
0
B 10:01:00
0105 100
0201 5
0205 200
0
.

输出样例：
A
10:00:00 10:00:30 Entry
10:00:30 10:02:10 Stay in room 0101
10:02:10 10:02:20 Transfer from room 0101 to room 0110
10:02:20 10:03:10 Stay in room 0110
10:03:10 10:03:20 Transfer from room 0110 to elevator
10:03:20 10:03:50 Stay in elevator
10:03:50 10:04:00 Transfer from elevator to room 0202
10:04:00 10:05:30 Stay in room 0202
10:05:30 10:05:40 Transfer from room 0202 to room 0205
10:05:40 10:07:40 Waiting in front of room 0205
10:07:40 10:08:30 Stay in room 0205
10:08:30 10:08:40 Transfer from room 0205 to elevator
10:08:40 10:09:10 Stay in elevator
10:09:10 10:09:40 Exit

B
10:01:00 10:01:30 Entry
10:01:30 10:03:10 Stay in room 0105
10:03:10 10:03:20 Transfer from room 0105 to elevator
10:03:20 10:03:25 Waiting in elevator queue
10:03:25 10:03:55 Stay in elevator
10:03:55 10:04:05 Transfer from elevator to room 0201
10:04:05 10:04:10 Stay in room 0201
10:04:10 10:04:20 Transfer from room 0201 to room 0205
10:04:20 10:07:40 Stay in room 0205
10:07:40 10:07:50 Transfer from room 0205 to elevator
10:07:50 10:08:20 Stay in elevator
10:08:20 10:08:50 Exit

提示：




题目：-2N+1Problem(1754)
时间限制：2000MS
空间限制：65535KB
题目描述：
 fishhead和鱼儿子一起做游戏。 fishhead给鱼儿子出了大家所熟知的3N+1 problem，著名的克拉兹猜想。 fishhead给了鱼儿子两种转化： (1)当这个数字n为偶数时，那么n就可以变换到n/2，即 n -> n/2； (2)n可以变换到3*n+1，即 n -> 3n+1。 fishhead给鱼儿子的任务是，给定任意的一个正整数x，最后通过上面的两种变换，最后需要变化到1。 聪明的鱼儿子很快就解决了这个问题，他说当x为偶数的时候就执行变换(1)，当x为奇数的时候就执行变换(2)，重复执行最后会收敛到1。 fishhead觉得这个问题太明显太简单了，于是就出了下面这个问题。 fishhead给了鱼儿子三种转化： (1)n可以变换到-2*n，即 n -> -2n； (2)n可以变换到-2*n+1，即 n -> -2n+1； (3)对于当前的变换m -> n，如果(n - m)%3 == 0，那么n可以变换到[n/3]，即 n -> n/3(向下取整)，特别地，对于第一次变换，可以无条件使用这条转化。 现在fishhead给了鱼儿子两个整数a和b，鱼儿子可以使用上述3种转化，需要把a转化到b，鱼儿子犯难了，于是向你求助，你能否替他解决呢？
题目输入：
 第一行输入一个T(T约为10000)，表示有T组测试数据。 每组测试数据，输入2个整数a和b(a和b都在int范围内)。
题目输出：
 对于每组测试数据，给出一种可行变换，第一行先输出变换的次数N，下面N行，每行输出[1,3]之间的一个数字，表示转化的序号，注意不要输出多余的空格和空行。 我们保证给定的每组测试数据都是存在转化方式的，转化范围请在long long范围内转化。	
输入样例：
2
4 1
10 -7
输出样例：
1
3
2
1
3
提示：
None



题目：InventionofWAVWind(1204)
时间限制：1000 ms
空间限制：65535 ms
题目描述：

Recently WAVWind has finished a great invention named WAVWind pencil!!
Maybe you wonder what aWAVWind pencilis? First of all, the pencil we speak of supports only black and white. Therefore, a picture consists of a rectangular area of pixels, which are either black or white. Second, there is only one operation how to change the colour of pixels: 
Select a rectangular area of r rows and c columns of pixels, which is completely inside the picture. As a result of the operation, each pixel inside the selected rectangle changes its colour (from black to white, or from white to black). 
Initially, all pixels are white. To create a picture, the operation described above can be applied several times. Can you paint a certain picture which you have in mind?
 
题目输入：
The input contains several test cases. Each test case starts with one line containing four integers n, m, r and c. (1 ≤ r ≤ n ≤ 100, 1 ≤ c ≤ m ≤ 100), The following n lines each describe one row of pixels of the painting you want to create. The ith line consists of m characters describing the desired pixel values of the ith row in the finished painting ('0' indicates white, '1' indicates black). 
The last test case is followed by a line containing four zeros. 

题目输出：
For each test case, print the minimum number of operations needed to create the painting, or -1 if it is impossible. 
输入样例：
3 3 1 1
010
101
010
4 3 2 1
011
110
011
110
3 4 2 2
0110
0111
0000
0 0 0 0

输出样例：
4
6
-1

提示：




题目：Marbles(1650)
时间限制：1000 MS
空间限制：65535 KB
题目描述：
	最近我买了一些金鱼（n个），我想买一些鱼缸去装他们，商店有两种鱼缸	第一种：每个鱼缸花费c1个大洋，可以装n1条鱼	第二种：每个鱼缸花费c2个大洋，可以装n2条鱼	我想要每个鱼缸都可以放满而且最后的花费要最小，我很难计算出怎么把我的鱼分配到这些缸里面，我需要你的程序的帮助，而且你的程序需要很有效率哦
题目输入：
	输入文件包括多个测试样例。每个测试样例以一个整数n开头，n的范围是[1,2000000000]。第二行包含两个整数，c1、n1，第三行包括c2、n2。c1，n1，c2，n2的数据范围都是[1,2000000000]。	测试样例当n=0时结束
题目输出：
	没个测试样例输出是最小的耗费数，包含两个整数，m1、m2，其中第i种鱼缸需要mi个，如果方案不存在输出”failed”。如果方案存在，你可以假设他是唯一的。
输入样例：
43
1 3
2 4
40
5 9
5 12
0

输出样例：
13 1
failed

提示：
None



题目：PackingRectangles(1450)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The six basic layouts of four rectanglesFour rectangles are given. Find the smallest enclosing (new) rectangle into which these four may be fitted without overlapping. By smallest rectangle, we mean the one with the smallest area. All four rectangles should have their sides parallel to the corresponding sides of the enclosing rectangle. Figure 1 shows six ways to fit four rectangles together. These six are the only possible basic layouts, since any other layout can be obtained from a basic layout by rotation or reflection. Rectangles may be rotated 90 degrees during packing. There may exist several different enclosing rectangles fulfilling the requirements, all with the same area. You must produce all such enclosing rectangles.
题目输入：
There are several test cases, end by EOF, for each test case:Four lines, each containing two positive space-separated integers that represent the lengths of a rectangle's two sides. Each side of a rectangle is at least 1 and at most 50.
题目输出：
The output file contains one line more than the number of solutions. The first line contains a single integer: the minimum area of the enclosing rectangles. Each of the following lines contains one solution described by two numbers p and q with p<=q. These lines must be sorted in ascending order of p, and must all be different.
输入样例：
1 2
2 3
3 4
4 5
输出样例：
40
4 10
5 8
提示：




题目：Borrowers(1550)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	I mean your borrowers of books - those mutilators of collections, spoilers of the symmetry of shelves, and creators of odd volumes.	- (Charles Lamb, Essays of Elia (1823) `The Two Races of Men')	Like Mr. Lamb, librarians have their problems with borrowers too. People don't put books back where they should. Instead, returned books are kept at the main desk until a librarian is free to replace them in the right places on the shelves. Even for librarians, putting the right book in the right place can be very time-consuming. But since many libraries are now computerized, you can write a program to help.	When a borrower takes out or returns a book, the computer keeps a record of the title. Periodically, the librarians will ask your program for a list of books that have been returned so the books can be returned to their correct places on the shelves. Before they are returned to the shelves, the returned books are sorted by author and then title using the ASCII collating sequence. Your program should output the list of returned books in the same order as they should appear on the shelves. For each book, your program should tell the librarian which book (including those previously shelved) is already on the shelf before which the returned book should go.	
题目输入：
	First, the stock of the library will be listed, one book per line, in no particular order. Initially, they are all on the shelves. No two books have the same title. The format of each line will be:	``title" by author	The end of the stock listing will be marked by a line containing only the word:	END	Following the stock list will be a series of records of books borrowed and returned, and requests from librarians for assistance in restocking the shelves. Each record will appear on a single line, in one of the following formats:	BORROW ``title"	RETURN ``title"	SHELVE	The list will be terminated by a line containing only the word:	END	
题目输出：
	Each time the SHELVE command appears, your program should output a series of instructions for the librarian, one per line, in the format:	Put ``  " after ``  "	or, for the special case of the book being the first in the collection:	Put ``title" first	After the set of instructions for each SHELVE, output a line containing only the word:	END	Assumptions & Limitations:	1. A title is at most 80 characters long.	2. An author is at most 80 characters long.	3. A title will not contain the double quote (") character.	
输入样例：
"The Canterbury Tales" by Chaucer, G.
"Algorithms" by Sedgewick, R.
"The C Programming Language" by Kernighan, B. and Ritchie, D.
END
BORROW "Algorithms"
BORROW "The C Programming Language"
RETURN "Algorithms"
RETURN "The C Programming Language"
SHELVE
END
输出样例：
Put "The C Programming Language" after "The Canterbury Tales"
Put "Algorithms" after "The C Programming Language"
END
提示：
None



题目：ACM队专题小组(1346)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
njust的ACM队友很多专题小组，鱼头规定，为保证研究质量，每个同学只能加入一个专题小组。但是，由于以孙健波为首的一小撮同学研究的专题古怪，而且不愿意向大家透露专题小组的名称，所以统计计算集训队一共有多少专题小组变得十分困难，于是，鱼头把这个艰难的任务交给了你。你只知道集训队一共有n (0 < n ≤ 50000)个同学。于是，lmm333向你伸出援助之手，借助lmm333强大的酱油能力，你可以询问m (0 ≤ m ≤  n(n-1)/2)对同学他俩是否是一个专题小组。于是这个任务变得相当简单了^_^
题目输入：
输入包含许多测试数据，
每组第一行包含整数n、m
下有面m行
没行包含两个整数，i、j，代表学生i和j研究了相同的专题，学生编号从1到n，
当测试数据以n=m=0结束
题目输出：
对于每组测试数据，先输出case号（从1开始），接着输出最多有多少个不同的专题小组
输入样例：
10 9
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
1 10
10 4
2 3
4 5
4 8
5 8
0 0

输出样例：
Case 1: 1
Case 2: 7
提示：
大量测试数据，建议使用scanf，例如把cin>>n;改成scanf("%d",&n)；



题目：MayaCalendar(1003)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
During his last sabbatical, professor M. A. Ya made a surprising discovery about the old Maya calendar. From an old knotted message, professor discovered that the Maya civilization used a 365 day long year, called Haab, which had 19 months. Each of the first 18 months was 20 days long, and the names of the months were pop, no, zip, zotz, tzec, xul, yoxkin, mol, chen, yax, zac, ceh, mac, kankin, muan, pax, koyab, cumhu. Instead of having names, the days of the months were denoted by numbers starting from 0 to 19. The last month of Haab was called uayet and had 5 days denoted by numbers 0, 1, 2, 3, 4. The Maya believed that this month was unlucky, the court of justice was not in session, the trade stopped, people did not even sweep the floor.

For religious purposes, the Maya used another calendar in which the year was called Tzolkin (holly year). The year was divided into thirteen periods, each 20 days long. Each day was denoted by a pair consisting of a number and the name of the day. They used 20 names: imix, ik, akbal, kan, chicchan, cimi, manik, lamat, muluk, ok, chuen, eb, ben, ix, mem, cib, caban, eznab, canac, ahau and 13 numbers; both in cycles.

Notice that each day has an unambiguous description. For example, at the beginning of the year the days were described as follows:

1 imix, 2 ik, 3 akbal, 4 kan, 5 chicchan, 6 cimi, 7 manik, 8 lamat, 9 muluk, 10 ok, 11 chuen, 12 eb, 13 ben, 1 ix, 2 mem, 3 cib, 4 caban, 5 eznab, 6 canac, 7 ahau, and again in the next period 8 imix, 9 ik, 10 akbal . . .

Years (both Haab and Tzolkin) were denoted by numbers 0, 1, : : : , where the number 0 was the beginning of the world. Thus, the first day was:
     Haab: 0. pop 0
    Tzolkin: 1 imix 0

Help professor M. A. Ya and write a program for him to convert the dates from the Haab calendar to the Tzolkin calendar. 
题目输入：
The date in Haab is given in the following format:

NumberOfTheDay. Month Year

The first line of the input file contains the number of the input dates in the file. The next n lines contain n dates in the Haab calendar format, each in separate line. The year is smaller then 5000. 
题目输出：
The date in Tzolkin should be in the following format:

Number NameOfTheDay Year

The first line of the output file contains the number of the output dates. In the next n lines, there are dates in the Tzolkin calendar format, in the order corresponding to the input dates. 
输入样例：
3
10. zac 0
0. pop 0
10. zac 1995

输出样例：
3
3 chuen 0
1 imix 0
9 cimi 2801

提示：




题目：留下的士兵(1104)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	有N个士兵站成一行，从右到左，从1到N依次编号，他们还得到一个整数M。然后这些士兵从右手边的士兵开始报数。报的数为M的倍数的士兵留在队列里，其他的士兵需要离开队列。他们重复进行这项操作直到队列中的人数小于M。举例来说，如果有10个士兵，并且M=3。第一次操作后，编号为3，6，9的士兵留在队列中。第二次操作后，编号为9的士兵留在队列中。由于队列中的士兵的数量小于M，那么编号为9的士兵就是最终留在队列里面的士兵。现在我们想知道哪些士兵将会最终留在队列中，你能告诉我们吗?
题目输入：
输入包含几个测试数据。每个测试数据只占单独的一行，包含两个整数n和m(3 <= n <= 10^9, 2 <= m <= n)。当n=0 并且m=0的时候标志输入结束。
题目输出：
对于每组测试数据，输出两行。第一行包含一个整数X，表示最终留下的士兵的数量。第二行包含X个整数，表示最终留下的士兵的编号。你应该把他们按照升序输出。
输入样例：
10 3
8 3
0 0

输出样例：
1
9
2
3 6

提示：
None



题目：NORUBBISH(1755)
时间限制：1000ms
空间限制：65535kb
题目描述：
 There is no fucking,no rubbish . 对于一个给定高度K和节点数N的完全二叉树，给出他一共有多少种不同的形态。 TIPS：完全二叉树要么没有子树，要么一定左右子树都有。
题目输入：
 有多组数据  每组数据一行 两个数 N （1<=N<=200）,K（1<=K<=100） 
题目输出：
   每行对应给出N ,K 的结果模除9901
输入样例：
5 3
输出样例：
2
提示：

	           @                   @      


	          / \                    / \


	       @   @     and   @   @


	       / \                           / \


	     @   @                     @   @





题目：JudgerealLianbao(1205)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
最近，Haltstead又开始玩仙四了，由于之前的经历，现如今他的技术水平已经是炉火纯青了。不到一天的时间，他便见到了狐三太爷。


       剧情中，梦璃为救莲宝遭遇了如上一场，狐三太爷变出了很多莲宝（当然其中只有一个真身，其余都是幻象），聪明的梦璃在与狐仙的对话中判断出了莲宝的真身所在，并很快地找到了莲宝，这让狐仙十分恼怒和不满。接下来便是战斗了？
       当然Halstead感觉不过瘾，这打得有点突然了，于是他意淫之间其实还有一段隐藏剧情：狐仙觉得梦璃这样是耍诈，于是再度施法，要求梦璃只能一段一段的排除，而且每一段排除的必须的是相等的完全平方数y^2个，一共只能使用k次排除，最后刚好找出剩下的那一个，同时狐仙给出的包括真身在内的所有莲宝也是一个完全平方数x^2。
       对于如此苛刻的条件，梦璃感觉接受比较困难，于是提出狐仙给出的x^2中的x需要自己确定，狐仙觉得这个条件不算什么，于是欣然接受了。由于忙着练级，所以这个确定x的问题就交给我们可爱的程序员了，当然是满足条件的最小的正整数x（x>1），同时算出梦璃每段排除的个数y^2中的y。
题目输入：
多组case，以文件尾结尾。每行输入一个数据k，表示一共可以使用k次排除（1 = < k < = 10^9 ）。
题目输出：
输出满足条件的最小的正整数x，y(1 < x < 10 ^ 1000, 1 < y < 10 ^ 1000 )。如果这样的结果不存在，输出“What a pity!”。
输入样例：
2
3
4

输出样例：
3 2
2 1
What a pity！

提示：




题目：传纸条(1651)
时间限制：1000 MS
空间限制：65535 KB
题目描述：
	周瑜童鞋最大的爱好就是上自习课传纸条给小乔童鞋。自习教室有N个人编号为1...N，周瑜童鞋的编号为1，小乔童鞋的编号为N。因为是在上自习课，所以帮忙传纸条的童鞋会不高兴，而且每两个童鞋互相只会帮忙传一次纸条，当童鞋A传纸条给童鞋B或童鞋B传纸条给童鞋A时，产生的不高兴度为C。周瑜童鞋想知道从他传纸条给小乔童鞋，到小乔童鞋传回纸条给他的这个过程中，最小的总不高兴度是多少。
题目输入：
	第一行输入T（T<=5)，表示有T组测试数据。对于每组测试数据，第一行输入两个整数N,M(0<=N<=100,0<=M<=N*(N-1)/2)。接下来M行，每行三个整数A,B,C(1<=A,B<=N,0<C<=200)，表示童鞋A和童鞋B可以互相传纸条且传纸条产生的不高兴度为C。
题目输出：
输出最小的总不高兴度(数据保证有解)。
输入样例：
1
4 5
1 2 1
2 3 1
3 4 1
1 3 2
2 4 2

输出样例：
6
提示：
None



题目：TheClocks(1451)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Consider nine clocks arranged in a 3x3 array thusly: |-------|    |-------|    |-------|    |       |    |       |    |   |   |    |---O   |    |---O   |    |   O   |          |       |    |       |    |       |           |-------|    |-------|    |-------|        A            B            C|-------|    |-------|    |-------||       |    |       |    |       ||   O   |    |   O   |    |   O   ||   |   |    |   |   |    |   |   ||-------|    |-------|    |-------|    D            E            F|-------|    |-------|    |-------||       |    |       |    |       ||   O   |    |   O---|    |   O   ||   |   |    |       |    |   |   ||-------|    |-------|    |-------|    G            H            IThe goal is to find a minimal sequence of moves to return all the dials to 12 o'clock. Nine different ways to turn the dials on the clocks are supplied via a table below; each way is called a move. Select for each move a number 1 through 9 which will cause the dials of the affected clocks (see next table) to be turned 90 degrees clockwise. Move  Affected clocks  1  ABDE  2  ABC  3  BCEF  4  ADG  5  BDEFH  6  CFI  7  DEGH  8  GHI  9  EFHI Example Each number represents a time accoring to following table: 9 9 12       9 12 12       9 12 12        12 12 12      12 12 12 6 6 6  5 ->  9  9  9  8->  9  9  9  4 ->  12  9  9  9-> 12 12 12 6 3 6        6  6  6       9  9  9        12  9  9      12 12 12 [But this might or might not be the `correct' answer; see below.]
题目输入：
There are several test cases, end by EOF, for each test case:Lines 1-3:  Three lines of three space-separated numbers; each number represents the start time of one clock, 3, 6, 9, or 12. The ordering of the numbers corresponds to the first example above.
题目输出：
A single line that contains a space separated list of the shortest sequence of moves (designated by numbers) which returns all the clocks to 12:00. If there is more than one solution, print the one which gives the lowest number when the moves are concatenated (e.g., 5 2 4 6 < 9 3 1 1).
输入样例：
9 9 12
6 6 6
6 3 6
输出样例：
4 5 8 9
提示：




题目：TestingtheCATCHER(1551)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	A military contractor for the Department of Defense has just completed a series of preliminary tests for a new defensive missile called the CATCHER which is capable of intercepting multiple incoming offensive missiles. The CATCHER is supposed to be a remarkable defensive missile. It can move forward, laterally, and downward at very fast speeds, and it can intercept an offensive missile without being damaged. But it does have one major flaw. Although it can be fired to reach any initial elevation, it has no power to move higher than the last missile that it has intercepted.	The tests which the contractor completed were computer simulations of battlefield and hostile attack conditions. Since they were only preliminary, the simulations tested only the CATCHER's vertical movement capability. In each simulation, the CATCHER was fired at a sequence of offensive missiles which were incoming at fixed time intervals. The only information available to the CATCHER for each incoming missile was its height at the point it could be intercepted and where it appeared in the sequence of missiles. Each incoming missile for a test run is represented in the sequence only once.	The result of each test is reported as the sequence of incoming missiles and the total number of those missiles that are intercepted by the CATCHER in that test.	The General Accounting Office wants to be sure that the simulation test results submitted by the military contractor are attainable, given the constraints of the CATCHER. You must write a program that takes input data representing the pattern of incoming missiles for several different tests and outputs the maximum numbers of missiles that the CATCHER can intercept for those tests. For any incoming missile in a test, the CATCHER is able to intercept it if and only if it satisfies one of these two conditions:		The incoming missile is the first missile to be intercepted in this test.	-or-		The missile was fired after the last missile that was intercepted and it is not higher than the last missile which was intercepted.	
题目输入：
	The input data for any test consists of a sequence of one or more non-negative integers, all of which are less than or equal to 32,767, representing the heights of the incoming missiles (the test pattern). The last number in each sequence is -1, which signifies the end of data for that particular test and is not considered to represent a missile height. The end of data for the entire input is the number -1 as the first value in a test; it is not considered to be a separate test.	The number of integer of each case is no more than 150000.	
题目输出：
	Output for each test consists of a test number (Test #1, Test #2, etc.) and the maximum number of incoming missiles that the CATCHER could possibly intercept for the test. That maximum number appears after an identifying message. There must be at least one blank line between output for successive data sets.	Note: The number of missiles for any given test is not limited. If your solution is based on an inefficient algorithm, it may not execute in the allotted time.	
输入样例：
389
207
155
300
299
170
158
65
-1
23
34
21
-1
-1
输出样例：
Test #1:
  maximum possible interceptions: 6

Test #2:
  maximum possible interceptions: 2
提示：
None



题目：内功or外功(1347)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
集训队组织的每个队员的报告课上，今天恰好轮到亮亮讲他研究的专题。
小明明坐在下面，听的迷迷糊糊的，开始津津有味的回忆起亮亮刚上课时讲的，他关于内功和外功的理解。
亮亮是这么说的，小时候喜欢看武侠片，在江湖上打打杀杀很潇洒，后来长大了才知道，现实是不允许的。但进了大学，才发现。其实计算机的世界，就是一个江湖。我们搞算法，修炼内功，他们做技术，其实是修炼外功。虽然修炼内功很苦，很累，而且需要漫长的时间积累内力，而练外功的话，不时可以学到很多很花哨的招式，做出很漂亮的东西。但是我们都知道，内功是比外功强大的，有了好的内力，再去学外功，才会成为真正的武林高手。
小明明想着想着就睡着了。梦里，他仿佛觉得自己成为了一个绝世高手。
天地灵气都从头顶的百汇穴流入，经过身体的奇经八脉，最终流至丹田处汇合。无奈身体各经脉能够承载的灵气的数量有限，而且有的承载的多，有的承载的少。小明明非常想知道自己每一次吸纳灵气的流量最大是多少，然后使劲想，发现经脉实在太多了，怎么也算不过来，非常懊恼，急着急着就醒了。发现这原来是个梦，但是他还是很想知道这个问题应该怎么解决，于是他想到了聪明的你，并请你编程解决这个问题。
题目输入：
多测试样例，文件结束为止(EOF)
每个样例的第一行是两个整数，n和m。n+1个穴位数（2<=n<=1000），m表示经脉数。(1<=m<=10000)（0表示百会穴，灵气从那流入，n表示丹田，灵气在那汇总。注意到，两个点之间不止一条经脉,并且经脉不能逆流，否则会走火入魔）
接下来m行，每行有三个数，a，b，c，表示该条经脉从a穴位流至b穴位。能容纳的最大灵气数为c个单位。

题目输出：
对于每个样例输出一个整数ans，表示每次最多吸纳的灵气数。
如果吸纳不到灵气，输出“you need to study hard!”（双引号不要）

输入样例：
5 6
0 1 5
1 2 3
2 3 5
4 5 3
1 4 7
3 5 3
3 3
0 1 10
0 2 10
1 2 3

输出样例：
5
you need to study hard!

提示：




题目：Transportation(1004)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Ruratania is just entering capitalism and is establishing new enterprising activities in many fields in- cluding transport. The transportation company TransRuratania is starting a new express train from city A to city B with several stops in the stations on the way. The stations are successively numbered, city A station has number 0, city B station number m. The company runs an experiment in order to improve passenger transportation capacity and thus to increase its earnings. The train has a maximum capacity n passengers. The price of the train ticket is equal to the number of stops (stations) between the starting station and the destination station (including the destination station). Before the train starts its route from the city A, ticket orders are collected from all onroute stations. The ticket order from the station S means all reservations of tickets from S to a fixed destination station. In case the company cannot accept all orders because of the passenger capacity limitations, its rejection policy is that it either completely accept or completely reject single orders from single stations.

Write a program which for the given list of orders from single stations on the way from A to B determines the biggest possible total earning of the TransRuratania company. The earning from one accepted order is the product of the number of passengers included in the order and the price of their train tickets. The total earning is the sum of the earnings from all accepted orders. 
题目输入：
The input file is divided into blocks. The first line in each block contains three integers: passenger capacity n of the train, the number of the city B station and the number of ticket orders from all stations. The next lines contain the ticket orders. Each ticket order consists of three integers: starting station, destination station, number of passengers. In one block there can be maximum 22 orders. The number of the city B station will be at most 7. The block where all three numbers in the first line are equal to zero denotes the end of the input file. 
题目输出：
The output file consists of lines corresponding to the blocks of the input file except the terminating block. Each such line contains the biggest possible total earning. 
输入样例：
10 3 4
0 2 1
1 3 5
1 2 7
2 3 10
10 5 4
3 5 10
2 4 9
0 2 5
2 5 8
0 0 0

输出样例：
19
34

提示：




题目：Base64编码(1105)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	Base64编码用来将任意的八位字节序列表示成为区分大小写的让人难以理解的形式。	       Base64编码用到了US-ASCII中的一个有65个元素的子集，能表示出可打印字符的其中6位。（额外的第65个字符‘=’，用来做特殊处理）。	       编码过程中，将一个24位的输入作为一个整体，处理成4个字符输出。编码从左向右进行，一个24位的输入是由三个连续的8位字节组成，这些24位被看成是4个连续的6位的正整数，每一个正整数都被转换成Base64字符表中的一个数字。	       每个6位的正整数都是64个字符数组的地址。由此地址确定的字符将会放到输出字符串。	 Table 1: Base 64 字符表         值 编码         值 编码         值 编码         值 编码          0 A            17 R            34 i            51 z          1 B            18 S            35 j            52 0          2 C            19 T            36 k            53 1          3 D            20 U            37 l            54 2          4 E            21 V            38 m            55 3          5 F            22 W            39 n            56 4          6 G            23 X            40 o            57 5          7 H            24 Y            41 p            58 6          8 I            25 Z            42 q            59 7          9 J            26 a            43 r            60 8         10 K            27 b            44 s            61 9         11 L            28 c            45 t            62 +         12 M            29 d            46 u            63 /         13 N            30 e            47 v         14 O            31 f            48 w          (pad) =         15 P            32 g            49 x         16 Q            33 h            50 y	 	       当输入数据的最后少于24bit的时候就需要特殊处理，最后总是能完全编码。当输入串最后少于24位的时候，不足的部分补0。填充的数据用 ‘=’ 来编码，由于所有的输入都是八位的字符，所以只有下列情况发生：	1、  最后剩余的bit数是24的倍数，输出的字符数目将是4的倍数，不会有 ’=’追加。	2、  最后剩余的 bit 数正好为 8 bits，此时在编码串后追加两个 ‘=’ 字符。	3、  最后剩余的 bit 数正好是 16bits，此时在编码串后追加一个 ‘=’ 字符	 
题目输入：
第一行是一个正整数 T(1 <= T <= 100)，表示数据的组数。接着是 T行，每一行为一个待编码的字符串。
题目输出：
对于每一个测试用例，输出相应的编码字符串。
输入样例：
4
What is your name
i
you
yes

输出样例：
V2hhdCBpcyB5b3VyIG5hbWU=
aQ==
eW91
eWVz

提示：
None



题目：水量统计(1756)
时间限制：1000ms
空间限制：65535KB
题目描述：
	   众所周知,水是大自然给予人类最宝贵的资源之一.在现代城市中,横纵交错的水管构成了人们生活的基本用水网络.某个社会实践小组希望能通过活动,加强对城市用水的了解.不过他们现在遇到了一个严峻的问题.	   他们需要一个数据,但是又没法直接得到.于是便通过收集相关数据的方式,希望能从中得到他们想要的那个数据.他们建立的模型是这样的:	   一个供水厂通过一个水管网络向m个用户提供用水.网络中的每条管子都有容量上限.连接水管的是被称为结点的连接部件.网络中共有n个结点.问若所有用户同时按最大需求用水(即尽可能地压榨,呃不,是使用这个供水网络).实践小组想知道此时网络内水的总量是多少(总水量包括从供水厂出发的管道到到达用户处管道里的水的总量,不包括用户正在使用的部分).假设供水厂能满足任何量的输出.
题目输入：
 多组测试数据,输入以EOF结尾 每个case以n(<=70),m(<=25),k分别表示结点数,用户数与管道数. 以下k行表示k条管道. 每行有三个正整数u,v,c分别表示管道起点,终点与容量(容量<=250). 供水厂的编号是0,结点编号由1到n,用户编号由n+1到n+m 接着有m个整数表示m个用户各自所需的用水量.	
题目输出：
 一个整数表示网络中的水量
输入样例：
4 4 10
0 1 1
0 2 4
0 3 3
0 4 2
1 6 5
2 5 6
2 7 8
3 6 7
3 8 9
4 7 4
1 2 3 4
输出样例：
16
提示：
None



题目：Alldisappeared(1207)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
                                                                     
 
As the coming of TuringCup，NewFarKing&&Queenlv( N & Q for short) worked very hard on it, Sister Xing has made a great problem for them: the rule are much more difficult than usual, there are many objects on the map, everyone is unique, and the task is to collect all the objects as short as possible.
The collecting tools are many kinds of tanks, you can use tank[i] when the objects in set b1[i] are all on the map and the objects in set b2[i] are not all on the map, tank[i] can collect all the objects in set f1[i], and throw out all the objects in set f2[i](if the object is already on the map, it won’t be thrown out).
As described above, can you help them find the shortest time to collect all the objects?
题目输入：
Multiple test cases,for each case:
First line containing two number:n,m, indicating the num of object and the number of tank.
Then following m lines as the information of tank[i].the beginning of a line is integer, indicating the time tank need to finish collecting, then two arrays, both of them are length of n. In the first array, if the kth letter is ‘+’, then the kth object belongs to b1, if ’-’, then the kth object belongs to b2, if ’0’,the kth object belongs to neither. In the second array, if the kth letter is ‘-’, then the kth object belongs to f1, if ’+’, then the kth object belongs to f2, if ’0’,the kth object belongs to neither.

题目输出：
For each case, output the shortest time to collect all the objects, if no answer output 0.

输入样例：
3 3 
1 000 00- 
1 00- 0-+ 
2 0-- -++

输出样例：
8
提示：




题目：寻找字符串(1652)
时间限制：1000 MS
空间限制：65535 KB
题目描述：
	李雷和韩梅梅都是非常好学的孩子，他们一遇到不会的问题就会上Baidu寻找答案。她们发现每次输入关键字，搜索得到的答案中关键字都会用不同的颜色标出，十分显眼，他们觉得这个非常神奇。同时他们发现在一段文字中，关键字可能会出现很多次，于是他们便有了一个需要聪明的你帮忙解答的问题，你能帮他们找到一段文字中重复出现的最长子串的长度么？注意，子串之间不能相互重叠。
题目输入：
每组输入数据有两行，第一行为一个整数n，第二行输入一个长为n（1<=n<=20000）的字符串，字符串由’a’-‘z’组成。
题目输出：
输出只有一行，输出一个数字表示最长重复子串的长度。
输入样例：
8
aabaaaab
4
aaaa

输出样例：
3
2

提示：
None



题目：ArithmeticProgressions(1452)
时间限制：15000 ms
空间限制：65535 ms
题目描述：
An arithmetic progression is a sequence of the form a, a+b, a+2b, ..., a+nb where n=0,1,2,3,... . For this problem, a is a non-negative integer and b is a positive integer. Write a program that finds all arithmetic progressions of length n in the set S of bisquares. The set of bisquares is defined as the set of all integers of the form p^2 + q^2 (where p and q are non-negative integers).
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  N (3 <= N <= 25), the length of progressions for which to search  Line 2:  M (1 <= M <= 250), an upper bound to limit the search to the bisquares with 0 <= p,q <= M.
题目输出：
If no sequence is found, a singe line reading `NONE'. Otherwise, output one or more lines, each with two integers: the first element in a found sequence and the difference between consecutive elements in the same sequence. The lines should be ordered with smallest-difference sequences first and smallest starting number within those sequences first. There will be no more than 10,000 sequences.
输入样例：
5
7
输出样例：
1 4
37 4
2 8
29 8
1 12
5 12
13 12
17 12
5 20
2 24
提示：
None



题目：CrosswordAnswers(1552)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
				A crossword puzzle consists of a rectangular grid of black and white squares and two lists of definitions (or descriptions).				One list of definitions is for ``words" to be written left to right across white squares in the rows and the other list is for words to be written down white squares in the columns. (A word is a sequence of alphabetic characters.)				To solve a crossword puzzle, one writes the words corresponding to the definitions on the white squares of the grid.				The definitions correspond to the rectangular grid by means of sequential integers on ``eligible" white squares. White squares with black squares immediately to the left or above them are ``eligible." White squares with no squares either immediately to the left or above are also ``eligible." No other squares are numbered. All of the squares on the first row are numbered.				The numbering starts with 1 and continues consecutively across white squares of the first row, then across the eligible white squares of the second row, then across the eligible white squares of the third row and so on across all of the rest of the rows of the puzzle. The picture below illustrates a rectangular crossword puzzle grid with appropriate numbering.								An ``across" word for a definition is written on a sequence of white squares in a row starting on a numbered square that does not follow another white square in the same row.				The sequence of white squares for that word goes across the row of the numbered square, ending immediately before the next black square in the row or in the rightmost square of the row.				A ``down" word for a definition is written on a sequence of white squares in a column starting on a numbered square that does not follow another white square in the same column.				The sequence of white squares for that word goes down the column of the numbered square, ending immediately before the next black square in the column or in the bottom square of the column.				Every white square in a correctly solved puzzle contains a letter.				You must write a program that takes several solved crossword puzzles as input and outputs the lists of across and down words which constitute the solutions.	
题目输入：
	Each puzzle solution in the input starts with a line containing two integers r and c ( 1<=r<=10 and 1<=c<=10), where r (the first number) is the number of rows in the puzzle and c (the second number) is the number of columns.	The r rows of input which follow each contain c characters (excluding the end-of-line) which describe the solution. Each of those c characters is an alphabetic character which is part of a word or the character ``*", which indicates a black square.	The end of input is indicated by a line consisting of the single number 0.	
题目输出：
	Output for each puzzle consists of an identifier for the puzzle (puzzle #1:, puzzle #2:, etc.) and the list of across words followed by the list of down words. Words in each list must be output one-per-line in increasing order of the number of their corresponding definitions.	The heading for the list of across words is ``Across". The heading for the list of down words is ``Down".	In the case where the lists are empty (all squares in the grid are black), the Across and Down headings should still appear.	Separate output for successive input puzzles by a blank line.	
输入样例：
2 2
AT
*O
6 7
AIM*DEN
*ME*ONE
UPON*TO
SO*ERIN
*SA*OR*
IES*DEA
0
输出样例：
puzzle #1:
Across
  1.AT
  3.O
Down
  1.A
  2.TO

puzzle #2:
Across
  1.AIM
  4.DEN
  7.ME
  8.ONE
  9.UPON
 11.TO
 12.SO
 13.ERIN
 15.SA
 17.OR
 18.IES
 19.DEA
Down
  1.A
  2.IMPOSE
  3.MEO
  4.DO
  5.ENTIRE
  6.NEON
  9.US
 10.NE
 14.ROD
 16.AS
 18.I
 20.A
提示：
None



题目：儿童节快乐(1348)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
6.1儿童节快到了，为了彰显节日气氛，学校决定打印出心形的图形以庆祝儿童节的到来。问题是，大家还没有决定打印多少个心。现在学校把这个任务交给了你。请编写一个程序，输出n*n个心。
     ******       ******     
   **********   **********   
 ************* ************* 
*****************************
*****************************
*****************************
 *************************** 
   ***********************   
     *******************     
       ***************       
         ***********         
           *******           
             ***             
              *              
题目输入：
多组测试数据
每组测试数据有1个整数n，8>=n>=1

题目输出：
输出n行*n列个心心
每组测试数据后加一个空行。
不能有多余的空格

输入样例：
1
2

输出样例：
     ******       ******     
   **********   **********   
 ************* ************* 
*****************************
*****************************
*****************************
 *************************** 
   ***********************   
     *******************     
       ***************       
         ***********         
           *******           
             ***             
              *              

     ******       ******          ******       ******     
   **********   **********      **********   **********   
 ************* *************  ************* ************* 
**********************************************************
**********************************************************
**********************************************************
 ***************************  *************************** 
   ***********************      ***********************   
     *******************          *******************     
       ***************              ***************       
         ***********                  ***********         
           *******                      *******           
             ***                          ***             
              *                            *              
     ******       ******          ******       ******     
   **********   **********      **********   **********   
 ************* *************  ************* ************* 
**********************************************************
**********************************************************
**********************************************************
 ***************************  *************************** 
   ***********************      ***********************   
     *******************          *******************     
       ***************              ***************       
         ***********                  ***********         
           *******                      *******           
             ***                          ***             
              *                            *              


提示：
建议将图形贴入txt记事本中看



题目：Counting(1106)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	在一个给定的有向连通图G里，有N个节点和M条边。在这M条边中，对于任意给定的节点k(我们将这N个节点编号为1,2,...,N)，如果有S条边指向它，我们称节点K的入度为S，如果有T条边从它指出来，我们称节点K的出度为T。对于给定的图G，我们这样定义生成树的概念:	(1) 这棵树包含图G中的N个节点和N-1条边。	(2) 这个N个节点是弱连通的。	对于以上关于生成树的定义，如果有一个节点V符合这样的条件: 节点V的入度为0，其余节点的入度为1，我们称这种树为根为V的外向树。	现在有给定的如下任务:	在任意给定的一个有N个节点和M条边的图G中，你能不能告诉我们图G中有多少种不同的树?	(1)这棵树可能是一棵根为V的外向树。也可能只是一棵生成树;	(2)这棵树必须包含给定的H条边，你可以假定这H条边属于G;你可以假定图中没有重边。 
题目输入：
在第一行，有一个整数T，表示测试数据的个数。对于每组测试数据，第一行包含三个整数N(2 <= N <= 100)，M(N-1 <= M < 10000)，R(0 <= R <= N)，N表示节点的个数，M表示有向边的个数，你需要数的R表示外向树的根，如果R=0，你的任务就是数生成树的个数。在接下来的M行里，每行包含两个整数x 和 y，表示一个从x 指向y 的边。接下有一个给定的整数h(0 <= h < N)，表示你数的树必须包含的边数，接下来的h行，每行包含两个整数x 和 y，表示一条从x 指向y 的边。
题目输出：
对于每组测试数据，第一行你应该输出"Case #:"，'#'是第几组测试数据，然后你需要在第二行输出一个整数，表示根为R的外向树的个数或是生成树的个数(如果R=0)，当然这些树需要包含给定的h条边。如果结果不小于10007，请输出个数模10007后的结果。
输入样例：
2
4 5 0
1 2
1 4
4 2
4 3
3 2
0
4 6 1
1 2
1 4
1 3
2 4
4 3
2 3
1
4 3

输出样例：
Case 1:
8
Case 2:
2

提示：
None



题目：John'strip(1005)
时间限制：111 ms
空间限制：111 ms
题目描述：
Little Johnny has got a new car. He decided to drive around the town to visit his friends. Johnny wanted to visit all his friends, but there was many of them. In each street he had one friend. He started thinking how to make his trip as short as possible. Very soon he realized that the best way to do it was to travel through each street of town only once. Naturally, he wanted to finish his trip at the same place he started, at his parents' house.

The streets in Johnny's town were named by integer numbers from 1 to n, n < 1995. The junctions were independently named by integer numbers from 1 to m, m <= 44. No junction connects more than 44 streets. All junctions in the town had different numbers. Each street was connecting exactly two junctions. No two streets in the town had the same number. He immediately started to plan his round trip. If there was more than one such round trip, he would have chosen the one which, when written down as a sequence of street numbers is lexicographically the smallest. But Johnny was not able to find even one such round trip.

Help Johnny and write a program which finds the desired shortest round trip. If the round trip does not exist the program should write a message. Assume that Johnny lives at the junction ending the street No. 1 with smaller number. All streets in the town are two way. There exists a way from each street to another street in the town. The streets in the town are very narrow and there is no possibility to turn back the car once he is in the street. 
题目输入：
Input file consists of several blocks. Each block describes one town. Each line in the block contains three integers x; y; z, where x > 0 and y > 0 are the numbers of junctions which are connected by the street number z. The end of the block is marked by the line containing x = y = 0. At the end of the input file there is an empty block, x = y = 0. 
题目输出：
The output file consists of 2 line blocks corresponding to the blocks of the input file. The first line of each block contains the sequence of street numbers (single members of the sequence are separated by space) describing Johnny's round trip. If the round trip cannot be found the corresponding output block contains the message Round trip does not exist. The second line of each block is empty. 
输入样例：
1 2 1
2 3 2
3 1 6
1 2 5
2 3 3
3 1 4
0 0
1 2 1
2 3 2
1 3 3
2 4 4
0 0
0 0

输出样例：
1 2 3 5 4 6 

Round trip does not exist

提示：




题目：Fieldpack(1208)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
Have you heard the 01 Bag Problem ? There is a bag,of which the weight is M.What's more,there are N kinds of foods, and the number of the ith kind of foods is c[i] and the weight of the ith foods is w[i]. Noting that same kind of foods have the same weight.We want to put foods into bag as much as possible so that the bag can be of full use.Can you tell me the maximun weight of foods we can put into bag?
题目输入：
Multiple test cases.First line contains N and M, as for next N lines,each line contain a pair of integer,indicating w[i] and c[i]. (N < = 1000,M < = 10000,w[i] < = 1000,c[i] < = 1000)
题目输出：
For each test cases,output only a singal integer, the maximun weight of foods we can put into bag. You can assume the answer can fit into 32-bit signed integer.

输入样例：
3 10
3 1
4 2
0 10

输出样例：
8

提示：




题目：无聊的矩阵(1757)
时间限制：2000ms
空间限制：65535KB
题目描述：
 给定一个n*n的矩阵，从这个矩阵中选n个数，这n个数两两之间必须在不同行不同列，问这n个数中最大值与最小值之差的最小值是多少？
题目输入：
 多组测试数据。每组测试数据格式如下： 第一行是一个整数n（1<=n<=100） 接下来n行，每行n个整数，表示给定的矩阵。 
题目输出：
 输出n个数中最大值与最小值之差的最小值。
输入样例：
4
1 1 1 1
2 2 2 2
3 3 3 3
4 4 4 4
输出样例：
3
提示：
None



题目：糖果(1653)
时间限制：1000 MS
空间限制：65535 KB
题目描述：
hdd特别喜欢吃糖果，现在他手头有若干种糖果，每种糖果有个口味值。但是娄萌萌童鞋来捣乱了，娄萌萌把糖果分成水果糖、奶糖、巧克力、软糖、夹心糖等15个品种。每种糖果的口味值有一个范围，假设从A到B(1<= A <= B <= 10^6)，表示该种类里有一颗口味值为A的，为A+1的，为A+2的，……，为B的，现在娄萌萌童鞋告诉hdd童鞋，你最多只能在每种糖果里面挑一个，然后你将得到一个你手上糖果的口味值总和，但是如果让你挑中和最大的实在是太没挑战性了，所以如果你能告诉我你能得到多少不同的和(要求大于0)，那所有的糖果都归你。Hdd太想吃糖了，所以他需要你的帮助。
题目输入：
	Line 1: 糖果的种类n (1<=n<=15)	Line 2: 各种糖果的下限A	Line 3: 各种糖果的上限B
题目输出：
	Case X: 和的种类数(Case和X之间有空格，冒号和数字之间有空格，数字在int范围内)
输入样例：
4
1 3 5 6
1 3 8 7
2
3 1
9 2

输出样例：
Case 1: 18
Case 2: 11

提示：
None



题目：Mother'sMilk(1453)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer John has three milking buckets of capacity A, B, and C liters. Each of the numbers A, B, and C is an integer from 1 through 20, inclusive. Initially, buckets A and B are empty while bucket C is full of milk. Sometimes, FJ pours milk from one bucket to another until the second bucket is filled or the first bucket is empty. Once begun, a pour must be completed, of course. Being thrifty, no milk may be tossed out. Write a program to help FJ determine what amounts of milk he can leave in bucket C when he begins with three buckets as above, pours milk among the buckets for a while, and then notes that bucket A is empty.
题目输入：
There are several test cases, end by EOF, for each test case:A single line with the three integers A, B, and C.
题目输出：
A single line with a sorted list of all the possible amounts of milk that can be in bucket C when bucket A is empty.
输入样例：
8 9 10
输出样例：
1 2 8 9 10
提示：




题目：StampsandEnvelopeSize(1553)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
		 		 	Philatelists have collected stamps since long before postal workers were disgruntled. An excess of stamps may be bad news to a country's postal service, but good news to those that collect the excess stamps. The postal service works to minimize the number of stamps needed to provide seamless postage coverage. To this end you have been asked to write a program to assist the postal service.	Envelope size restricts the number of stamps that can be used on one envelope. For example, if 1 cent and 3 cent stamps are available and an envelope can accommodate 5 stamps, all postage from 1 to 13 cents can be ``covered": 		Although five 3 cent stamps yields an envelope with 15 cents postage, it is not possible to cover an envelope with 14 cents of stamps using at most five 1 and 3 cent stamps. Since the postal service wants maximal coverage without gaps, the maximal coverage is 13 cents.		
题目输入：
								The first line of each data set contains the integer S, representing the maximum of stamps that an envelope can accommodate. The second line contains the integer N, representing the number of sets of stamp denominations in the data set. Each of the next N lines contains a set of stamp denominations. The first integer on each line is the number of denominations in the set, followed by a list of stamp denominations, in order from smallest to largest, with each denomination separated from the others by one or more spaces. There will be at most S denominations on each of the N lines. The maximum value of S is 10, the largest stamp denomination is 100, the maximum value of N is 10.				The input is terminated by a data set beginning with zero (S is zero).					
题目输出：
				Output one line for each data set giving the maximal no-gap coverage followed by the stamp denominations that yield that coverage in the following format:				max coverage = <value> : <denominations>				If more than one set of denominations in a set yields the same maximal no-gap coverage, the set with the fewest number of denominations should be printed (this saves on stamp printing costs). If two sets with the same number of denominations yield the same maximal no-gap coverage, then the set with the lower maximum stamp denomination should be printed. For example, if five stamps fit on an envelope, then stamp sets of 1, 4, 12, 21 and 1, 5, 12, 28 both yield maximal no-gap coverage of 71 cents. The first set would be printed because both sets have the same number of denominations but the first set's largest denomination (21) is lower than that of the second set (28). If multiple sets in a sequence yield the same maximal no-gap coverage, have the same number of denominations, and have equal largest denominations, then print the set with the lewer second-maximum stamp denomination, and so on.	
输入样例：
5
2
4 1 4 12 21
4 1 5 12 28
10
2
5 1 7 16 31 88
5 1 15 52 67 99
6
2
3 1 5 8
4 1 5 7 8
0
输出样例：
max coverage =  71 :  1  4 12 21
max coverage = 409 :  1  7 16 31 88
max coverage =  48 :  1  5  7  8
提示：
None



题目：麻将(1349)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
大家都玩过麻将吧，初学麻将的人摸到一张牌时经常不知道自己到底有没有胡了。现在将麻将规则简化：自己手上有14张牌，每张牌只可能是1-9中的一个。胡的标准是14张牌有一对一样的，其他12张牌能分成4组，每组3张牌必须一样或者是连续的3个数。例如，14张牌分别是1 1 1 1 2 3 4 5 6 7 8 9 9 9，我们可以把9 9看成一对，1 1 1，,1 2 3，4 5 6,7 8 9为4组，所以胡了。现在给你任意14张牌，请输出胡了还是没胡
题目输入：
一个整数n，表明有几组测试数据
每组测试数据有14个整数，每个数为1-9，用空格分开。

题目输出：
每组测试数据一行
如果胡了，输出hule，否则输出meihu。

输入样例：
1
1 1 1 1 2 3 4 5 6 7 8 9 9 9

输出样例：
hule
提示：




题目：ChineseSegment(1107)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	前几个星期，ZJS一直在忙他的毕业设计，经过几个星期的努力，他终于完成了。他的毕业设计是关于中文分词的。	总所周知，西方语言书写的时候习惯用空格把单词分开。中文书写词语时是不连贯的，而且词是每个语言的基本组成单位，所以分词（用空格或其他标记把词分开）就成了中文自动分析中很有必要的第一道工序。	在ZJS的毕业设计里面有一个“最大概率算法”。这个算法的描述如下：在进行分词以前我们就已经有了一个可信度很高的带有词频的词典，每个词占一行，在每个词的后面是它的频率，而且这些词是按照词典编撰规律来存储的。当我们进行分词时，根据这个词典找出所有的词，然后找出所有可能的分词路径（即是词串），并且选择一个最佳（也就是说，最大概率）路径作为输出，这个原理的关键之处在于快速的找出最佳路径。为了简单起见，我们把最大概率转化为最小代价，找出代价最小的那条路径作为最佳路径。	fee ( word ) =  - log ( ( fre ( word ) + 1) / MaxFre ), fee ( word )为括号内词的代价，fre ( word )为括号内词出现的频率，这个频率是可以在词典里找到的。我们假设MaxFre为5196588，如果某个词不能在词典里找到，那么这个词的词频为0。	例如，词典的有一部分是这样的：	       成     2871	       成分   160	       合     276	       合成   21	       分     1986	       分子   373	       结     247	       结合   2208	       时     8076	       子     127	把代价转化为频率，得到结果如下：	    成     7.50075       成分   10.3821       合     9.8395	    合成   12.3725       分     7.86913       分子   9.53926	    结     9.95008       结合   7.76322       时     6.46674	    子     10.6115	“结合成分子时”进行分词后可以得到“结/合/成/分/子/时/”, “结合/成/分/子/时/”, “结合/成分/子/时/”, “结合/成/分子/时/”等。	很显然，“结合成分子时”的最佳路径为“结合/成/分子/时”，它的代价在这些路径中是最小的，为31.26997。现在你的任务就是进行中文句子分词，然后输出最佳路径，用“ / ”作为分隔符。为了简单起见，在输入中不含有标点符号和西方语言字母。
题目输入：
第一行是个整数m，代表的是在这个词典里的单词数量，接着是一个上面描述过的词典，里面有m行，每个单词最多有4个字符。然后就是一个整数n，接下来的n行每行都是一个中文句子，句子里没有标点符号，只有中文字符。
题目输出：
N个经过分词后带有分隔符的句子，每个句子占一行。
输入样例：
10
成		2871
成分	160
合		276
合成	21
分		1986
分子	373
结		247
结合	2208
时		8076
子		127
1
结合成分子时

输出样例：
结合/成/分子/时/

提示：
None



题目：Pipe(1006)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The GX Light Pipeline Company started to prepare bent pipes for the new transgalactic light pipeline. During the design phase of the new pipe shape the company ran into the problem of determining how far the light can reach inside each component of the pipe. Note that the material which the pipe is made from is not transparent and not light reflecting.Each pipe component consists of many straight pipes connected tightly together. For the programming purposes, the company developed the description of each component as a sequence of points [x1; y1], [x2; y2], . . ., [xn; yn], where x1 < x2 < . . . xn . These are the upper points of the pipe contour. The bottom points of the pipe contour consist of points with y-coordinate decreased by 1. To each upper point [xi; yi] there is a corresponding bottom point [xi; (yi)-1] (see picture above). The company wants to find, for each pipe component, the point with maximal x-coordinate that the light will reach. The light is emitted by a segment source with endpoints [x1; (y1)-1] and [x1; y1] (endpoints are emitting light too). Assume that the light is not bent at the pipe bent points and the bent points do not stop the light beam.
题目输入：
The input file contains several blocks each describing one pipe component. Each block starts with the number of bent points 2 <= n <= 20 on separate line. Each of the next n lines contains a pair of real values xi, yi separated by space. The last block is denoted with n = 0.
题目输出：
The output file contains lines corresponding to blocks in input file. To each block in the input file there is one line in the output file. Each such line contains either a real value, written with precision of two decimal places, or the message Through all the pipe.. The real value is the desired maximal x-coordinate of the point where the light can reach from the source for corresponding pipe component. If this value equals to xn, then the message Through all the pipe. will appear in the output file.
输入样例：
4
0 1
2 2
4 1
6 4
6
0 1
2 -0.6
5 -4.45
7 -5.57
12 -10.8
17 -16.55
0

输出样例：
4.67
Through all the pipe.

提示：
None



题目：Getthearea(1758)
时间限制：1000MS
空间限制：65535KB
题目描述：
	Weather in Nanjing, known as one of the four hottest stoves in China, is more and more intolerable recently. Especially for the sales promotion staff in summer, the only tool they can use is an old and shabby beach umbrella. There exists a small hole in the center of the umbrella.We can assume that the active area of the beach umbrella is an annulus. And the center is at the origin. The staff want to cover the tree shadow with the shabby beach umbrella .In this case, what they care most is the area of the tree shadow on the 3rd Road  in Nanjing University of Science & Technology they can take advantage of with the shabby beach umbrella.
题目输入：
	The first line contains three numbers: a positive double r1 (0 < r1 ≤ 1000.0) giving the radius of the umbrella; a positive double r2 (0 ≤ r2 ≤ r1) giving the radius of the small hole;and a positive integer m (3 ≤ m ≤ 50) giving the number of vertexes of the shadow. These are followed by m lines, each containing a vertex of the shadow.Two vertexes in adjacent lines are also adjacent on the shadow.
题目输出：
	Output the area of tree shadow they take advantage of with the umbrella.The error of answers in the range of 0.01 will be accepted.
输入样例：
10 0 3
0 20
10 0
-10 0
10 1 3
0 20
10 0
-10 0
输出样例：
144.35
142.78
提示：
None



题目：CalculateSerial(1211)
时间限制：30000 ms
空间限制：65535 ms
题目描述：

Since it can be quite large, it is enough to compute the answer modulo given natural number m.
1 <= a2,m<= 10^9, 2 <= n <= 10^9
One day, Pandadiscovere an interesting array.
1. the length of a1 is always 1 .
2. the length of a2 is given number.
3. an (n > 2) = 2*a2*(an-1)-(an-2)


So he want to know Sum(a1*a1…an*an).
Busy as he is ,he give the mission to snow. And snow is busy eating so he comes to you for help.

题目输入：
firstline:case number t
then t lines, each line three number :a2,n,m

题目输出：
rt
输入样例：
3
2 3 100
1 4 1000
3 3 1000000000

输出样例：
54
4
299

提示：




题目：NumberTriangles(1454)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Consider the number triangle shown below. Write a program that calculates the highest sum of numbers that can be passed on a route that starts at the top and ends somewhere on the base. Each step can go either diagonally down to the left or diagonally down to the right.           7        3   8      8   1   0    2   7   4   4  4   5   2   6   5In the sample above, the route from 7 to 3 to 8 to 7 to 5 produces the highest sum: 30.
题目输入：
There are several test cases, end by EOF, for each test case:The first line contains R (1 <= R <= 1000), the number of rows. Each subsequent line contains the integers for that particular row of the triangle. All the supplied integers are non-negative and no larger than 100.
题目输出：
A single line containing the largest sum using the traversal specified.
输入样例：
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
输出样例：
30
提示：




题目：罗马数字(1654)
时间限制：1000 MS
空间限制：65535 KB
题目描述：
    古罗马帝国开创了辉煌的人类文明，但他们的数字表示法的确有些繁琐，尤其在表示大数的时候，现在看起来简直不能忍受，所以在现代很少使用了。之所以这样，不是因为发明表示法的人的智力的问题，而是因为一个宗教的原因，当时的宗教禁止在数字中出现0的概念！    罗马数字的表示主要依赖以下几个基本符号：    I  1    V  5    X  10    L  50    C  100    D  500    M  1000    这里，我们只介绍一下1000以内的数字的表示法。    单个符号重复多少次，就表示多少倍。最多重复3次。比如：CCC表示300  XX表示20，但150并不用LLL表示，这个规则仅适用于I X C M。    如果相邻级别的大单位在右，小单位在左，表示大单位中扣除小单位。比如：IX表示9  IV表示4  XL表示40 更多的示例参见下表，你找到规律了吗？I,1 II，2III，3IV，4V，5VI，6VII，7VIII，8IX，9 X，10XI，11XII，12XIII,13XIV,14XV,15XVI,16XVII,17XVIII,18XIX,19XX,20XXI,21XXII,22XXIX,29XXX,30XXXIV,34XXXV,35XXXIX,39XL,40L,50LI,51LV,55LX,60LXV,65LXXX,80XC,90XCIII,93XCV,95XCVIII,98XCIX,99C,100CC,200CCC,300CD,400D,500DC,600DCC,700DCCC,800CM,900	CMXCIX,999		由上述提示 根据若干个罗马数字串，输出对应的十进制表示。
题目输入：
	第一行是整数n,表示接下来有n个罗马数字(n<100)。以后每行一个罗马数字。罗马数字大小不超过999。	
题目输出：
序输出n行，就是罗马数字对应的十进制数据。
输入样例：
3
LXXX
XCIII
DCCII

输出样例：
80
93
702

提示：
None



题目：Arbitrage(1350)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Arbitrage is the use of discrepancies in currency exchange rates to transform one unit of a currency into more than one unit of the same currency. For example, suppose that 1 US Dollar buys 0.5 British pound, 1 British pound buys 10.0 French francs, and 1 French franc buys 0.21 US dollar. Then, by converting currencies, a clever trader can start with 1 US dollar and buy 0.5 * 10.0 * 0.21 = 1.05 US dollars, making a profit of 5 percent. Your job is to write a program that takes a list of currency exchange rates as input and then determines whether arbitrage is possible or not.
题目输入：
The input file will contain one or more test cases. Om the first line of each test case there is an integer n (1<=n<=30), representing the number of different currencies. The next n lines each contain the name of one currency. Within a name no spaces will appear. The next line contains one integer m, representing the length of the table to follow. The last m lines each contain the name ci of a source currency, a real number rij which represents the exchange rate from ci to cj and a name cj of the destination currency. Exchanges which do not appear in the table are impossible.
Test cases are separated from each other by a blank line. Input is terminated by a value of zero (0) for n. 

题目输出：
For each test case, print one line telling whether arbitrage is possible or not in the format "Case case: Yes" respectively "Case case: No". 
输入样例：
3
USDollar
BritishPound
FrenchFranc
3
USDollar 0.5 BritishPound
BritishPound 10.0 FrenchFranc
FrenchFranc 0.21 USDollar

3
USDollar
BritishPound
FrenchFranc
6
USDollar 0.5 BritishPound
USDollar 4.9 FrenchFranc
BritishPound 10.0 FrenchFranc
BritishPound 1.99 USDollar
FrenchFranc 0.09 BritishPound
FrenchFranc 0.19 USDollar

0

输出样例：
Case 1: Yes
Case 2: No

提示：




题目：10-20-30(1554)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	A simple solitaire card game called 10-20-30 uses a standard deck of 52 playing cards in which suit is irrelevant. The value of a face card (king, queen, jack) is 10. The value of an ace is one. The value of each of the other cards is the face value of the card (2, 3, 4, etc.). Cards are dealt from the top of the deck. You begin by dealing out seven cards, left to right forming seven piles. After playing a card on the rightmost pile, the next pile upon which you play a card is the leftmost pile. 	 	For each card placed on a pile, check that pile to see if one of the following three card combinations totals 10, 20, or 30. 	1.the first two and last one,	2.the first one and the last two, or	3.the last three cards	If so, pick up the three cards and place them on the bottom of the deck. For this problem, always check the pile in the order just described. Collect the cards in the order they appear on the pile and put them at the bottom of the deck. Picking up three cards may expose three more cards that can be picked up. If so, pick them up. Continue until no more sets ofthree can be picked up from the pile. 	For example, suppose a pile contains 5 9 7 3 where the 5 is at the first card of the pile, and then a 6 is played. The first two cards plus the last card (5 + 9 + 6) sum to 20. The new contents of the pile after picking up those three cards becomes 7 3. Also, the bottommost card in the deck is now the 6, the card above it is the 9, and the one above the 9 is the 5. 	If a 	queen were played instead of the six, 5 + 9 + 10 = 24, and 5 + 3 + 10 = 18, but 7 + 3 + 10 = 20,so the last three cards would be picked up, leaving the pile as 5 9. 		 	If a pile contains only three cards when the three sum to 10, 20, or 30, then the pile "disappears" when the cards are picked up. That is, subsequent play skips over the position that the now-empty pile occupied. You win if all the piles disappear. You lose if you are unable todeal a card. It is also possible to have a draw if neither of the previous two conditions ever occurs. Write a program that will play games of 10-20-30 giveninitial card decks as input.	 
题目输入：
	Each input set consists of a sequence of 52 integers separated by spaces and/or ends of line. The integers represent card values of the initial deck for that game. The first integer is the top card of the deck.Input is terminated by a single zero (0) following the last deck. 
题目输出：
	For each input set, print whether the result of the game is a win, loss, or a draw, and print the number of times a card is dealt before the game results can be determined. (A draw occurs as soon as the state of the game is repeated.) Use the format shown in the ``Sample Output" section. 
输入样例：
2 6 5 10 10 4 10 10 10 4 5 10 4 5 10 9 7 6 1 7 6 9 5 3 10 10 4 10 9 2 1
10 1 10 10 10 3 10 9 8 10 8 7 1 2 8 6 7 3 3 8 2
4 3 2 10 8 10 6 8 9 5 8 10 5 3 5 4 6 9 9 1 7 6 3 5 10 10 8 10 9 10 10 7
2 6 10 10 4 10 1 3 10 1 1 10 2 2 10 4 10 7 7 10
10 5 4 3 5 7 10 8 2 3 9 10 8 4 5 1 7 6 7 2 6 9 10 2 3 10 3 4 4 9 10 1 1
10   5 10 10 1 8 10 7 8 10 6 10 10 10 9 6 2 10 10
0

输出样例：
Win : 66
Loss: 82

提示：
None



题目：QQGameAboutLianLianKan(1108)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	众所周知，lfq198502非常喜欢玩连连看游戏。连连看游戏 ，只要将相同花色的两张牌用三根以内的直线连在一起就可以消除， 规则简单容易上手 。	操作：第一次使用鼠标点击棋盘中的棋子，该棋子此时为“被选中”，以特殊方式显示；再次以鼠标点击其他棋子，若该棋子与被选中的棋子图案相同，且把第一个棋子到第二个棋子连起来，中间的直线不超过 3 根，则消掉这一对棋子，否则第一颗棋子恢复成未被选中状态，而第二颗棋子变成被选中状态	我们可以把连连看的界面想象成一个10×10的方格，每个方格内都放有一种类型的图案或者为空，简单起见，我们用不同的字符代表不同的图案，空格表示没有图案。你的任务是，给出游戏的初始界面，和游戏过程中lfq198502鼠标点击的坐标记录，判断他在这些操作后是否将图案全部消完。	
题目输入：
输入包含多组测试情况，每组情况数据包含两部分。第一部分：10行字符串，每行包含10个字符(空格表示该方格为空，其他字符表示方格中的有用该字符表示的图案)，表示游戏的初始界面。第二部分：首先是一个整数n，表示lfq198502的鼠标点击次数；接下来的n行，每行两个整数x,y（1≤x≤10, 1≤y≤10），表示鼠标点击位置所在的行和列。
题目输出：
每组测试情况输出一行。如果lfq198502能够将图案全部消除，输出“Yes,all pictures are removed!”；否则，输出“No,m picture(s) are left!”；
输入样例：
2
abccba   x
bax       
 ab   8   
         8
          
          
          
@        (
          
  (   @   
18
1 3
1 4
1 2
1 5
1 1
1 6
1 10
2 3
2 2
3 2
3 3
2 1
3 7
4 10
8 1
10 7
10 3
8 10
ab       8
ba        
          
         8
          
          
          
@         
          
      @   
8
1 1
2 2
1 2
2 1
1 10
4 10
8 1
10 7

输出样例：
Yes,all patterns are eliminated!
No,4 pattern(s) are left!

提示：
None



题目：持久找区间极值(1759)
时间限制：6000ms
空间限制：65535kb
题目描述：
 fishhead和鱼儿子一起做游戏。 fishhead给鱼儿子出了大家所熟知的找区间极值的问题，线段树解决。 fishhead给了N个数字，N比较大，然后需要询问M次，M也比较大，每次给出一个L和R，需要找到[L,R]的区间里的最大的数字。  fishhead给鱼儿子的任务是，在很快的时间内给出大量查询的结果。 聪明的鱼儿子很快解决了这个问题，fishhead对此无法直视了，数据结构居然比爹还强，果断不能忍。 为了显示fishhead自己数据结构的超强实力，于是他出了下面一个问题。 现在fishhead增加改变功能，他可以把一个数字改变成另外一个数字，同时，会记录他改变的次数。 fishhead想要知道，在他执行第i次变换之后，指定的[L,R]区间里的最大值是多少呢，当然，fishhead会给出很多的查询，你需要很快解决这个题目。 鱼儿子犯难了，所以向你请求帮助。
题目输入：
 第一行输入T(T约为10)，表示有T组测试数据。 每组测试数据，第一行首先输入两个整数N，M(1<=N<=50000，1<=M<=100000) 第二行输入N个整数，表示原数组，整数在int范围内。 下面M行，有两种输入形式： 1 a c 2 a b c 另外记录一个偏移量d，对于1操作，对于第a+d个数字变成c+d，对于2操作，输出第c+d次操作后，在区间[a+d, b-d]内的最大值。 对于每组测试数据，d一开始为0，对于每次2操作，e表示输出的整数中，取绝对值后其二进制数1的个数，则有d=d+e。 我们保证在1操作里1<=a+d<=N，2操作里1<=a+d<=b-d<=N，0<=c+d<=当前输入的1操作个数，c+d=0表示原序列，即一次操作都没有。
题目输出：
 对于每次2操作，输出相应的最大值。
输入样例：
1
5 4
1 2 3 4 5
1 2 4
1 5 -1
2 1 3 1
2 2 6 1
输出样例：
4
4
提示：
None



题目：Asimpleproblem(1212)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The  Description is very simple.There are n ( n < 100 ) convex polygon,please tell  me the intersection area of n convex polygon.Each convex polygon at most  have  10 points.
题目输入：
There are multiple test cases.The first line contain a integer t( t < = 10 ), indicate t cases.For each case,the first line contain a integer n,indicate n convex polygon,then next n lines contain the information of the n convex polygon.Each line contain a integer m,indicate the num of point of the convex polygon. Then give you m points by anticlockwise.
题目输出：
For each case,print  the intersection area of n convex polygon.( accurate up to 1 decimal place)
输入样例：
1
2
3 0.0 0.0 2.0 0.0 1.0 2.0
3 1.0 0.0 3.0 0.0 2.0 2.0

输出样例：
0.5
提示：
None



题目：RailwayStation(1007)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
There is a straight railway in one country. Beside the railway, there are several cities. The railway is represented as an integer axis. The position of each city is identified with a single integer coordinate. Of course there are no 2 cities in the same position.
Now the government needs to build some railway stations around the railway. Railway stations must be built in the cities. Since the government wants to save money, railway stations will not be built in all the cities. Here comes the question, how to build the stations in the proper cities, so that people in all cities will be convenient to travel by train?
In detail, these most convenient positions should be chosen so that the total sum of all distances between each city and its nearest railway station is minimum.
The government just asks you, the cleverest boy or girl in NJUST, to write a program to solve this problem. You will be given the positions of the cities and the number of railway stations, computes the least possible sum of all distances between each cities and its nearest railway station.
题目输入：
Your program is to read from standard input. The input will contain several test cases. In each cases, the first line contains two integers: the first is the number of cities C, 1 <= C <= 300, and the second is the number of railway stations R, 1 <= R <= 30, R <= C. The second line contains the position of each city in increasing order. For each position X, it holds that 1 <= X <= 10000.
Input will be ended if (C == 0 && R == 0).
题目输出：
Each line contains one integer S, which is the minimum sum of all distances between each city and its nearest railway station in this case.
输入样例：
10 5
1 2 3 6 7 9 11 22 44 50
0 0
输出样例：
9
提示：




题目：TheHardestProblemEver(1655)
时间限制：1000ms
空间限制：65535Kb
题目描述：
	Pbatenghyngvbaf gb lbh gung lbh unir fbyirq gur svefg cneg bs gur ceboyrz gb haqrefgnaq gur zrnavat bs gur ceboyrz . Gur arkg cneg bs gur ceboyrz vf irel rnfl . Lbh whfg arrq gb pnyphyngr gur ahzore bs mrebf va gur tvira fgevatf !
题目输入：
	 	Gur svefg svther G vf gur Pnfr ahzore .Gura pbzrf G yvarf .Rirel yvar pbagnvaf n fgevat jvgu gur yratgu ng zbfg 1000 punenpgbef.	
题目输出：
	 	Bar yvar cre pnfr,gur ahzore bs mrebf va gur fgevat.	
输入样例：
3
10
11
101110001

输出样例：
1
0
4

提示：

	题目是乱码？没看懂题目？很正常~


	世上最难的题目是什么？——是根本看不懂题目


	


	学长温馨提示：需要输入字符串的时候，不要用gets哦，可以用scanf或者cin




题目：PrimePalindromes(1455)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The number 151 is a prime palindrome because it is both a prime number and a palindrome (it is the same number when read forward as backward). Write a program that finds all prime palindromes in the range of two supplied numbers a and b (5 <= a < b <= 100,000,000); both a and b are considered to be within the range .
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  Two integers, a and b
题目输出：
The list of palindromic primes in numerical order, one per line.
输入样例：
5 500
输出样例：
5
7
11
101
131
151
181
191
313
353
373
383
提示：
Generate the palindromes and see if they are prime. Generate palindromes by combining digits properly. You might need more than one of the loops like below./* generate five digit palindrome: */for (d1 = 1; d1 <= 9; d1+=2) {	/* only odd; evens aren't so prime */    for (d2 = 0; d2 <= 9; d2++) {        for (d3 = 0; d3 <= 9; d3++) {	    palindrome = 10000*d1 + 1000*d2 +100*d3 + 10*d2 + d1;	    ... deal with palindrome ...	}    }}



题目：Alfredo'sPizzaRestaurant(1353)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Traditionally after the Local Contest, judges and contestants go to their favourite restaurant, Alfredos Pizza Restaurant. The contestants are really hungry after trying hard for five hours. To get their pizza as quickly as possible, they just decided to order one big pizza for all instead of several small ones. They wonder whether it is possible to put the big rectangular pizza on the surface of the round table such that it does not overhang the border of the table. Write a program that helps them!
题目输入：
The input file contains several test cases. Each test case starts with an integer number r, the radius of the surface of the round table the contestants are sitting at. Input is terminated by r=0. Otherwise, 1 ≤ r ≤ 1000. Then follow 2 integer numbers w and l specifying the width and the length of the pizza, 1 ≤ w ≤ l ≤ 1000. 
题目输出：
Output for each test case whether the ordered pizza will fit on the table or not. Adhere to the format shown in the sample output. A pizza which just touches the border of the table without intersecting it is considered fitting on the table, see example 3 for clarification. 
输入样例：
38 40 60
35 20 70
50 60 80
0

输出样例：
Pizza 1 fits on the table.
Pizza 2 does not fit on the table.
Pizza 3 fits on the table.


提示：




题目：BangtheDrumSlowly(1555)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	Many years ago the “primary memory” of most computer systems was a magnetic drum. Read/write heads were placed so they could access data from the magnetic outer surface as the drum rotated along its horizontal axis. The following illustration gives the basic idea: 		As the drum rotated, the data word under the read/write head(s) could be accessed. The drum continued to rotate after an instruction was fetched. After the execution of an instruction, the word ready to be accessed by the read/write head(s) was typically many words away. To minimize the delay that would occur if instructions to be executed sequentially were placed in consecutive words on the drum, designers of these machines frequently included the next instruction's drum address as a field in the instruction (that is,each instruction included an explicit ``next instruction" address). Then ``optimizing" assemblers could fill in the next instruction field with the address of the first available word ready to be read by the drum as soon as the current instruction was completed. 	 	In this problem we want to determine the average execution times of simple programs without loops. We will consider only a single read/write head on a single track. Assume that the words on that track have sequential addresses numbered 1 through n. All instructions require the same length of time to execute, specifically the same time as it takes the drum to rotate past twords. t does not include the time to read the instruction from the drum, nor does it include the additional rotational delay that might be required if the next instruction isn't at the ``optimum" address. However, these factors must be included in calculating the average execution time. 	 	There are three types of instructions: terminal, conditional and unconditional. Terminal instructions don't have a ``next instruction" address, since they terminate the execution of a program. Conditional instructions have two ``next instruction" addresses, and unconditional instructions have only one ``next instruction" address. 	 	The execution time of a program run is the time taken from beginning to read the first instruction until the terminal instruction has executed. To calculate the average execution time of a program, every possible run time is weighted (multiplied) by the probability of the run. We assume equal probability of taking each path of a branch in a conditional instruction. The sum of all weighted run times is the average execution time of the program. 	 	 
题目输入：
The input consists of a number of test cases. The input for each test case begins with a line containing integer values for n (1 < n < 50) and t (0 < t< n). This line is followed by a sequence of lines each of which contains integers representing an instruction address and zero, one, or two branch addresses. Specifically, for each instruction there is a location (between 1 and n), the number of ``next instruction" addresses (0 for a terminal instruction, 1 for an unconditional instruction, and 2 for a conditional instruction), and that many branch addresses. The last instruction is followed by 0 on a line by itself. The input set is terminatedby values of 0 for both n and t.
题目输出：
For each test case, print the case number (they are numbered sequentially starting with 1) and the average execution time for the program. Execution times must be accurate to and displayed with four fractional digits.
输入样例：
10 5
1 0
0
10 5
1 1 6
6 0
0
10 5
1 1 7
7 0
0
10 5
1 2 7 8
7 0
8 0
0
10 6
8 0
7 1 3
3 0
1 2 7 8
0
0 0

输出样例：
Case 1. Execution time = 6.0000
Case 2. Execution time = 21.0000
Case 3. Execution time = 12.0000
Case 4. Execution time = 12.5000
Case 5. Execution time = 26.5000

提示：

	  


	Assumptions: 


	•At the 


	     beginning of each test case the drum is positioned so that the instruction 


	     at location 1 is about to be read. 


	•Each program 


	     begins execution with the word in location 1. 


	•The time to 


	     read an instruction is one time unit. 


	•There will 


	     always be at least one terminal instruction, but there may be several. 


 

	




题目：同色游戏(1109)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	N个学生排成一排，每个学生都穿着某一种颜色的服装。一共有m种颜色，因此每一种颜色都可以用0到m-1之间的一个数字表示。吴老师想让他的学生都只同一种颜色的衣服，	因此他需要一些操作。我们都知道吴老师是一个非常奇怪的人，如果某个学生穿着第i种颜色的衣服而且吴老师想让这个学生换别的颜色，他在一次操作中只让这个学生换成第（i+1）%m种颜色的服装。更加奇怪的是，吴老师总是让连续的t个学生一起改变他们服装的颜色。现在问题来了，我们给你参数n,m和t（n<2000,m<150,t<n），而且告诉你开始的时候各个学生服装的颜色，让你计算出最少需要多少次操作可以使得每个学生都穿同一种颜色的服装。
题目输入：
在输入的第一行是k<=30，表示有多少组测试数据。对于每一种测试数据，有三个输入数据,n,m,t.接着是一行n个数字ai (i=1,2…n), (0<=ai<=m-1).ai  表示第i个学生衣服的颜色。
题目输出：
对于每一种测试数据，你需要在一行中输出两个数据，分别是所需要的最少的操作次数和最后学生衣服的颜色。如果有两种颜色可以通过相同的操作次数得到，你只需要输出较小数字所代表的颜色。题目保证对于所有的测试数据均可以通过某种操作使得所有的学生都穿同一种颜色的服装。
输入样例：
1
7 2 3
0 0 1 0 1 0 0

输出样例：
3 1
提示：
None



题目：尺规作图(1760)
时间限制：5000MS
空间限制：131072KB
题目描述：
	我们知道古时作图可用尺规，有时候仅用尺子也同样可以作图。例如，现在我们有N个点，可以选择任意2点做一条线段，在这些线段中，通过相交可以得到新的交点。这样我们就不断的扩大了原来的点集。但是手工作图难免不够精确，于是聪明的你借助计算机来达到“数学上”的严谨。现在你要求的是，从这N个点出发可以得到的新的点的个数（重复的当然只算一个），并且求出最终可以覆盖这所有点的凸多边形的面积。
题目输入：
	第一行为N，2<=N<50	接下来为N行，格式为 Xi Yi (-10^18 <= Xi,Yi <= 10^18)
题目输出：
	每一组输出一行S，A	S为新增的点的个数	A为最终的面积(如果不是整数，请用既约分数表示)
输入样例：
4
1 1
1 -1
-1 -1
-1 1
输出样例：
1 4
提示：
None



题目：Ballons(1213)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Every ACMer loves ballons very much.Doesn't it?Now,it's a mission about ballons.There is a n*n matrix board on the groud, and each has a balloon in it.They are floating in the sky by thread.Because of the different length of thread,the ballons have different heights.Mr Yu asks you to get all the ballons just in K times.What's more, each time you can only choose a single row or column of balloon and crash the ballons.Of course,it's a very hard problem.But messIDou is helpful for you.Before you do this mission.He will take the balloons that are higher than P( "P" is a integer.) away.Mr Yu is angry for this.So he commands messIDou: the "P" must as high as possible.Could you tell messIDou what the number "P" is?
题目输入：
The first line of the input contains an integer T (T < = 100), indicating the number of cases. Each case begin with two integers N ( 0 < N < = 100) and K ( 0 < K < = N) as described above.Next n lines each contains n integers.It's the height of the ballon in this grid.(0 < height[i][j] < = 1000000)
题目输出：
Each case contains just one line.If messIDou need not to take any ballon away,print "I can do!".Otherwise print the number "P".
输入样例：
2
2 2
1 2
3 4
3 1 
1 2 3
4 5 6
7 8 9

输出样例：
I can do!
3

提示：
None



题目：TheShadow(1008)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
When this semester is over, fish-head feels extremely sorry about the oldest teammates’ leaving. So he gathered all the teamers, went out for photos. Sunsets beautifully shone at the horizon and all the teamers stood in line and got lost in the scene.
Fish-head suddenly found the shadow of teamers was kind of funny. All the teamers were so strong that their shadow almost became rectangle!
Now fish-head wants to know how much the area of the shadow down there.
Everyone’s shadow is lined up straight towards the sun so we just regard it as a line and each shadow as rectangle. Each rectangle has 3 parameters: Ai, Bi, Hi. The shadow begins with Ai (point), ends with Bi (point), and its height is Hi.
题目输入：
Line 1: A single integer: N(1 ≤ N ≤ 40,000) represents the number of teamers.
Lines 2..N+1: Input line i+1 describes shadow i with three space-separated integers: Ai, Bi, (1 ≤ Ai < Bi ≤ 1,000,000,000) and Hi(1 ≤ Hi ≤ 1,000,000,000).
题目输出：
Line 1: The total area, in square units, of the pattern formed by all N teamers’ shadow.
输入样例：
4
2 5 1
9 10 4
6 8 2
4 6 3
输出样例：
16
提示：




题目：OptionalArrayPermutation(1656)
时间限制：2000ms
空间限制：65535Kb
题目描述：
	There is an array which consists of a set of n numbers (1..n, respectively). Differing from original meaning of array permutation, this problem contains several constraints restricting some permutation from being legal. Every constraint is a vector composed by a pair of integers A and B, saying that the A are supposed to be ahead of B. For example, as for one of the permutation 2 1 3 4 in the case of n=4, it satisfies the constraint (2,1) (2,3) (2,4), while it doesn't satisfy(3,2)(3,1),(3,4) etc. So much so that, how much is number of different legal permutations that satisfy all of the given constraint?
题目输入：
	There are several test cases. 	For each test case, the first line contains one positive integer n (n<=16) as the information said above. The following contains n lines, each of which containsn integers, the element at ith row and jth column is either 1 or 0. Legal permutation should satisfy the constraint (i, j) if and only if the value ofthe element is 1. You can assume that any pair of (i, j) is bound to be 0 if i is equal to j.	The input ends with EOF.
题目输出：
	For each test case, output the number of different legal permutations mod 10007.
输入样例：
2
0 1
1 0
3
0 0 0
0 0 0
0 0 0
3
0 0 0
1 0 0
0 1 0
3
0 0 0
0 0 1
0 0 0

输出样例：
0
6
1
3

提示：
None



题目：BrokenKeyboard(1354)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Bruce Force's keyboard is broken, only a few keys are still working. Bruce has figured out he can still type texts by switching the keyboard layout whenever he needs to type a letter which is currently not mapped to any of the m working keys of the keyboard. 
You are given a text that Bruce wishes to type, and he asks you if you can tell him the maximum number of consecutive characters in the text which can be typed without having to switch the keyboard layout. For simplicity, we assume that each key of the keyboard will be mapped to exactly one character, and it is not possible to type other characters by combination of different keys. This means that Bruce wants to know the length of the largest substring of the text which consists of at most m different characters.
题目输入：
The input contains several test cases, each test case consisting of two lines. The first line of each test case contains the number m (1 ≤ m ≤ 128), which specifies how many keys on the keyboard are still working. The second line of each test case contains the text which Bruce wants to type. You may assume that the length of this text does not exceed 1 million characters. Note that the input may contain space characters, which should be handled like any other character. 

The last test case is followed by a line containing one zero.

题目输出：
For each test case, print one line with the length of the largest substring of the text which consists of at most m different characters.
输入样例：
5
This can't be solved by brute force.
1
Mississippi
0

输出样例：
7
2

提示：
The largest substring for the first test case is "_by_bru", where _ stands for a space character. 



题目：SuperprimeRib(1456)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Butchering Farmer John's cows always yields the best prime rib. You can tell prime ribs by looking at the digits lovingly stamped across them, one by one, by FJ and the USDA. Farmer John ensures that a purchaser of his prime ribs gets really prime ribs because when sliced from the right, the numbers on the ribs continue to stay prime right down to the last rib, e.g.:      7  3  3  1The set of ribs denoted by 7331 is prime; the three ribs 733 are prime; the two ribs 73 are prime, and, of course, the last rib, 7, is prime. The number 7331 is called a superprime of length 4. Write a program that accepts a number N 1 <=N<=8 of ribs and prints all the superprimes of that length. The number 1 (by itself) is not a prime number.
题目输入：
There are several test cases, end by EOF, for each test case:A single line with the number N.
题目输出：
The superprime ribs of length N, printed in ascending order one per line.
输入样例：
4
输出样例：
2333
2339
2393
2399
2939
3119
3137
3733
3739
3793
3797
5939
7193
7331
7333
7393
提示：




题目：Addnumber(1110)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Employees of Baidu like to play a game called Making Numbers. It goes like this: there are two players in the game, one is called little A, the other little B. There are some cards with a number on each one of them, little A chooses a number X from 1 to N randomly, while little B has to choose some cards, the sum of which equals X. Now there are already M cards with numbers, and K blank cards. At the beginning of the game, little B is allowed to write numbers on the blank cards. Now little B wants to know, if it is possible to write some numbers that will assure him of the victory, that is to say, if it is possible for him to make up any number from 1 to N with the cards.
题目输入：
The input consists of several test cases. The first line is an integer T , in the second line of each case are 3 numbers, N M K, the second line shows the number that is already written on M cards. 0 < N < 100000000 , 0 < = M  < 20 , 0 < K < 20The numbers in the second line are above 0, smaller than or equals N, in non-descending order.
题目输出：
If little B can make it, output "YES", else output "NO".
输入样例：
3
15 0 4 
12 3 2
3 3 3
13 3 2
3 3 3

输出样例：
YES
YES 
NO


提示：
None



题目：PatternMatchingPrelims(1556)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	Some algorithms for optical character recognition compare a scanned imagewith templates of ``perfect" characters. Part of the difficulty with suchcomparisons is deciding where to start the comparison. This is because thecharacters in the scanned image are subject to noise and distortion, resultingin changes in size, position, and orientation. 	A procedure that is sometimes used to deal with changes in positionmatches the ``center of gravity" of the scanned character and thetemplates against which it is compared. In this problem you are to determinethe ``centers of gravity" of scanned images of characters. 	For our purposes, a scanned image will be a rectangular array of realnumbers, each of which represents the gray-scale value of a point in a scannedimage. Each gray-scale value will be between 0 (representing a totally whiteregion) and 1 (representing a totally black region). The array will have nomore than 25 rows and 25 columns. 	The center of gravity is a particular element of an array. Suppose acenter of gravity is in the ith row and jth column. Then the difference betweenthe sum of the elements of the two array portions above and below the ith rowis minimal. Likewise, the difference of the sums of the elements in the twoarray portions to the left and to the right of the jth column is minimal. 	Consider the array shown below, which might have resulted from scanning alower case ``o." The center of gravity for this array is uniquely in row3, column 3. The difference of the sum of the elements in each array portionformed by ignoring the third row is 0.1 (the sums are 5.55 and 5.65). Thedifference of the sum of each array portion formed by ignoring the third columnis 0.0 (the sums are both 5.60).	 	
题目输入：
	The input will consist of a sequence of scanned character images. Inputfor each image will begin with two integers specifying the number of rows andcolumns in the scanned data. This will be immediately followed by the scannedgray-scale data given in row-major order. A pair of zeroes will follow the datafor the last input image. 
题目输出：
	For each input character image, display its number (they are sequentiallynumbered starting with 1) and the row and column corresponding to the center ofgravity. If there is more than one center of gravity, the one with the largestrow and column should be displayed. The sample that follows illustrates areasonable output format. 
输入样例：
5 5
0.1 0.2 0.1 0.2 0.1
0.1 0.2 0.3 0.1 0.1
0.2 0.3 0.1 0.1 0.3
0.4 0.1 0.1 0.1 0.2
0.2 0.2 0.3 0.3 0.1

5 10
0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1
0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2
0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3
0.4 0.4 0.4 0.4 0.4 0.4 0.4 0.4 0.4 0.4
0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.6

0 0

输出样例：
Case 1: center at (3, 3)
Case 2: center at (4, 6)
提示：
None



题目：Competition(1214)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Each ACMer has a unique programing rank. To improve their skill rank, Mr Yu commands that they should compete with each other.But it's no suspense for some new ACMers because of their ranks.So messIDou proposes:two ACMers can be made up as a team to challenge a ACMer whose rank is higher than both of them.It's so interesting. But to be unfair,the two lower rank ACMers can't communicate with each other.So messIDou wants the higher rank ACMer must stand between the two lower rank ACMers.Now N ( 3 <= N <= 20000 ) ACMers are standing in a line segment and you can't change their positions.Could you tell me how many different competition can be hold.   
题目输入：
The first line of the input contains an integer T(1<=T<=20), indicating the number of test cases, followed by T lines each of which describes a test case.Every test case consists of N + 1 integers. The first integer is N, the number of ACMers. Then N distinct integers a1, a2 … aN follow, indicating the programing rank of each ACMer, in the order of standing now. (1 <= ai <= 100000, i = 1 … N).
题目输出：
For each test case, output a single line contains an integer, the total number of different competition.
输入样例：
2
5 1 2 3 4 5
5 2 4 1 7 9

输出样例：
0
1

提示：
None



题目：柯南的数学题(1761)
时间限制：1000MS
空间限制：131072KB
题目描述：
	众所周知，柯南小童鞋是一个高智商的小学生。	一天，他碰到了一道奇怪的数学题：求函数值f(n) = （a ^ g(n)）% p，其中p一定为质数，	而函数g(n)在旁边有这样一段话：@#￥%……&×@#￥%……&×，njust，{1,1,0,0,0}。	柯南童鞋完全看不懂那句话，通过猜测，他明白了，g(n)函数是指njust五个字母，可重复出现，并且其中“n”与“j”两个字母必须出现，且以奇数个出现，“u”“s”“t”没有限制条件的情况下，总共出现n个的排列数。柯南童鞋这下犯难了，这要计算太多了，所要柯南童鞋请你写程序帮他解决这个问题。	
题目输入：
	每个样例一行，格式为：a n p，意思如题目所言。	0<=a,n<=2^31-1.,1<p<1000000	
题目输出：
	对于每个样例在一行中输出f(n)。
输入样例：
2 2 7
1 3 11

输出样例：
4
1
提示：
None



题目：Zen'sGarden(1009)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Zen's Garden is eagerly waiting for you who are obviously a genius. The little snail in the garden needs your help with collecting silver coins.
In this lovely garden there're a lot of plants which can produce coins randomly. Coins can come out from any plant at any place at any time. At the very beginning (time is began with 0), our snail will be at the coordinate (0, 0) ready for coins' coming up and going over to collect them.
But we should pay more attention to two things. It will take 10 seconds from a coin shows up to its vanish. And the snail is at the const speed of 10 per seconds unless he stops. It still works if little snail reach the coin at the moment it vanishes.
Now I give you a set of coins' information, please tell little snail if he can collect all the coins. If the answer is yes, please give the fastest time to collect all.
题目输入：
There are multiple cases. Each case has (n+1) lines.
First line is a number n (n<31), indicates the number of coins.
For each coin there is a line with 3 numbers: t (t>=0), x and y (x, y>=0). The coin will show up at the time of t, and the place of (x, y). 
题目输出：
Each case one line is needed. If you can find the fastest way please give the shortest time (accurate to 0.001). Or you can print -1 if you can't find one.
输入样例：
1
1 100 100
1
200 100 100
输出样例：
-1
200.000
提示：




题目：Fib&&Gib(1657)
时间限制：1000ms
空间限制：32768Kb
题目描述：
	Have you heard the famous sequence called the Fibonacci Sequence, or Fib for short? HJWAJ loves this sequence very much. One day HJWAJ, getting bored, started playing with it again.	But HJWAJ’s girlfriend, wdyswdjl, hates maths very much. She doesn’t want HJWAJ to be immersed in his maths world. She said, “HJWAJ, why do you love sequences so much? If I make a sequence based on Fib, you will never like playing with it again. Let’s bet!” So she created another sequence called Gib Sequence. If HJWAJ couldn’t work out with the sequence, he would get frustrated and his GF would never permit him to play with maths again. Now HJWAJ have no idea to deal with the sequence, so it’s time for you, the most brilliant programmer, to help him.	The Gib Sequence is defined by four variables a, b, n, p. For any group of given (a, b, n, p), the sequence is denoted as		
题目输入：
	The first line contains an integer T(T<=20), representing T cases followed.	Then comes T lines. Each line contains 4 integers, a, b, n, p.All the integers are positive and will never be larger than 2000000000(i.e.2*10^9), p is an odd prime number and a, b < p.	 
题目输出：
	For each testcase, first output “Case #i: ”, then a number followed representing the result of the sequence. The variable i means the ith testcase.	 
输入样例：
2
2 3 1 10007
2 3 2 10007

输出样例：
Case #1: 40
Case #2: 392

提示：

	(1)


	The Fib Sequence is denoted as below:


	Fib(n)=1, n==0 || n==1;


	Fib(n)=Fib(n-1) + Fib(n-2), n>1.


	(2)


	In this problem you may need to use a
famous theorem in number theory called Euler’s Theorem.


	It states that:


	Given two positive integers a and n, if a and n are
coprime, then aphi(n)mod n=1


	We define phi(n) as the number of integers which are not greater than n and are coprime with n.


	(3)


	In this problem you may need to use a
commonly used skill in ACM. If you have a linear recursion formula to
calculate, you may use the matrix to prior the calculation—I think all of you
have learnt linear algebra, right? Here is an example below.


	Given A0=a, A1=b, An = p*A(n-1) + q*A(n-2)(n>2).
You can make such matrix:


	 


	So, after iterating we can get:

 

	Then, assuming A is a matrix, to calculate
A^n, we can use binary algorithm below: 


	If n is odd, A^n = ( A^(n/2) )^2 *A;


	If n is even, A^n = ( A^(n/2) )^2.


	This can save large amount of time so you
may avoid from TLE.




题目：ConvertKilometerstoMiles(1355)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
This year, Bruce Force spends his vacation in Flagstaff, Arizona, where he wants to practice for his next half marathon (a race over 21 km). At his first training he runs to his friend Greedy Gonzales' home which is 21 miles away from Flagstaff. 
Arriving there, he is very tired and realizes that 21 miles are much more than 21 km. Greedy Gonzales tells him that 21 km equals 13 miles. 21, 13? Bruce realizes immediately that there must be a deeper relation! Both, 13 and 21 are Fibonacci numbers! 
Fibonacci numbers can be defined as follows: 

F1 = 1 
F2 = 2 
Fn+1 = Fn+Fn-1 for n>1. 

Bruce has just learned about the Fibonacci number system at his university. Each positive integer x can be written as the sum of different Fibonacci numbers, so this means that there exists numbers k and b1, b2, ..., bk such that x = ∑i=1..k bi * Fi, where bk = 1 and bi (1 ≤ i < k) is either 0 or 1. In short, we can write the representation as: b(x) = (bk, bk-1, ..., b1). To make the representation unique, we require that bi * bi-1 = 0 for all i > 1. 
For example 21 can be represented as (1,0,0,0,0,0,0) and 13 as (1,0,0,0,0,0) in the Fibonacci system. Bruce notices that one can convert a distance x in kilometers into a corresponding distance y to miles as follows: First, write down x in its Fibonacci system representation b(x). Second, shift the bits of b(x) one position to the right (the last bit is deleted) and get b(y). Third, calculate y from b(y) by evaluating the sum given above. 
For example, the number 42 written in the Fibonacci system is (1,0,0,1,0,0,0,0). In step two we would shift the bits one position to the right and get (1,0,0,1,0,0,0). In the third step, we would calculate 0*1 + 0*2 + 0*3 + 1*5 + 0*8 + 0*13 + 1*21 = 26. 
Now it's your turn to write a program for Bruce that converts kilometers into miles according to Bruce's algorithm.
题目输入：
The first line of the input contains t, the number of distances Bruce wants to convert from kilometers to miles (0
            
题目输出：
For each distance x in kilometers output the distance y in miles calculated according to Bruce's algorithm.
输入样例：
5
42
100
180
300
360

输出样例：
26
62
111
185
222

提示：




题目：CheckerChallenge(1457)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
Examine the 6x6 checkerboard below and note that the six checkers are arranged on the board so that one and only one is placed in each row and each column, and there is never more than one in any diagonal. (Diagonals run from southeast to northwest and southwest to northeast and include all diagonals, not just the major two.)           Column    1   2   3   4   5   6  -------------------------1 |   | O |   |   |   |   |  -------------------------2 |   |   |   | O |   |   |  -------------------------3 |   |   |   |   |   | O |  -------------------------4 | O |   |   |   |   |   |  -------------------------5 |   |   | O |   |   |   |  -------------------------6 |   |   |   |   | O |   |  -------------------------The solution shown above is described by the sequence 2 4 6 1 3 5, which gives the column positions of the checkers for each row from 1 to 6: ROW    1 2 3 4 5 6 COLUMN 2 4 6 1 3 5 This is one solution to the checker challenge. Write a program that finds all unique solution sequences to the Checker Challenge (with ever growing values of N). Print the solutions using the column notation described above. Print the the first three solutions in numerical order, as if the checker positions form the digits of a large number, and then a line with the total number of solutions. Special note: the larger values of N require your program to be especially efficient. Do not precalculate the value and print it (or even find a formula for it); that's cheating. Work on your program until it can solve the problem properly. If you insist on cheating, your login to the USACO training pages will be removed and you will be disqualified from all USACO competitions. YOU HAVE BEEN WARNED.
题目输入：
There are several test cases, end by EOF, for each test case:A single line that contains a single integer N (6 <= N <= 13) that is the dimension of the N x N checkerboard.
题目输出：
The first three lines show the first three solutions found, presented as N numbers with a single space between them. The fourth line shows the total number of solutions found.
输入样例：
6
输出样例：
2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4
提示：
Hint 1Use recursion:     function placequeen(column) {   # place columns 0..max-1	if (column == max) { deal with answer; return; }        for (row = 0; row < max; row++)  {            if (canplacequeen (row)) {		mark queen placed at column,row;		placequeen(column+1);		un-mark queen placed at column,row;	    }        }    }Hint 2Do everything you can to eliminate loops (searching) in the part of your program executed most frequently. Usually, the best way to do this is to 'trade memory for speed'. When checking to see if a queen can be placed in a given row, for example, store a row status list that says if a queen is already stored there or not:     function placequeen(column) {   # place columns 0..max-1	if (column == max) { deal with answer; return; }        for (row = 0; row < max; row++)  {            if (rowok[row] && canplacequeen(row,column)) {		rowok[row] = 1;		mark queen placed at column,row;		placequeen(column+1);		un-mark queen placed at column,row;		rowok[row] = 0;	    }        }    }Hint 3Do *absolutely everything* you can to eliminate loops (searching) in the part of your program executed most frequently. Keep track not only of the rows that are legal for queen placement but also which of the two sorts of diagonals (the ones that are like a '/' and the others that are like '\' by using an array of size 2*max - 1 that records whether a diagonal is legal or not. Hint 4SYMMETRY. Can you eliminate half or 3/4 of the cases you test by studying rotations, reflections, or something like that? [hint: yes] Hint 5Still over time? If you have programmed modularly and have little subroutines to check diagonals, etc., move that code into the main execution stream. The subroutine call overhead is nontrivial. Hint 6 for JAVA programmersMost successful Java solutions store their 'this column used' marks as bits in a word.



题目：Route(1111)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
	在三国演义中，四川省饱含了许多美丽，激动人心和神秘的故事。尤其是古代剑门径是一个拥有美丽风光和文化的良好度假场所。最激动人心的故事就是关羽的千里走单骑。话说关羽当年一听到他结拜兄弟刘备的下落，就马上放弃了曹操给他的优厚条件，带上刘备的家眷去找刘备。关羽从许都出发，历经艰辛，最后在古城找到了刘备。现在你的任务是为关羽设计一条新的路线来寻找他的兄长。假设关羽知道从许都到古城的所有关口的连通情况，并且知道在每个关口打败守卫并安全离开的概率。请帮助关羽找一条能成功从许都逃往古城的最大概率的路线。关羽不能去同一个关口两次。
题目输入：
输入数据的第一行包含了一个整型数T(1 <= T <= 50). T代表输入数据的数量。对于每组测试数据，第一行只包含一个整数N(3 <= N <= 1000).接下来的N行是一个表示关口之间的连通性的矩阵。如果第i行第j列的数是1，这意味着从关口i到关口j是连通的。否则，0表示从关口i到关口j是不连通的。每组测试数据的最后一行是N-2个用空格分隔开的实数，每个实数表示关羽安全通过该关口的概率P(0 <= P <= 1)。
题目输出：
对于每组测试数据，你需要输出一行，包含一个实数，表示关羽安全到达古城的最大概率。这个实数需要精确到小数点后4位。如果结果小于0.0001，那么输出“Cannot reach!”
输入样例：
3
3
0 1 0
0 0 1
0 0 0
0.5
4
0 1 0 0
0 0 1 0
0 0 0 1
0 0 0 0
0.01 0.001
6
0 1 1 0 0 0 
0 0 1 1 0 0
0 0 0 1 1 0
0 0 1 0 1 1
0 0 0 0 0 1
0 0 0 0 0 0
0.2 0.1 0.6 0.3

输出样例：
0.5000
Cannot reach!
0.1200

提示：
None



题目：SystemDependencies(1557)
时间限制：3000 ms
空间限制：655350 ms
题目描述：
	Components ofcomputer systems often have dependencies--other components that must beinstalled before they will function properly. These dependencies are frequentlyshared by multiple components. For example, both the TELNET client program andthe FTP client program require that the TCP/IP networking software be installedbefore they can operate. If you install TCP/IP and the TELNET client program,and later decide to add the FTP client program, you do not need to reinstallTCP/IP.	For some components it would not be a problem if the components on which theydepended were reinstalled; it would just waste some resources. But for others,like TCP/IP, some component configuration may be destroyed if the component wasreinstalled.	It is useful to be able to remove components that are no longer needed. Whenthis is done, components that only support the removed component may also beremoved, freeing up disk space, memory, and other resources. But a supportingcomponent, not explicitly installed, may be removed only if all componentswhich depend on it are also removed. For example, removing the FTP clientprogram and TCP/IP would mean the TELNET client program, which was not removed,would no longer operate. Likewise, removing TCP/IP by itself would cause thefailure of both the TELNET and the FTP client programs. Also if we installedTCP/IP to support our own development, then installed the TELNET client (whichdepends on TCP/IP) and then still later removed the TELNET client, we would notwant TCP/IP to be removed.	We want a program to automate the process of adding and removing components. Todo this we will maintain a record of installed components and componentdependencies. A component can be installed explicitly in response to a command(unless it is already installed), or implicitly if it is needed for some othercomponent being installed. Likewise, a component, not explicitly installed, canbe explicitly removed in response to a command (if it is not needed to supportother components) or implicitly removed if it is no longer needed to supportanother component. Installing an already implicitly-installed component won'tmake that component become explicity installed.
题目输入：
	The input will contain a sequence of commands (as described below), eachon a separate line containing no more than eighty characters. Item names arecase sensitive, and each is no longer than ten characters. The command names (DEPEND, INSTALL, REMOVE and LIST) always appear inuppercase starting in column one, and item names are separated from the commandname and each other by one or more spaces. All appropriate DEPEND commandswill appear before the occurrence of any INSTALL command thatuses them. There will be no circular dependencies. The end of the input ismarked by a line containing only the word END.	Multimple cases is included.	 	 																					Command Syntax 																								Interpretation/Response 																														DEPEND item1 item2 [item3 ...] 																								item1 depends  on item2 (and item3 ...) 																														INSTALL item1 																								install item1 and those on which it  depends 																														REMOVE item1 																								remove item1, and those on which it  depends, if possible 																														LIST 																								list the names of all currently-installed components 																
题目输出：
	Echo each line of input. Follow each echoed INSTALL or REMOVE line withthe actions taken in response, making certain that the actions are given in theproper order. Also identify exceptional conditions (see Sample Output, below,for examples of all cases). For the LIST command, display the names of thecurrently installed components in the installation order. No output, except theecho, is produced for a DEPEND command or the line containing END. There will be atmost one dependency list per item.	If multiple answers exists, you should output the answer using the orderthe components appears. See the sample for more detailed presentation. 
输入样例：
DEPEND   TELNET TCPIP NETCARD
DEPEND TCPIP NETCARD
DEPEND DNS TCPIP NETCARD
DEPEND  BROWSER   TCPIP  HTML
INSTALL NETCARD
INSTALL TELNET
INSTALL foo
REMOVE NETCARD
INSTALL BROWSER
INSTALL DNS
LIST
REMOVE TELNET
REMOVE NETCARD
REMOVE DNS
REMOVE NETCARD
INSTALL NETCARD
REMOVE TCPIP
REMOVE BROWSER
REMOVE TCPIP
END

输出样例：
DEPEND   TELNET TCPIP NETCARD
DEPEND TCPIP NETCARD
DEPEND DNS TCPIP NETCARD
DEPEND  BROWSER   TCPIP  HTML
INSTALL NETCARD
   Installing NETCARD
INSTALL TELNET
   Installing TCPIP
   Installing TELNET
INSTALL foo
   Installing foo
REMOVE NETCARD
   NETCARD is still needed.
INSTALL BROWSER
   Installing HTML
   Installing BROWSER
INSTALL DNS
   Installing DNS
LIST
   TELNET
   TCPIP
   NETCARD
   DNS
   BROWSER
   HTML
   foo
REMOVE TELNET
   Removing TELNET
REMOVE NETCARD
   NETCARD is still needed.
REMOVE DNS
   Removing DNS
REMOVE NETCARD
   NETCARD is still needed.
INSTALL NETCARD
   NETCARD is already installed.
REMOVE TCPIP
   TCPIP is still needed.
REMOVE BROWSER
   Removing BROWSER
   Removing TCPIP
   Removing HTML
REMOVE TCPIP
   TCPIP is not installed.
END

提示：
None



题目：洗牌游戏(1762)
时间限制：2000MS
空间限制：131072KB
题目描述：
		Lich同学特别喜欢打牌，打牌中难免需要洗牌，洗着洗着，Lich从中悟出了一种新的洗牌方式。简单来说，有2n张不同的牌，放在1~2n个有序的位置上，初始情况下，牌放的序列为：1，2，3...2*n，并且洗牌规则如下：第i张牌会被洗到p(i)张牌上，并且：	p(i) = 2i  			当i<=n	p(i) = 2(i - n) - 1 		当i>n	Lich现在很想知道，当洗牌重新洗回到序列：1，2，3...2*n，对于每一个n，自己需要洗牌的最少次数是多少？		
题目输入：
	对于每组样例，输入一行n，1<= n <= 2^31-1。
题目输出：
	最少洗牌次数
输入样例：
1
输出样例：
2
提示：
None



题目：聪明的鱼儿子(1010)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
鱼头是一个喜欢创造的人，他发明了一种游戏。给出一个m×n的棋盘。他和他的儿子分别有一个棋子随机的放在棋盘上的两个位置，分别为（x1,y1）,(x2,y2).且x1≠x2且y1≠y2.坐标均为整数，且左下角为（0，0）。两个人分别移动自己的棋子(横竖走，步数>=1)，但棋子移动不能经过另外一个人所在的行，或列。最后谁无路可走谁就输。鱼头是一个谦让的父亲，他让儿子选择谁先走。但聪明的鱼儿子百战百胜。鱼头终于忍不住了，要自己决定谁先手，但他实在不知道该如何选择，于是请你来帮忙了，记住，鱼头和他的儿子都很聪明，都能抓住对手的每一个破绽，走出完美的一步。
题目输入：
多组测试数据以文件尾结束。输入的第一行为两个int型的整数m,n;然后是m×n范围内的两个坐标x1,y1,x2,y2。
题目输出：
如果鱼头应该先手，则输出” former”,后手的话输出“hinder”.
输入样例：
6 6
1 1 2 2
输出样例：
hinder
提示：




题目：Distancebringsaboutlove(1215)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
thinking610 is a beautiful boy.He is attractive to boys,especially the old boys.If the distance between thinking610 and a boy is less than or equal to K.The boy would fall in love with thinking610. Mr Yu is a very very … very old boy.One day,He and thinking610 walked in the 3-D cartesian space.Assuming that the two boys continues to walk with constant speed and direction, you need to work out if Mr Yu will fall in love with thinking610 in the future.You will be given the distance K and the positions(x,y,z) and velocities(x1,y1,z1) of the two boys.So after t seconds the boy will reach the point(x+x1*t,y+y1*t,z+z1*t)."t" can be a float number.
题目输入：
The first line of the input contains an integer T (T <= 1000), indicating the number of cases.Each case contains 5 lines:the distance (a integer): Kthinking610's position now (three integers): x y zthinking610's speed (three integers): x1 y1 z1Mr Yu's position now (three integers): x y zMr Yu's speed (three integers): x1 y1 z1
题目输出：
If Mr Yu will fall in love with thinking610,print "So romantic!".Otherwise print "Oh,no!"
输入样例：
1
41
478 724 169 500 334 467
281 145 705 464 962 358

输出样例：
Oh,no!
提示：
None



题目：DesignAGarden(1658)
时间限制：3000ms
空间限制：65535Kb
题目描述：
	One day you realize your dream and become a fabulous designer. An project manager come to find you to do some businesses.Due to your wonderful experiences and designing skills, he decides to make a gigantic investment to design a garden in his business land. Now it is your turn to make that happen. For the sake of his contentment, you must follow all his requirements he mentions:	1. The business land is a convex polygon. The garden is inside the land and is line-parallel to the business land. Outside the garden stands the corridor around. The width of the corridor is D .		2. The area of the garden must be at least S .	3. On the boundary of the business land, the manager wants to place a water spray, which has a R spray range. He announces that in your design you must make sure any place on the boundary where the water spray sets can cover all the garden area to make the garden watered.	4. He will give you the business land point by point in random order, totally N points.	(no three points in one line and these points are all vertexes) He will also show you the base requirement: S,R. And you must give the range of D.	This is a picture to help you to understand the design. If legal D does not exsit, puts single line: no appropriate design	
题目输入：
	An interger N, 3<=N<=10000;	Following N lines: (Xi, Yi)     |Xi|<109 |Yi|<109	Two floating-point numbers :S(S>=0),R(R>=0);
题目输出：
D’srange:Two floating-point numbers, split by blank, accurate to . 2,smaller one comes first.
输入样例：
4
(0,0)
(1,1) 
(1,0)
(0,1)
0.20 1.20

输出样例：
0.15 0.28

提示：
None



题目：DecodetheStrings(1356)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Bruce Force has had an interesting idea how to encode strings. The following is the description of how the encoding is done: 
Let x1,x2,...,xn be the sequence of characters of the string to be encoded. 

Choose an integer m and n pairwise distinct numbers p1,p2,...,pn from the set {1, 2, ..., n} (a permutation of the numbers 1 to n). 
Repeat the following step m times. 
For 1 ≤ i ≤ n set yi to xpi, and then for 1 ≤ i ≤ n replace xi by yi. 
For example, when we want to encode the string "hello", and we choose the value m = 3 and the permutation 2, 3, 1, 5, 4, the data would be encoded in 3 steps: "hello" -> "elhol" -> "lhelo" -> "helol". 
Bruce gives you the encoded strings, and the numbers m and p1, ..., pn used to encode these strings. He claims that because he used huge numbers m for encoding, you will need a lot of time to decode the strings. Can you disprove this claim by quickly decoding the strings? 
题目输入：
The input contains several test cases. Each test case starts with a line containing two numbers n and m (1 ≤ n ≤ 80, 1 ≤ m ≤ 109). The following line consists of n pairwise different numbers p1,...,pn (1 ≤ pi ≤ n). The third line of each test case consists of exactly n characters, and represent the encoded string. The last test case is followed by a line containing two zeros.
题目输出：
For each test case, print one line with the decoded string.
输入样例：
5 3
2 3 1 5 4
helol
16 804289384
13 10 2 7 8 1 16 12 15 6 5 14 3 4 11 9
scssoet tcaede n
8 12
5 3 4 2 1 8 6 7
encoded?
0 0

输出样例：
hello
second test case
encoded?
提示：




题目：TheCastle(1458)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
In a stroke of luck almost beyond imagination, Farmer John was sent a ticket to the Irish Sweepstakes (really a lottery) for his birthday. This ticket turned out to have only the winning number for the lottery! Farmer John won a fabulous castle in the Irish countryside. Bragging rights being what they are in Wisconsin, Farmer John wished to tell his cows all about the castle. He wanted to know how many rooms it has and how big the largest room was. In fact, he wants to take out a single wall to make an even bigger room. Your task is to help Farmer John know the exact room count and sizes. The castle floorplan is divided into M (wide) by N (1 <=M,N<=50) square modules. Each such module can have between zero and four walls. Castles always have walls on their "outer edges" to keep out the wind and rain. Consider this annotated floorplan of a castle:      1   2   3   4   5   6   7   ############################# 1 #   |   #   |   #   |   |   #   #####---#####---#---#####---#    2 #   #   |   #   #   #   #   #   #---#####---#####---#####---# 3 #   |   |   #   #   #   #   #      #---#########---#####---#---# 4 # ->#   |   |   |   |   #   #      ############################# #  = Wall     -,|  = No wall-> = Points to the wall to remove to     make the largest possible new roomBy way of example, this castle sits on a 7 x 4 base. A "room" includes any set of connected "squares" in the floor plan. This floorplan contains five rooms (whose sizes are 9, 7, 3, 1, and 8 in no particular order). Removing the wall marked by the arrow merges a pair of rooms to make the largest possible room that can be made by removing a single wall. The castle always has at least two rooms and always has a wall that can be removed.
题目输入：
There are several test cases, end by EOF, for each test case:The map is stored in the form of numbers, one number for each module, M numbers on each of N lines to describe the floorplan. The input order corresponds to the numbering in the example diagram above. Each module number tells how many of the four walls exist and is the sum of up to four integers: 1: wall to the west 2: wall to the north 4: wall to the east 8: wall to the south Inner walls are defined twice; a wall to the south in module 1,1 is also indicated as a wall to the north in module 2,1. Line 1:  Two space-separated integers: M and N Line 2..:  M x N integers, several per line.
题目输出：
The output contains several lines: Line 1:  The number of rooms the castle has.  Line 2:  The size of the largest room Line 3:  The size of the largest room creatable by removing one wall  Line 4:  The single wall to remove to make the largest room possible Choose the optimal wall to remove from the set of optimal walls by choosing the module farthest to the west (and then, if still tied, farthest to the south). If still tied, choose 'N' before 'E'. Name that wall by naming the module that borders it on either the west or south, along with a direction of N or E giving the location of the wall with respect to the module.
输入样例：
7 4
11 6 11 6 3 10 6
7 9 6 13 5 15 5
1 10 12 7 13 7 5
13 11 10 8 10 12 13
输出样例：
5
9
16
4 1 E
提示：




题目：JillRidesAgain(1558)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	Jill likes to rideher bicycle, but since the pretty city of Greenhills where she lives has grown,Jill often uses the excellent public bus system for part of her journey. Shehas a folding bicycle which she carries with her when she uses the bus for thefirst part of her trip. When the bus reaches some pleasant part of the city,Jill gets off and rides her bicycle. She follows the bus route until shereaches her destination or she comes to a part of the city she does not like.In the latter event she will board the bus to finish her trip.	Through years of experience, Jill has rated each road on an integer scale of``niceness.'' Positive niceness values indicate roads Jill likes; negativevalues are used for roads she does not like. There are not zero values. Jillplans where to leave the bus and start bicycling, as well as where to stopbicycling and re-join the bus, so that the sum of niceness values of the roadsshe bicycles on is maximized. This means that she will sometimes cycle along aroad she does not like, provided that it joins up two other parts of herjourney involving roads she likes enough to compensate. It may be that no partof the route is suitable for cycling so that Jill takes the bus for its entireroute. Conversely, it may be that the whole route is so nice Jill will not usethe bus at all.	Since there are many different bus routes, each with several stops at whichJill could leave or enter the bus, she feels that a computer program could helpher identify the best part to cycle for each bus route.
题目输入：
	The input file contains information on several bus routes. The first lineof the file is a single integer b representing the number ofroute descriptions in the file. The identifier for each route (r) is thesequence number within the data file, 1<=r<=b.Each route description begins with the number of stopson the route: an integer s, 2<=s<=20,000 on a line by itself. The number of stops isfollowed by s - 1 lines, each line i (1<=i<=s) is an integer ni representing Jill'sassessment of the niceness of the road between the two stops i and i+1.		
题目输出：
	For each route r in the input file, your program shouldidentify the beginning bus stop i and the ending busstop j that identify the segment of the route which yields themaximal sum of niceness, m= ni+ni+1+...+nj-1.If more than one segment is maximally nice, choose the one with the longestcycle ride (largest j-i). To break ties in longest maximalsegments, choose the segment that begins with the earliest stop (lowest i).For each route r in the input file, print a line in the form:	The nicest part ofroute r is between stops i and j	However, if the maximal sum is not positive, your program should print:	Route r has no niceparts
输入样例：
3
3
  -1
   6
10
   4
  -5
   4
  -3
   4
   4
  -4
   4
  -5
4
  -2
  -3
  -4

输出样例：
The nicest part of route 1 is between stops 2 and 3
The nicest part of route 2 is between stops 3 and 9
Route 3 has no nice parts

提示：
None



题目：页面置换(1112)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	在19世纪60年代和70年代，页面置换算法是一个热门话题。大多以LRU的近似算法和working set算法结束。从那以后，一些传统页面置换算法作出的基础的假设失效了。结果造成了研究的复兴。特别是，下列趋势中，基础硬件和用户级软件，已经影响到页面置换算法的性能	主存的容量增加了多个数量级。在几个GB的主存中，需要定期检查每一个帧的算法越来越不实际。存储器层级增加。缓存未命中的开销变得越来越大，这加剧了先前的问题。	用户及软件内存引用的区域性减弱。这主要是归因于面向对象编程技术的传播，偏向于大量小型模块，使用先进的数据结构如树和散列表，往往会导致内存引用模式的混乱，还有垃圾收集机制的出现，大大改变了应用程序的存储器访问行为。	由于不同的操作系统内核架构，页面置换算法的需求已经改变。尤其是最现代的操作系统内核有统一的虚拟内存和文件系统缓存，要求页面置换算法从用户程序虚拟地址和缓冲文件中选择一个页面，后者的页面有具体的属性。举例来说，它们可以被锁定，或可以有日志指定的写入顺序的要求。此外，页面置换算法的目的是尽量减少等待存储器的总时间，它必须考虑到其他分配内存的子系统设定的帐户内存需求。因此，页面置换在现代内核（ Linux，FreeBSD和Solaris ），往往工作在一个一般用途内核内存分配器的水平，而不是在更高层次的虚拟存储器子系统。	 	页面置换算法有很多种，其中一种是LRU：	最近最少使用（LRU)页面置换算法算法，虽然与NRU（最近未使用）的名字近似，不同的是，LRU跟踪页面在一段时间内的使用，而NRU只是着眼最后一个时钟周期内的使用。LRU的思想是在过去少量指令中引用量大的页面最有可能在未来指令中被引用。LRU可以在理论上提供近似最优性能（几乎和自适应置换高速缓存一样优秀），但是在实现上的开销相当大。这个方法有一些实现试图减少开销同时尽可能地保留性能。              LRU算法的一个重要优点是它已被全面的统计分析验证过。例如，LRU永远不能导致比最优算法多于N次的页面错误，其中N与缓存中页面数量成正比。	最费时的实现方法是链表方法，它使用一个链表保存缓存中的所有页面，在链表的尾部是最近最少使用的页面，在首部是最近最常使用的页面。这种实现的消耗在于链表中的项在每次内存引用中都需要移动，这是一个相当耗时的过程。	另一种需要硬件支持的实现方法如下：假设硬件有一个64位的计数器并且在每条指令执行的时候都递增。当一个页面被访问的时候，它得到一个等同于计数器当时的数值的值。当一个页面需要被换出时，操作系统选择计数器值最小的页面并换出。对于现有的硬件来说，这种方法并不可行，因为这样的硬件不存在。	缓存容量为3的LRU算法运行如下：	 	7  0  1  2  0  3  0  4  2  3  0  3  2  1  2  0  1  7  0  1  引用序列	----------------------------------------------------------------------------------------	7  7  7  2      2     4  4  4  0           1          1  1         	    0  0  0      0     0  0  3  3           3          0  0       缓存中的页面	        1  1      3     3  2  2  2           2          2  7       	 	一共发生了12次缺页错误。对于一个给定的引用序列，你需要计算出缺页错误发生的次数。
题目输入：
第一行包含一个整数，表示测试数据的组数。每一组测试数据包括两行，第一行是缓存区的容量m(0 < m ≤ 10000)和引用序列的长度(0 < n ≤ 100000)。第二行包含n个整数，表示整个引用序列(页面号码范围为0到n)。
题目输出：
对于每一组测试数据，输出应该包含缺页错误发生的次数。
输入样例：
3
3 5
1 2 3 4 5
3 5
1 2 1 2 3
3 20
7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1

输出样例：
5
3
12

提示：
None



题目：神灵武士求你A(1763)
时间限制：1000MS
空间限制：131072KB
题目描述：
	dota里面的神灵武士在新版本里面改版了，现在的神灵武士太虎了。当你攻击神灵武士掉血的时候，神灵武士的自身的攻击速度会提升，而且魔抗	也会提升，所以，当神灵武士的血越少，他的攻击速度就越高，魔抗也越高。	在游戏中，一个英雄有这些参数的：	1.血量。一个英雄的血量只要不为0，就可以继续和你对A,哪怕只有一点血。当然了，如果血量为0，则英雄就死掉回泉水去了。	2.魔抗。这绝对是神灵的一大优势了。当对面对你释放魔法技能造成伤害的时候，你的魔抗会为你抵消掉一定的伤害。魔抗最多只能达到100%，也就是为你抵消掉100%的魔法伤害，当然，有一类魔法伤害是抵消不掉的，也就是神圣伤害。	3.攻击力。攻击力就是英雄普通攻击造成的伤害，攻击力造成的伤害是要计算护甲的。	4.护甲。为你抵消一部分的物理攻击，也就是普通攻击造成的伤害。护甲最多100，即抵消100%的物理伤害。	5.攻击速度。用攻击间隔表示，即攻击一次的时间。攻击速度最多提升到400%，也就是原先的攻击时间的1/4。	有些英雄是有技能伤害了，当然了，神灵武士就不需要了，因为神灵武士的物理攻击太高了。当是，你要和神灵对A要赢是在是太难了，所以，你除了和神灵武士对A之外，还要依靠技能的释放来造成伤害。	而技能分为了主动技能和被动技能这两种。每个主动技能在对抗中只能够释放一次(神灵武士不会给你等到第二个技能的CD的)，也就是在你攻击时放技能,当到你攻击时你释放技能时，你就不会去攻击（就当是施法动作。。。）	主动技能有以下几种：	1.神圣伤害，这种魔法攻击的伤害将无视魔法抗性	2.普通的魔法伤害，造成一定的伤害，这种伤害会计算魔法抗性	3.降低攻击，减少对方英雄的攻击，持续几次攻击	被动技能，被动技能相当于光环作用，在整个对抗过程中都是存在的。被动技能有以下几种	1.提升自己的攻击力	2.提升自己的攻击速度	3.提升自己的护甲	现在已知神灵当血量每降低10%的血量，魔抗就会提升10%，攻击速度也会提升20%。除此之外，神灵武士还有一个攻击特效，就是神灵武士每次攻击会失去8点血，而这次攻击会对对方造成16点的伤害，同时这次伤害会持续4个回合，并且这个伤害是叠加，当然了，当神灵的血量低于8点时，神灵的攻击里面就没有这个攻击特效了，也就是只能够普通攻击了。（假设神灵的每一次攻击的时间都是由前一攻击之后确定的）。	现在给你一个英雄的参数，并且给出这个英雄的三个技能（可以在与神灵武士的对A中使用，当然，你不能挂啊），请问你能否获胜？
题目输入：
	先输入一个整数，表示样例的个数。接下来，对于每个样例，先输入神灵武士的五个参数，参数分别有"血量","魔抗","攻击力","护甲","攻击速度"。血量，攻击力和护甲都是整数，魔抗是一个小于1的小数，攻击速度则是一个小数用来表示攻击间隔。接下，再输入你的四个参数，你的参数有"血量","攻击力","护甲","攻击速度"。其中，"血量","攻击力","护甲"是整数，"攻击速度"是一个用小数表示的攻击间隔。接下来三行，输入你的所拥有的三个技能。每个技能先输入一个整数，1表示主动技能，接下来输入一个整数，表示技能的类型：1表示神圣伤害，再输入一个整数，表示其造成伤害的值；2表示普通魔法伤害，在输入一个整数，表示其造成的值；3表示降低攻击，接下来输入两个整数，表示其持续的攻击次数和降低的攻击力。2表示被动技能，接下来再输入一个整数表示被动技能的类型，1表示提升攻击力，在输入一个整数表示攻击力，2表示提升攻击速度，输入一个整数a，表示提升a%，3表示提升护甲，再输入一个整数，表示提升护甲值。血量，攻击力都是小于5000的数。
题目输出：
		对于每个样例，如果你赢了，就输出"YES"，否则，就输出"NO"。	
输入样例：
1
50 0.00 0 0 2.00
100 50 50 50
1 1 50
1 1 50
1 1 50 
输出样例：
Yes
提示：
None



题目：鱼儿子的反击(1011)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
鱼头终于在你的帮助下，在下棋上战胜了自己的儿子，大呼得意。于是，鱼儿子决定要挫挫爸爸的锐气，给爸爸出了道难题。
连续的整数如图排列，这些数字一定在int范围内。给出其中的N个点的数字（N<=100）,鱼头需要在这N个点中建立路径，使任意一个点可以直接或间接的与另外N-1个点连通，路径为每跨越一条边算长度1，只能从从边走，不能从点走。求建立这些连接所需要的最短路径总长度。鱼头又囧了，只能偷偷的打电话让你给出他答案，电话费很贵的，赶紧搞定告诉可怜的鱼头吧。
输入：多组测试数据以文件尾结束。第一行为一个整数N。下面的N行分别只有一个数，代表上面三角形的一个数字，来表示位置。
输出：建立这些点之间连接的最短路径总长度。
题目输入：
多组测试数据以文件尾结束。第一行为一个整数N。下面的N行分别只有一个数，代表上面三角形的一个数字，来表示位置。
题目输出：
建立这些点之间连接的最短路径总长度。
输入样例：
2
6
12
输出样例：
3
提示：




题目：Easy(1216)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
As you know,messIDou is not good at math problems.So this problem is easy.Isn't it? Let's consider an infinite sequence A defined as follows:Ai = 1 for all i <= 0;Ai = A [ [i/p]-x ]+ A [ [i/q]-y ] for all i >= 1, where [x] denotes the floor function of x. You will be given n, p, q, x and y. Please tell me A[n] (index is 0-based).
题目输入：
There are multiple test cases in the input file. Each test case contains five integers n,p,q,x,y.( 0 <=n <= 10^12 , 2 <=p,q <= 10^9 , 0 <=x,y <= 10^9)End with EOF.
题目输出：
For each test case,output A[n] in a single line.
输入样例：
10000000 2 3 10000000 10000000
12 2 3 1 0

输出样例：
2
8

提示：
None



题目：ElDorado(1357)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Bruce Force has gone to Las Vegas, the El Dorado for gamblers. He is interested especially in one betting game, where a machine forms a sequence of n numbers by drawing random numbers. Each player should estimate beforehand, how many increasing subsequences of length k will exist in the sequence of numbers. 
A subsequence of a sequence a1, ..., an is defined as ai1, ..., ail, where 1 ≤ i1 < i2 < ... < il ≤ n. The subsequence is increasing, if aij-1 < aij for all 1 < j ≤ l. 
Bruce doesn't trust the Casino to count the number of increasing subsequences of length k correctly. He has asked you if you can solve this problem for him.
题目输入：
The input contains several test cases. The first line of each test case contains two numbers n and k (1 ≤ k ≤ n ≤ 100), where n is the length of the sequence drawn by the machine, and k is the desired length of the increasing subsequences. The following line contains n pairwise distinct integers ai (-10000 ≤ ai ≤ 10000 ), where ai is the ith number in the sequence drawn by the machine. 

The last test case is followed by a line containing two zeros.

题目输出：
For each test case, print one line with the number of increasing subsequences of length k that the input sequence contains. You may assume that the inputs are chosen in such a way that this number fits into a 64 bit signed integer (in C/C++, you may use the data type "long long", in Java the data type "long").
输入样例：
10 5
1 2 3 4 5 6 7 8 9 10
3 2
3 2 1
0 0

输出样例：
252
0

提示：




题目：ContinuousLongestIncreaseSubsequence(1659)
时间限制：1000ms
空间限制：65535Kb
题目描述：
		Given n integer ,Only two kinds of operations ：	（1）U A B：change the A-th integer to B	（2）Q A B: Output the length of the longest continuous increasing subsequence in the interval [A, B]	
题目输入：
	The first line of a integer T, show that the number of case	The first line of each case are two integers n, m (0<n,m<=100000)	The next line has n Numbers （0<=value<=100000）.	Then following m lines ,each line next shows one operation:	U A B（0<=A<n,0=<B<=100000）	or	Q A B（0<=A<=B<n）.
题目输出：
	For every Q operation, to print the answer. 
输入样例：
1
10 10
7 7 3 3 5 9 9 8 1 8 
Q 6 6
U 3 4
Q 0 1
Q 0 5
Q 4 7
Q 3 5
Q 0 2
Q 4 6
U 6 10
Q 0 9

输出样例：
1
1
4
2
3
1
2
5

提示：

	由于我的英语水平比较菜，所以我简单的翻译一下


	U A B：change the A-th integer to B 将第A个整数改为整数B（不是第B个整数）




题目：OrderedFractions(1459)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Consider the set of all reduced fractions between 0 and 1 inclusive with denominators less than or equal to N. Here is the set when N = 5: 0/1 1/5 1/4 1/3 2/5 1/2 3/5 2/3 3/4 4/5 1/1Write a program that, given an integer N between 1 and 160 inclusive, prints the fractions in order of increasing magnitude.
题目输入：
There are several test cases, end by EOF, for each test case:One line with a single integer N.
题目输出：
One fraction per line, sorted in order of magnitude.
输入样例：
5
输出样例：
0/1
1/5
1/4
1/3
2/5
1/2
3/5
2/3
3/4
4/5
1/1
提示：




题目：MorseMismatches(1559)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	Samuel F. B. Morseis best known for the coding scheme that carries his name. Morse code is stillused in international radio communication. The coding of text using Morse codeis straightforward. Each character (case is insignificant) is translated to apredefined sequence of dits and dahs (theelements of Morse code). Dits are represented as periods (``.'') and dahs arerepresented as hyphens or minus signs (``-''). Each element is transmitted bysending a signal for some period of time. A dit is rather short, and a dah is,in perfectly formed code, three times as long as a dit. A short silent spaceappears between elements, with a longer space between characters. A stilllonger space separates words. This dependence on the spacing and timing ofelements means that Morse code operators sometimes do not send perfect code.This results in difficulties for the receiving operator, but frequently themessage can be decoded depending on context.	In this problem we consider reception of words in Morse code without spacingbetween letters. Without the spacing, it is possible for multiple words to becoded the same. For example, if the message ``dit dit dit'' were received, itcould be interpreted as ``EEE'', ``EI'', ``IE'' or ``S'' based on the codingscheme shown in the sample input. To decide between these multipleinterpretations, we assume a particular context by expecting each received wordto appear in a dictionary.	For this problem your program will read a table giving the encoding of lettersand digits into Morse code, a list of expected words (context), and asequence of words encoded in Morse code (morse). These morse words maybe flawed. For each morse word, your program is to determinethe matching word from context, if any. If multiple wordsfrom context match morse, or if no word matchesperfectly, your program will display the best matching word and a mismatchindicator.	If a single word from context matches morse perfectly,it will be displayed on a single line, by itself. If multiple context wordsexist for a given morse, the first matching word will be displayedfollowed by an exclamation point (``!'').	We assume only a simple case of errors in transmission in which elements may beeither truncated from the end of a morse word or added to theend of a morse word. When no perfect matches for morse arefound, display the word from context that matches the longestprefix of morse, or has the fewest extra elements beyond those inmorse.If multiple words in context match using these rules, any ofthese matches may be displayed. Words that do not match perfectly are displayedwith a question mark (``?'') suffixed.	The input data will only contain cases that fall within the preceding rules.
题目输入：
	The Morse code table will appear first and consists of lines eachcontaining an uppercase letter or a digit C, zero or more blanks, and asequence of no more than six periods and hyphens giving the Morse code for C.Blanks may precede or follow the items on the line. A line containing a singleasterisk (``*''), possibly preceded or followed by blanks, terminates the Morsecode table. You may assume that there will be Morse code given for everycharacter that appears in the context section.	The context section appears next, with one word per line,possibly preceded and followed by blanks. Each word in context willcontain no more than ten characters. No characters other than upper case lettersand digits will appear. Thered will be at most 100 context words.A line containing only a single asterisk (``*''), possibly preceded or followedby blanks, terminates the context section.	The remainder of the input contains morse words separated by blanks orend-of-line characters. A line containing only a single asterisk (``*''),possibly preceded or followed by blanks, terminates the input. No morse wordwill have more than eighty (80) elements.
题目输出：
	For each input morse word, display the appropriatematching word from context followed by an exclamation mark(``!'') or question mark (``?'') if appropriate. Each word is to appear on aseparate line starting in column one.
输入样例：
A       .-
B       -...
C       -.-.
D       -..
E       .
F       ..-.
G       --.
H       ....
I       ..
J       .---
K       -.-
L       .-..
M       --
N       -.
O       ---
P       .--.
Q       --.-
R       .-.
S       ...
T       -
U       ..-
V       ...-
W       .--
X       -..-
Y       -.--
Z       --..
0       ------
1       .-----
2       ..---
3       ...--
4       ....-
5       .....
6       -....
7       --...
8       ---..
9       ----.
*
AN
EARTHQUAKE
EAT
GOD
HATH
IM
READY
TO
WHAT
WROTH
*
.--.....--   .....--....
--.----..   .--.-.----..
.--.....--   .--.
..-.-.-....--.-..-.--.-.
..--   .-...--..-.--
----        ..--
*
输出样例：
WHAT
HATH
GOD
WROTH?
WHAT
AN
EARTHQUAKE
EAT!
READY
TO
EAT!

提示：
None



题目：RSA签名(1113)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	在密码学中，RSA是一种公钥加密算法。它也是第一个同样适合于签名的算法，是密码学的重大进步之一。RSA在电子商务协议中广泛运用，如果使用了有效的长密钥和最新的实现，它被认为是安全的。	RSA设计到一个公钥和一个私钥。公钥可以公布给所有人，用于加密。由公钥加密的信息只能由私钥解密. RSA的密钥由以下方法生成：	 	1. 选择两个不同的大随机素数p和q。	2. 计算 n = p * q。	3. 计算欧拉函数: φ(n) = (p-1) * (q-1)。	4. 选择一个整数e 满足 1 < e < φ(n), 而且e和φ(n) 互素。	5. 计算满足d * e 恒等于1 mod (φ(n)) 的d。	 	公钥包括模数n，和公共 (或加密) 指数 e。	私钥包括模数n，和私有 (或解密) 指数d，必须保密。	 	加密信息：	Alice把她的公钥(n,e)传输给Bob同时保证私钥保密。如果Bob想发送消息M给Alice。他首先将M转换为一个小于n的数字m。然后计算密文c：	    c = me mod n	使用平方求幂的方法可以很快计算出来。然后Bob将c传输给Alice。	 	解密信息：	Alice能够从c中恢复m，使用她的私钥的指数d：	    m = cd mod n	给定一个m她能够恢复出原始的M。	 	假设Alice使用Bob的公钥发送给他加密信息。在消息中，她可以声称自己是Alice 但是Bob无法验证消息是否真的是Alice发送的，因为所有人都可以使用Bob的公钥发送给他加密后的信息。所以，为了验证信息的来源，RSA同样可以用于给消息签名。              假设Alice希望向Bob发送信息。她可以使用她的私钥。她先计算消息的散列值m， 计算指数d模n (就像解密一样)，然后在消息中附加上这个签名。当Bob收到一个签名了的消息，他使用同样的散列算法和Alice的公钥来计算指数e模n (就像加密一样)，然后比较结果和消息的真实散列值。如果匹配，那么他就会得知这个消息的作者持有Alice的私钥，而且这个消息没有被篡改。现在你得到了Alice的公钥，你想要伪装成Alice给Bob发信息，如果她的密钥很弱，那么你将怎样伪造Alice的签名呢？
题目输入：
第一行包括一个整数T，表示测试数据的组数。每一组测试数据包括三个正整数n, e, m  (0 < m < n, 0 < e < n, 0 < n < 2的60次方).
题目输出：
对于每一组测试数据，在单独的一行中输出消息m的RSA签名。
输入样例：
1
55 7 15

输出样例：
20
提示：
None



题目：棋盘游戏(1764)
时间限制：1000MS
空间限制：131072KB
题目描述：
		有一个在棋盘上玩的游戏，游戏规则如下： 	 	 	两个玩家，A和B，轮流地放小木棍在两个节点相连的线上（一共只有16个节点），A为先手。一个木棍占据连线后，之后就不可以有木棍在放在该连线上。 	当一个玩家在放了这个木棍之后，此时恰好组成了一个正边形（只是最小的），那么该玩家将得到一分。当所有的树枝都填满了，游戏就结束了。拥有最高分的人获胜。 	在此题中，会先给你一些放木棍的步数，也是两个人轮流开始。在当前的局面里，你需要判断哪个人会赢，假设每个人都会都是选择自己方最优的方案。 	
题目输入：
	先输入一个整数T，表示样例数	对于每一组样例，先输入一个整数n，接下有n行（12<= n <= 24），每行两个数字，分别表示边的两个节点，表示的每个选手轮流的操作。	
题目输出：
	对于每组样例，输出当前是第几个样例，并且如果是A赢，就输出’A’，否则，输出’B’。
输入样例：
1
12
1 2
3 4
5 6
7 8
9 10
11 12
13 14
15 16
2 6
3 7
10 14
11 15 

输出样例：
Case 1: B
提示：
None



题目：神勇的小田(1012)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
小田本来是南京理工大学ACM集训队的队员，但由于武功高强，身体条件出色，被特种部队挖走，去执行一项不可能完成的任务……
小田潜入敌人的巢穴去夺回原本属于中华人民共和国的三鹿奶粉配方，任务眼看就要成功了，出口就在前面，可是狡猾的敌人把铁质的地面通上了高压电，幸好小田身手敏捷，他立刻跳到了一个很高的木箱子上。由于小田多年从事ACM活动，脑子十分好用。看到周围有许多木箱子，把箱子踢到就可以踩在箱子上走。他心中一算就知道自己能出去了。 
我们现在可以这样描述这个问题。小田所在的屋子的地面可以看成由n*n的格子组成，地板上要么有箱子（深色），要么没箱子，箱子高用数字表示。E表示出口。小田现在就在某一个箱子上。小田现在可以做两件事：
1、如果小田所处的箱子旁边还有箱子，他可以从一个箱子移动到另一个箱子上，移动花费1步，不考虑箱子的高度。如图a所示：
2、小田可以用大力精钢腿踢到所站的箱子，条件是倒的方向上没有箱子没有墙，箱子就会向前覆盖等于箱子高的地面，小田顺势用林波微步移动到倒了的箱子上，共花费1步，如图b，c，d所示。倒了的箱子不能再立起来，也不能再向其他方向踢了。在倒的箱子上可以移动，也可以从倒的箱子上调到相邻的其他箱子。每走一格算一步。
作为晚辈的你一定钦佩小田的功夫了。我们虽然不可能有小田的武功，但头脑并不比小田差，假如当时你是小田，你能找到最短的出去的路吗？
题目输入：
有多组输入输出
每组中 第一行输入三个数 n，i， j，n表示房间的是由n*n的地板组成。i， j表示小田的位置是第i行第j列。
然后输入n*n的矩阵，其中.表示地面数字表示有箱子及高度。E表示出口。
输入 0 0 0表示输入结束。
题目输出：
每组输出各占一行，表示逃出房间的最少步数。
输入样例：
5 5 3
.2..E
...2.
4....
....4
..2..
0 0 0
输出样例：
18
提示：




题目：Fishhead'sproblemforpost90s(1217)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
thinking610 is proud because of born after 1990.He loves the number "90".When fishhead asked him to give a problem,he came up soon.There is a string containing only decimal digit characters. The length of the string is between 1 and 1000. Using characters of the string, you have to construct the maximum number which divides by 90 without remainder. Each character of the string may not be used more than once.
题目输入：
The first line of the input contains an integer T (T <= 1000), indicating the number of cases. Each case begins with a line containing a single line representing the source string.
题目输出：
For each test case, print a line containing the decimal representation of the maximum number (leading zeroes should be omitted). If no number can be constructed, please output “impossible” instead.
输入样例：
3
0099
2
00

输出样例：
9900
impossible
0

提示：
None



题目：SortingaThree-ValuedSequence(1460)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Sorting is one of the most frequently performed computational tasks. Consider the special sorting problem in which the records to be sorted have at most three different key values. This happens for instance when we sort medalists of a competition according to medal value, that is, gold medalists come first, followed by silver, and bronze medalists come last. In this task the possible key values are the integers 1, 2 and 3. The required sorting order is non-decreasing. However, sorting has to be accomplished by a sequence of exchange operations. An exchange operation, defined by two position numbers p and q, exchanges the elements in positions p and q. You are given a sequence of key values. Write a program that computes the minimal number of exchange operations that are necessary to make the sequence sorted.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  N (1 <= N <= 1000), the number of records to be sorted Lines 2-N+1:  A single integer from the set {1, 2, 3}
题目输出：
A single line containing the number of exchanges required
输入样例：
9
2
2
1
3
3
3
2
3
1
输出样例：
4
提示：




题目：Forest(1358)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Bruce Force is standing in the forest. He wonders what is the tree trunk the farthest away which is not blocked from his view by other tree trunks. 
Bruce has made a map of the trees in the forest. The map shows his current position as the origin of a cartesian coordinate system. Tree i is shown on the map as a circle with the center (xi, yi) and radius ri. You may assume that a tree trunk is visible if and only if there exists a line segment on the map from the origin (0,0) to a point on the border of the circle representing the tree trunk, where the line segment does not intersect or touch another circle.
题目输入：
The input contains several test cases. The first line of each test case contains one number n (1 ≤ n ≤ 1000), where n specifies how many trees are on the map. The following n lines contain 3 integers xi, yi, ri each, (-10000 ≤ xi, yi ≤ 10000 , 1 ≤ ri ≤ 1000 ) where (xi, yi) is the center of the circle representing tree trunk i, and ri is the radius of the circle. You may assume that no two circles in the input intersect, i.e., for any two circles, the distance between their centers is more than the sum of their radii. Moreover, you may assume that no circle contains the origin. 

The last test case is followed by a line containing one zero.

题目输出：
For each test case, print one line with the maximum euclidean distance from the origin to a visible tree. The distance to a tree should be measured using the point of the tree closest to the origin, no matter if this point is in fact visible or not. 

Round the answer to 3 digits after the decimal point.

输入样例：
3
10 10 11
1 1 1
-20 -10 20
5
1 2 2
-2 1 1
2 -1 1
-1 -2 2
10000 -10000 1000
0

输出样例：
3.142
1.236

提示：
In the second test case, the first four trees block the view of all trees farther away than these four trees.



题目：Thenearestpairsontree(1660)
时间限制：1000ms
空间限制：65535Kb
题目描述：
Give a tree with n vertices,each edge has a length. Define cost(u,v)=The min edge in the path which from node u to node v .Give two integer k、h，for every pair (u,v) of verticesis called valid if cost (u,v) ∈ [k,h]. Write a program that will count how many pairs which are valid for a given tree. 
题目输入：
The input contains several test cases. The first line of each test case contains two integers n, q. (n<=10000,q<= 10000) The following n-1 lines each contains three integers u,v,l, which means there is an edge between node u and v of length l. Then following q lines each contains two integer k,h(h>=k>=0). End of by EOF. 
题目输出：
For each query output the answer on a singleline.
输入样例：
5 6
1 2 3
1 3 1
1 4 2
3 5 1
0 4
0 0
1 1
2 2
3 3
4 4

输出样例：
10
0
7
2
1
0

提示：
None



题目：RAID!(1560)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	RAID (RedundantArray of Inexpensive Disks) is a technique which uses multiple disks to storedata. By storing the data on more than one disk, RAID is more fault tolerantthan storing data on a single disk. If there is a problem with one of thedisks, the system can still recover the original data provided that theremaining disks do not have corresponding problems.	One approach to RAID breaks data into blocks and stores these blocks on all butone of the disks. The remaining disk is used to store the parity informationfor the data blocks. This scheme uses vertical parity in whichbits in a given position in data blocks are exclusive ORed to form thecorresponding parity bit. The parity block moves between the disks, starting atthe first disk, and moving to the next one in order. For instance, if therewere five disks and 28 data blocks were stored on them, they would be arrangedas follows:																						Disk 1 																								Disk 2 																								Disk 3 																								Disk 4 																								Disk 5 																														Parity for 1-4 																								Data block 1 																								Data block 2 																								Data block 3 																								Data block 4 																														Data block 5 																								Parity for 5-8 																								Data block 6 																								Data block 7 																								Data block 8 																														Data block 9 																								Data block 10 																								Parity for 9-12 																								Data block 11 																								Data block 12 																														Data block 13 																								Data block 14 																								Data block 15 																								Parity for 13-16 																								Data block 16 																														Data block 17 																								Data block 18 																								Data block 19 																								Data block 20 																								Parity for 17-20 																														Parity for 21-24 																								Data block 21 																								Data block 22 																								Data block 23 																								Data block 24 																														Data block 25 																								Parity for 25-28 																								Data block 26 																								Data block 27 																								Data block 28 																With this arrangement of disks, a block size of two bits and even parity, thehexadecimal sample data 6C7A79EDFC (01101100 01111010 01111001 1110110111111100 in binary) would be stored as:																						Disk 1 																								Disk 2 																								Disk 3 																								Disk 4 																								Disk 5 																														00 																								01 																								10 																								11 																								00 																														01 																								10 																								11 																								10 																								10 																														01 																								11 																								01 																								10 																								01 																														11 																								10 																								11 																								11 																								01 																														11 																								11 																								11 																								00 																								11 																If a block becomes unavailable, its information can still be retrieved usingthe information on the other disks. For example, if the first bit of the firstblock of disk 3 becomes unavailable, it can be reconstructed using thecorresponding parity and data bits from the other four disks. We know that oursample system uses even parity:				So the missing bitmust be 1.	An arrangement of disks is invalid if a parity error is detected, or if anydata block cannot be reconstructed because two or more disks are unavailablefor that block.	Write a program to report errors and recover information from RAID disks.
题目输入：
	The input consists of several disk sets.	Each disk set has 3 parts. The first part of the disk set contains threeintegers on one line: the first integer d, 2<=d<=6,is the number of disks, the second integer s,1<=s<=64,is the size of each block in bits, and the thirdinteger b, , is the total number of data and parity blocks oneach disk. The second part of the disk set is a single letter on a line, either``E'' signifying even parity or ``O'' signifying odd parity. The third part of thedisk set containsd lines, one for each disk, each holding s×b charactersrepresenting the bits on the disk, with the most significant bits first. Eachbit will be specified as ``0'' or ``1'' if it holds valid data, or ``x'' if that bit is unavailable. The end ofinput will be a disk set with d = 0. There will be no otherdata for this set which should not be processed.		
题目输出：
	For each disk set in the input, display the number of the set and whetherthe set is valid or invalid. If the set is valid, display the recovered databits in hexadecimal. If necessary, add extra ``0'' bits at the end of therecovered data so the number of bits is always a multiple of 4. All outputshall be appropriately labeled.
输入样例：
5 2 5
E
0001011111
0110111011
1011011111
1110101100
0010010111
3 2 5
E
0001111111
0111111011
xx11011111
3 5 1
O
11111
11xxx
x1111
0

输出样例：
Disk set 1 is valid, contents are: 6C7A79EDFC
Disk set 2 is invalid.
Disk set 3 is valid, contents are: FFC

提示：
None



题目：数字猜想(1114)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	数字猜想是一个电脑游戏。首先，电脑会选择四个不重复的数字，你要根据电脑的提示尽快地猜出这个数字。电脑给的提示形式是“#A#B”，其中“#”是0~4的数字。其中“#A”表示猜中了数字.和位置的数目，“#B”表示猜中数字的数目。比如，电脑选择的是1234，你猜的是6139，电脑给的提示是“1A2B”，因为数字“3”既猜中了数字，也猜对了位置，而数字“1”只猜中了数字，所以电脑给的提示就是“1A2B”。	现在，你仔细记录了你每次猜的数字和电脑的提示，你感觉应该可以猜对结果了。是的，生活中充满了智慧，不是吗？
题目输入：
有多个测试序列。每个测试序列的第一行是一个单独的正整数N，表示猜想的次数，接下来的N行是N次猜想的记录，形式为：#### #A#B前面四个数字是猜想的数字，后面是电脑对猜想的提示。输入N为0或者负整数表示输入结束，并且无须处理。
题目输出：
对于每个测试序列，输出一行，给出电脑选定的数字，要求数字和位置都正确。你可以假设，每个测试序列都提供了足够的信息，让你可以猜出该数字。
输入样例：
2
1234 2A4B
1243 0A4B
3
0732 3A3B
1526 0A0B
4567 0A2B
-1

输出样例：
2134
0734

提示：
None



题目：幻方大分子(1765)
时间限制：1000MS
空间限制：131072KB
题目描述：
	先进复合材料（Advanced Composites Material，简称ACM）专指可用于加工主承力结构和次承力结构、其刚度和强度性能相当于或超过铝合金的复合材料。ACM具有质量轻，较高的比强度、比模量、较好的延展性、抗腐蚀、隔热、隔音、减震、耐高（低）温等特点，已被大量运用到航空航天、医学、机械、建筑等行业。	某校应用化学与材料中心(Applied Chemistry and Materials Center,简称ACM)研制出了新型先进复合材料分子——幻方大分子系列。	幻方大分子通过面向制造业的(AutoCAD Mechanical,简称ACM）设计，该系列的材料分子可以看作一个A*A*A（A<=50）的立方矩阵，矩阵内部整齐地排布着多种原材料小分子，这些原材料小分子的原子数不超过10。样例展示了一个边长为三和一个边长为四的幻方大分子沿Z轴方向材料结构剖析图，其中0表示该位置没有分子。	幻方大分子的制造流程较为复杂，包括层叠技术，超分子雕刻，奇原子吸附，离子腐蚀，空洞吸附。	层叠技术：技术人员通过纳米层叠膜，沿某个轴线方向（X或Y轴）搭建出A个层叠膜（可以看作A个边长为A的正方形）。由于材料强度特性的需要，层叠技术不能沿结构剖析图的Z轴使用。	超分子雕刻：用超分子雕刻刀在层叠膜上留下轨迹，由于原子数为奇数的材料小分子与层叠膜作用的特性，奇原子小分子会被吸附在雕刻刀留下的刀印下。需要注意的是雕刻刀只能沿平行于层叠膜的直线雕刻，且不能雕刻到非奇原子小分子所在的位置。	离子腐蚀：用离子束轰击，腐蚀掉层叠膜，留下完整的奇原子小分子的聚合结构。	空洞吸附：奇原子小分子的聚合结构上遗留的空洞结构具有吸附设计要求的偶原子小分子的能力，这部分工艺比较容易实现。	这些技术中花费最高的是使用超分子雕刻造成的损耗，应该尽量减少使用雕刻刀的数目。应用化学与材料中心的研究人员找到了你，你能帮助他们求出最少的雕刻的刀数么？
题目输入：
	题目包含多组测试数据,对于每一组数据:	第 1 行包含一个整数A，表示幻方材料分子的边长	接下来有A个长A宽A的矩阵，表示a个沿Z轴正方向的材料的原材料小分子结构剖析图
题目输出：
	一个数即最少的超分子雕刻刀数，格式见样例
输入样例：
3
103
929
103
222
535
222
103
929
103
4
3789
0121
5633
4926
3221
7788
2039
0017
2643
1131
2948
0905
6610
3322
0317
1372
输出样例：
Case 1 : 7
Case 2 : 18
提示：
None



题目：Goodmemory(1218)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Mr Yu has a good memory.If someone gives him some people's names.He can remember them in the orginal order.Even 100 people's names,he just need two minutes.dccmx is also a clever boy.He wants to challenge Mr Yu.Mr Yu creates a new rule.He gives dccmx some people's names in order(at most 1000 names.And name only contains lower case letters,no space).He also gives him the num of names he must remember.Mr Yu is mercy.He allows dccmx using at most m "@"s to mark the names he can't remeber.The names order can't be changed.If dccmx gives the n names using less "@" and it is substring of Mr Yu gives,it shows dccmx is clover."@" is useful.It can become the name you want.
题目输入：
The first line of the input contains an integer T (T <= 1000), indicating the number of cases. Each case begins with a single integer n( 0
题目输出：
For every case,if the t names in the given order may be the substring of the n names using less than "@".print "dccmx is clever!" in a single line.Otherwise,print "Oh,my god!" in a single line.
输入样例：
2
8
zhao
qian
sun
li
zhou
wu
zheng
wang
5 2
zhao
qian
@
li
zhou
5
zhao
qian
sun
li
zhou
3 1
zhao
qian
@

输出样例：
dccmx is clever!
Oh,my god!

提示：
None



题目：选数字(1013)
时间限制：6000 ms
空间限制：65535 ms
题目描述：
鱼头最近很喜欢一种特殊的福彩——二进制福彩，一串全是由01组成的福彩序列长度相同（爱好独特的教练）……
鱼头总是将自己喜欢的喜好存在一个盒子里面（他有许多盒子……），但是他只记得有哪些序列，却不记得他们的顺序……
现在他要买彩票了，作为ACM队的总教练，肯定是有些不同常人的地方！（不仅仅体现在鱼头标志性的笑容！）他会一种魔法，每次将i盒子里面的第a位为0的福彩序列移动到第j个盒子里面，
现在，问题来了，为了省些力气（施魔法要好很多力气的，天气好热啊！）鱼头指定了一个福彩序列，他很想知道最少施法多少次才能取得这个序列（即：某个盒子里面只剩下这一个序列）
题目输入：
第一行是测试次数，
第二行有两个数：福彩序列数n(1到20)和序列长度m(1到10)，
以下有n行，每行有m个数这n行里面的第一行即为鱼头想要的福彩序列；
题目输出：
输出最少施魔法次数
输入样例：
2
4 3
110
101
100
001
4 4
1000
1001
1100
1010
输出样例：
1
4
提示：




题目：HealthyHolsteins(1461)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer John prides himself on having the healthiest dairy cows in the world. He knows the vitamin content for one scoop of each feed type and the minimum daily vitamin requirement for the cows. Help Farmer John feed his cows so they stay healthy while minimizing the number of scoops that a cow is fed. Given the daily requirements of each kind of vitamin that a cow needs, identify the smallest combination of scoops of feed a cow can be fed in order to meet at least the minimum vitamin requirements. Vitamins are measured in integer units. Cows can be fed at most one scoop of any feed type. It is guaranteed that a solution exists for all contest input data.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  integer V (1 <= V <= 25), the number of types of vitamins  Line 2:  V integers (1 <= each one <= 1000), the minimum requirement for each of the V vitamins that a cow requires each day  Line 3:  integer G (1 <= G <= 15), the number of types of feeds available  Lines 4..G+3:  V integers (0 <= each one <= 1000), the amount of each vitamin that one scoop of this feed contains. The first line of these G lines describes feed #1; the second line describes feed #2; and so on.
题目输出：
The output is a single line of output that contains: 	the minimum number of scoops a cow must eat, followed by: 	a SORTED list (from smallest to largest) of the feed types the cow is given If more than one set of feedtypes yield a minimum of scoops, choose the set with the smallest feedtype numbers.
输入样例：
4
100 200 300 400
3
50   50  50  50
200 300 200 300
900 150 389 399
输出样例：
2 1 3
提示：




题目：英雄无敌3之自动战斗(1661)
时间限制：1000ms
空间限制：65535Kb
题目描述：
			英雄无敌3是近年来最经典的战棋类游戏之一。它强大的策略和战术对玩家的吸引经久不衰。每个人在战斗的时候控制己方的兵种进行战斗。而决定一场战斗的胜负，除了英雄的魔法、等级，人物操作的好坏，排兵布局的走位之外，最重要的就是己方各类兵种的数量和质量了。	Zymy非常喜欢玩这款游戏，而当他玩多了以后，为了提高效率，他最喜欢的就是里面的自动战斗功能了。Suninwinter知道了以后，很好奇，系统是通过什么算法来计算自动战斗的呢？经过推理和YY，suninwinter终于推测出了一种自动战斗的规则来。	为了简便起见，我们只考虑以下规则。	1、  每个英雄最多能带7个兵种，英雄的攻击力，防御力加成到每个兵种上，如英雄的攻击力和防御力为Ha,Hd,兵种原有的攻击力和防御力为Aa，Ad，则加成后变为Aa = Aa+Ha , Ad =Ad+Hd	2、  英雄的魔法值为英雄的智力数*10，英雄的魔法伤害为英雄的力量数*50，英雄单次的施法消耗的魔法值固定为12，英雄不受到攻击。	3、  每个兵种有攻击力，防御力，生命值，兵种数量和攻击速度五个属性。假设A兵种攻击B兵种，A兵种的各项属性分别为Aa,Ad,Ab,Am,As，相应的B的各项属性为Ba,Bd,Bb,Bm,Bs则A兵种发出的总伤害为：Am*Aa，B兵种按逐个单位来承受该伤害，首先查看Am*Aa是否大于Bd，若不大于，则B兵种的一个单位扣除一点生命值，若大于，则超出部分的攻击力全部作为扣除当前单位的生命值，若一个单位的生命值无法抵挡，则当前单位死亡，把剩余的攻击力放到下一个单位结算。此时同样要先结算攻击力是否大于防御力。当前兵种所有单位都死亡以后，当前伤害不再结算。（举个简单的例子，若Aa = 5，Am = 2，Bd = 3，Bb = 4，Bm = 2，则A发出的总伤害为10，大于Bd部分为7，然后Bb为4，不足以抵挡，死亡一个单位，剩余3的伤害，不大于Bd =3，所以第二个单位强制扣除1点生命值，最终结果是B兵种的数量剩余1，生命值为3）	4、  为了简便起见，每回合都是一左一右（左边先开始，即左、右、左、右这样的顺序攻击，己方英雄始终在左边，每回合每个兵种只能攻击一次，如果当前回合某方已经没有可攻击兵种，则本方轮空）间隔攻击，而攻击速度决定了该兵种本方攻击时的攻击次序，攻击速度相同的情况下则是先出现的兵种先行。英雄总是在回合最开始的时候进行攻击,英雄攻击效果计算方法与（3）相同，若该回合英雄没有魔法无法攻击，则英雄攻击不算伤害但也算攻击了一次。当己方和敌方所有英雄和兵种都攻击过后，则算一回合结束。	｛	第四条规则也可看以下每回合进攻示意图	A英雄魔法攻击->B英雄魔法攻击->A的攻速最快兵种a->B的攻速最快兵种a->A的次快攻速兵种->B的次快攻速兵种….	｝	 	5、  假设每个兵的攻击范围都是全屏，每个兵都可以被任意兵攻击（周围可容纳下的敌方兵种数量假设无上限）	6、  英雄可以装备治疗帐篷，治疗帐篷每回合回血20点，选择当前兵种中，单个兵剩余血量与最大血量差值最大的一个兵种进行治疗。（治疗最多回复到最大血量上限，无法复活已死单位）治疗帐篷总是在回合的最后回血，治疗帐篷不受攻击。	7、  每次所有兵种（包括英雄的魔法攻击，英雄每回合都攻击）攻击的都是敌方数量最多的兵种（请注意是数量而非总血量），若数量相同，优先攻击初始时排在前面的兵种。	8、  每回合每个兵种有一次反击机会，在能反击的第一时间反击。（如被英雄攻击无法反击，反击机会留到下次使用）	9、  在所有兵种行动完成后算一回和结束。	10、 所涉及到的所有数据都是整数,单个数值均小于等于100，大于等于0，计算都是整数计算（向下取整即可）。	11、 一方的所有兵种全部死亡则宣告失败。	 	Suninwinter想请你根据这些规则把一场战斗的结局判断出来。	
题目输入：
	第一行Case数 T，表面一共有T组case。	每个case的第一行为Aa,Ad,Ae,As,An(1<=An<=7),Azp，分别表示己方英雄的攻击力，防御力，智力，力量，以及己方英雄所带的兵种种类。Azp是1表示有急救帐篷，是0表示没有急救帐篷	接下来有五行，每行An个数，分别表示An个兵种的攻击力，防御力，生命值，数量和攻击速度。	接下来一行是敌方的英雄数据 Ba,Bd,Be,Bs,Bn,Bzp, 分别表示敌方英雄的攻击力，防御力，智力，力量，以及敌方英雄所带的兵种种类。Bzp是1表示有急救帐篷，是0表示没有急救帐篷。接下来有五行，每行Bn个数，分别表示这Bn个兵种的攻击力，防御力，生命值，数量和攻击速度。
题目输出：
	己方胜利则输出“Win!”否则输出“Lose!”	接下来两行分别按兵种出现顺序打印出己方和敌方兵种的死亡数量。
输入样例：
1
1 1 4 3 5 1
5 4 3 2 1
3 2 1 0 0
4 3 2 2 1
2 3 4 5 6
5 3 2 1 1
2 1 2 1 4 0
3 3 2 4
4 3 5 2
2 1 1 2
4 3 2 1
3 2 4 5

输出样例：
Win!
0 0 0 2 6
4 3 2 1

提示：

	感谢ZYMY、treert和HJWAJ的辛苦验题。


	此题AC除气球外额外奖励个水果~




题目：HelpBob(1360)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Bob loves Pizza but is always out of money. One day he reads in the newspapers that his favorite pizza restaurant, Alfredo's Pizza Restaurant, is running a competition: they will donate a big pizza to the first person who will tell them the lowest price per area that can be achieved by buying any of the pizzas at most once. "That task is easy!", thinks Bob, "For each pizza I just calculate the average price and the lowest quotient will be the answer.". 
Unfortunately the problem is a bit more complicated: with some pizzas Alberto gives out discount coupons for getting another pizza cheaper and even worse, those coupons can be combined. The pizzas have to be bought one after the other, and it is not possible to use a coupon to get a discount retrospectively for a pizza which has already been bought. Can you help Bob to become the first to solve this task and to get a pizza for free?
题目输入：
The input file contains several test cases. Each test case starts with a number m, the number of pizzas Alfredo offers. Input is terminated by m=0. Otherwise, 1 ≤ m ≤ 15. Then follow m lines describing the pizzas. Each of those following lines describes pizza i (1 ≤ i ≤ m) and starts with 3 integer numbers pi, ai and ni specifying the price of the pizza, its area and the number of discount coupons you get when buying it, 1 ≤ pi ≤ 10000, 1 ≤ ai ≤ 10000 and 0 ≤ ni < m. Then follow ni pairs of integer numbers xi,j and yi,j specifying the index xi,j (1 ≤ xi,j ≤ m, xi,j ≠ i) of the pizza you get a discount coupon for and the discount in percentage terms yi,j (1 ≤ yi,j ≤ 50) you get when buying pizza xi,j. You may assume that for each i the values xi,j are pairwise distinct.
题目输出：
For each test case print one line containing the lowest price per area that can be achieved by buying any of the pizzas at most once. Round this number to 4 places after the decimal point. Note that you can combine an arbitrary number of discount coupons: for a pizza with price 10 and two rabatt coupons for that pizza with a 50 and a 20 on it, you would only have to pay 10 * 0.8 * 0.5 = 4 monetary units.
输入样例：
1
80 30 0
2
200 100 1 2 50
200 100 0
5
100 100 2 3 50 2 50
100 100 1 4 50
100 100 1 2 40
600 600 1 5 10
1000 10 1 1 50
0

输出样例：
2.6667
1.5000
0.5333

提示：




题目：DoYouKnowtheWaytoSanJose?(1561)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	The Internet nowoffers a variety of interactive map facilities, so that users can see either anoverview map of a large geographic region or can ``zoom in'' to a specificstreet, sometimes even a specific building, on a much more detailed map. Forinstance, downtown San Jose might appear in a map of California, a map of SantaClara county, and a detailed street map.	Suppose you have a large collection of rectangular maps and you wish to designa browsing facility that will process a sequence of map requests for locationsat various levels of map detail. Locations are expressed using locationnames. Each location name has a unique pair of real coordinates (x,y).Maps are unique, labeled with identifying map names, and defined by two pairsof real coordinates-- (x1 ,y1) (x2 ,y2 )--representingopposite corners of the map. All map edges are parallel to the standardCartesian x and y axes. A map and a locationcan have the same name. The aspect ratio of a map is the ratioof its height to its width (where width is measured in the x directionand height is measured in the y direction).	The level of detail of a map can be approximated by using the rectangular arearepresented by the map; i.e., assume that a map covering a smaller areacontains more detailed information. Maps can overlap one another. If a location(x,y) lies within two or more maps having equal areas, thepreferred map (at that level of detail) is the one in which the location isnearest the center of the map. If the location is equidistant from the centersof two overlapping maps of the same area, then the preferred map (at that levelof detail) is the one whose aspect ratio is nearest to the aspect ratio of thebrowser window, which is 0.75. If this still does not break the tie, then thepreferred map is the one in which the location is furthest from the lower rightcorner of the map (this heuristic is intended to minimize the need forscrolling in the user's browser window). Finally, if there is still a tie, thenthe preferred map is the one containing the smallest x-coordinate.	The maximum detail level available for a given location is themaximal number of maps of different areas that contain the location. Clearly,different locations can have different maximum detail levels. The map at detail i forthe location is the map with the ith largest area among a maximalset of maps of the distinct area containing the location. Thus, the map atdetail level 1 for the location will be the least detailed (largest area) mapcontaining the location and the map at the maximum detail level will be themost detailed (smallest area) map containing the location.
题目输入：
	The input file consists of a set of maps, locations, and requests; it isorganized as follows:			The word ``MAPS'', in all     uppercase letters and on a line by itself, introduces a set of one or more     maps. Following the set heading, each map is described by a single line     consisting of a map name (an alphabetic string with no leading, trailing,     or embedded blanks) and two real coordinate pairs--               --representing     opposite corners of the map. 				The word ``LOCATIONS'', in all uppercase letters and on a line by     itself, introduces a set of one or more locations. Following this heading,     each location is described by a line consisting of a location name (an     alphabetic string with no leading, trailing, or embedded blanks) and a     real coordinate pair-- --representing the center of the location. 				The word ``REQUESTS'', in all uppercase letters and on a line by     itself, introduces a set of zero or more requests. Following this heading,     each request is described by a line consisting of a location name (an     alphabetic string with no leading, trailing, or embedded blanks) followed     by a positive integer representing the desired detail level for that location. 				The word ``END'', in all uppercase and on a line by itself,     terminates the file. 		All map andlocation data preceding the requests are valid. There will be no duplicatemaps. The result of processing a valid request is the name of the map containingthe given location at the given detail level (using the tie-breaking rulesdescribed above). Invalid requests can result from requesting unknown locationnames, locations that do not appear in any map, or detail levels that exceedthe number of maps of different areas containing the location.	The following example should illustrate all these definitions:
题目输出：
	Each request must be echoed to the output. If the request is valid,display the name of the map satisfying the request. If the location is not on amap, display a message to that effect. If the location is on the map but thedetail level is too large, display the name of the map of the smallestavailable area (largest possible detail level).
输入样例：
MAPS
BayArea -6.0 12.0 -11.0 5.0
SantaClara 4.0 9.0 -3.5 2.5
SanJoseRegion -3.0 10.0 11.0 3.0
CenterCoast -5.0 11.0 1.0 -8.0
SanMateo -5.5 4.0 -12.5 9.0
NCalif -13.0 -7.0 13.0 15.0
LOCATIONS
Monterey -4.0 2.0
SanJose -1.0 7.5
Fresno 7.0 0.1
SanFrancisco -10.0 8.6
SantaCruz -4.0 2.0
SanDiego 13.8 -19.3
REQUESTS
SanJose 3
SanFrancisco 2
Fresno 2
Stockton 1
SanDiego 2
SanJose 4
SantaCruz 3
END

输出样例：
SanJose at detail level 3 using SanJoseRegion
SanFrancisco at detail level 2 using BayArea
Fresno at detail level 2 no map at that detail level; using NCalif
Stockton at detail level 1 unknown location
SanDiego at detail level 2 no map contains that location
SanJose at detail level 4 using SantaClara
SantaCruz at detail level 3 no map at that detail level; using CenterCoast

提示：
None



题目：矩形重叠面积(1115)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
题目描述：豆豆最近喜欢一个电脑游戏，游戏规则如下：在一个二维平面坐标系中，有一系列各边都平行于坐标轴的矩形。且所有矩形均在坐标系的第一象限。游戏要求豆豆在最快的时间内把重叠部分的面积算出来，但是豆豆很不想手算，他找你来编一个程序帮助他计算重叠部分的面积。
题目输入：
第一行是一个正整数T ( 1 <= T <=100 ),代表测试数据的数量.每个测试数据的第一行是一个正整数N(1<=N<=1000),代表矩形的数量,然后是N行数据,每一行包含四个浮点数,代表平面上的一个矩形的左下角坐标和右上角坐标,矩形的上下边和X轴平行,左右边和Y轴平行.坐标的范围从0到100000。
题目输出：
对于每组测试数据,请计算出被这些矩形覆盖过至少两次的区域的面积.结果保留两位小数。
输入样例：
2
5
1 1 4 2
1 3 3 7
2 1.5 5 4.5
3.5 1.25 7.5 4
6 3 10 7
3
0 0 1 1
1 0 2 1
2 0 3 1

输出样例：
7.63
0.00

提示：




题目：加密网络(1766)
时间限制：1000MS
空间限制：131072KB
题目描述：
	某军事科研机构在内部搭建了局域网，由于军事科研项目的特殊性，网络通讯之间的保密协议成为了一个重要课题。	该机构的网络技术人员开发出这样一套方案来构建网络：	该网络中一共有N台电脑，每台电脑都视为一个计算机结点。	两台计算机之间若需要通讯，则在两台计算机之间直接建立通讯线路；这样数据不经过别的计算机转发，可以保证数据不会被中途监听，两台计算机之间可能存在多条通讯线路,一台计算机不会与自己有一条通讯线路。	技术人员把网络中的计算机分为两种：把长期保存涉密信息的电脑成为涉密计算机，而辅助涉密计算机进行大型运算的机器成为工作计算机。	网络中每台计算机在运行都有一个加密系数（非负整型）。对于每台涉密计算机设一个固定的加密系数，由技术人员统一分配；对于每台工作计算机，在工作时随机生成一个加密系数。	在两台加密系数分别为X和Y的计算机进行通信时，该网络的通讯协议要求通信数据进行加密，加密方法为：X与Y进行异或，其结果为Z，生成一个长度为Z的通讯校验码，校验码的内容与日期和通讯计算机的加密系数有关。	虽然上述机制在很大程度上保证了数据的保密，但是在需要大量计算机协同工作时，通讯校验码过长会影响科研计算的效率。于是在有重大科研项目计算时，技术人员通过人工分配工作计算机加密系数的方法，使得网络中所有通讯线路的通讯校验码的长度之和最短。	给你网络中计算机与通讯线路的信息，并给你所有涉密计算机的加密系数，现在技术人员想知道：通过分配工作计算机加密系数，所有通讯线路的通讯校验码的长度之和的最小值是多少。这个任务就交给你来完成
题目输入：
	多组样例输入，对于每一组样例:	第一行两个整数N（ <=500 ）和M( <=2500 )，表示计算机节点数与通信线路数	接下来M行，每行两个整数U，V，表示一条通信线路相互通信的两个结点编号	之后一行，包含一个整数P( <=N )，表示已经获得加密系数的计算机节点数	接下来P行，每行两个整数V与W，涉密计算机结点的序号与该结点的加密系数X
题目输出：
	一个整数，即所有线路最小的通讯校验码长度之和
输入样例：
3 2
1 3
3 2
2
1 100
2 5
输出样例：
97
提示：
None



题目：安装摄像头(1014)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
当下，全国各地安全事故时有发生。各大高校对此很是重视。于是，高校安全设施也相应的增加了。其中摄像头的安装对安全稳定的重要性不言而喻。简而言之，为了实时监控某个区域的状况，我们要在某些区域安装摄像头。
为了使问题简单化，将某个区域看成是有若干方格组成的正方形，每堵墙占一个方格，墙会阻碍摄像头的摄像。也许是各大高校过于紧张，他们觉得安装的摄像头越多越好，然而他们又不希望过于浪费（即不希望两个或多个摄像头出现在同一行或同一列）。当然大前提是监控整个区域。 请你帮忙找出可以安装的最大摄像头数。（可以假设，每个摄像头只能监控它所在方格的列和行）。

题目输入：
有多个用例直到文件结尾
每个用例的形式如下：
第一行：n分别表示矩形方格的行数和列数（1<=n<=4）
以下为n*n矩阵。用 “.” 表示空的区域，用“X”表示墙。

题目输出：
一个整数，表示所要安装的最大摄像头数。
输入样例：
4
....
....
....
....
4
.X..
....
XX..
....
输出样例：
4
5
提示：




题目：Howtosit(1219)
时间限制：6000 ms
空间限制：131072 ms
题目描述：
Mr Yu will get marrid soon.He wants to treat ACMers in advance.We will go to Jinling Hotel.And sit along a roundtable.But a problem may occur.Someone doesn't want to sit next to another.For example,messIDou and thinking610 don't want to sit together.As you know,Mr Yu's seat is fixed because of treating others.There will be n persons and we mark every person by a unique number(0...n-1).Mr Yu is Number 0.Good ACMer,please tell me how many kinds of ways to sit.
题目输入：
There are multiple test cases in the input file. Every case start with two integers N,M ( 1<=N<=18,M<=N*N )The followed M lines contains two integers a,b ( 0<=a,b
题目输出：
For each test case,output the number of ways to sit in a single line.
输入样例：
3 3
0 1
0 2
1 2

输出样例：
2

提示：
None



题目：theSwordofGryffindor(1662)
时间限制：1000MS
空间限制：65535K
题目描述：
	As we all known,the Sword of Gryffindor is the symbol of Gryffindor, which can help those students in Gryffindor who are brave enough when necessary. However, there are something must be tell you that, in goblins' world, they believe that who make the thing, who own it. Oneday, they conjured at the Sword so that it will be larger and larger when someone take it. What's more, the longer time you holdfor, the larger it will be. If you hold it for more than 5 seconds, it can crush everything.	Now, little Harry is curious about how large it can be, but obviously, as you are so kindand smart, you won't let Harry to run the risk. So please write a program to show large the Sword will be.
题目输入：
	The input consists of several lines, each line is an integer n (0 <= n <= 5), which means the time that someone hold the Sword.	The input file ends with EOF.
题目输出：
	The output show the Sword is like, corresponding to the input above.	Each case endswith "END"(without the quota).
输入样例：
0
1
2

输出样例：
+
END
 + 
+++
 + 
 + 
END
    +    
   +++   
    +    
    +    
 +  +  + 
+++++++++
 +  +  + 
 +  +  + 
    +    
   +++   
    +    
    +    
    +    
   +++   
    +    
    +    
END
提示：
None



题目：Annoyingpaintingtool(1361)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Maybe you wonder what an annoying painting tool is? First of all, the painting tool we speak of supports only black and white. Therefore, a picture consists of a rectangular area of pixels, which are either black or white. Second, there is only one operation how to change the colour of pixels: 
Select a rectangular area of r rows and c columns of pixels, which is completely inside the picture. As a result of the operation, each pixel inside the selected rectangle changes its colour (from black to white, or from white to black). 
Initially, all pixels are white. To create a picture, the operation described above can be applied several times. Can you paint a certain picture which you have in mind?
题目输入：
The input contains several test cases. Each test case starts with one line containing four integers n, m, r and c. (1 ≤ r ≤ n ≤ 100, 1 ≤ c ≤ m ≤ 100), The following n lines each describe one row of pixels of the painting you want to create. The ith line consists of m characters describing the desired pixel values of the ith row in the finished painting ('0' indicates white, '1' indicates black). 

The last test case is followed by a line containing four zeros. 

题目输出：
For each test case, print the minimum number of operations needed to create the painting, or -1 if it is impossible.
输入样例：
3 3 1 1
010
101
010
4 3 2 1
011
110
011
110
3 4 2 2
0110
0111
0000
0 0 0 0

输出样例：
4
6
-1

提示：




题目：SpreadsheetTracking(1562)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	Data in spreadsheets are stored in cells, which are organized in rows (r)and columns (c). Some operations on spreadsheets can be applied tosingle cells (r,c), while others can be applied to entire rows orcolumns. Typical cell operations include inserting and deleting rows or columnsand exchanging cell contents.	Some spreadsheets allow users to mark collections of rows or columns fordeletion, so the entire collection can be deleted at once. Some (unusual)spreadsheets allow users to mark collections of rows or columns for insertionstoo. Issuing an insertion command results in new rows or columns being insertedbefore each of the marked rows or columns. Suppose, for example, the user marksrows 1 and 5 of the spreadsheet on the left for deletion. The spreadsheet thenshrinks to the one on the right.	   	 	If the usersubsequently marks columns 3, 6, 7, and 9 for deletion, the spreadsheet shrinksto this. 	 																					 																								1 																								2 																								3 																								4 																								5 																														1 																								2 																								24 																								8 																								22 																								16 																														2 																								18 																								19 																								21 																								22 																								25 																														3 																								24 																								25 																								67 																								22 																								71 																														4 																								16 																								12 																								10 																								22 																								58 																														5 																								33 																								34 																								36 																								22 																								40 																If the user marksrows 2, 3 and 5 for insertion, the spreadsheet grows to the one on the left. Ifthe user then marks column 3 for insertion, the spreadsheet grows to the one inthe middle. Finally, if the user exchanges the contents of cell (1,2) and cell(6,5), the spreadsheet looks like the one on the right. 	     	You must writetracking software that determines the final location of data in spreadsheetsthat result from row, column, and exchange operations similar to the onesillustrated here. 	
题目输入：
	The input consists of a sequence of spreadsheets, operations on thosespreadsheets, and queries about them. Each spreadsheet definition begins with apair of integers specifying its initial number of rows (r) and columns (c),followed by an integer specifying the number (n) of spreadsheetoperations. Row and column labeling begins with 1. The maximum number of rowsor columns of each spreadsheet is limited to 50. The following n lines specifythe desired operations.	An operation to exchange the contents of cell (r1, c1)with the contents of cell (r2, c2)is given by:	EX r1 c1 r2 c2	The four insert and delete commands--DC (delete columns), DR (delete rows), IC (insertcolumns), and IR (insert rows) are given by:	<command> A x1 x2 where <command> is one of the four commands; A isa positive integer less than 10, and x1,...,xA are the labels of the columns or rows to be deleted or inserted before. For each insert and delete command, the order of the rows or columns in the command has no significance. Within a single delete or insert command, labels will be unique.	The operations are followed by an integer which is the number of queries forthe spreadsheet. Each query consists of positive integers r and c,representing the row and column number of a cell in the original spreadsheet.For each query, your program must determine the current location of the datathat was originally in cell (r,c). The end of input is indicatedby a row consisting of a pair of zeros for the spreadsheet dimensions.
题目输出：
	For each spreadsheet, your program must output its sequence number(starting at 1). For each query, your program must output the original celllocation followed by the final location of the data or the word GONE if thecontents of the original cell location were destroyed as a result of theoperations. Separate output from different spreadsheets with a blank line.	The data file will not contain a sequence of commands that will cause thespreadsheet to exceed the maximum size.
输入样例：
7 9
5
DR   2  1 5
DC  4  3 6 7 9
IC  1  3
IR  2  2 4
EX 1 2 6 5
4
4 8
5 5
7 8
6 5
0 0

输出样例：
Spreadsheet #1
Cell data in (4,8) moved to (4,6)
Cell data in (5,5) GONE
Cell data in (7,8) moved to (7,6)
Cell data in (6,5) moved to (1,2)

提示：
None



题目：HammingCodes(1462)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Given N, B, and D: Find a set of N codewords (1 <= N <= 64), each of length B bits (1 <= B <= 8), such that each of the codewords is at least Hamming distance of D (1 <= D <= 7) away from each of the other codewords. The Hamming distance between a pair of codewords is the number of binary bits that differ in their binary notation. Consider the two codewords 0x554 and 0x234 and their differences (0x554 means the hexadecimal number with hex digits 5, 5, and 4):         0x554 = 0101 0101 0100        0x234 = 0010 0011 0100Bit differences: xxx  xxSince five bits were different, the Hamming distance is 5.
题目输入：
There are several test cases, end by EOF, for each test case:N, B, D on a single line
题目输出：
N codewords, sorted, in decimal, ten per line. In the case of multiple solutions, your program should output the solution which, if interpreted as a base 2^B integer, would have the least value.
输入样例：
16 7 3
输出样例：
0 7 25 30 42 45 51 52 75 76
82 85 97 102 120 127
提示：




题目：钢铁之躯(1767)
时间限制：1000MS
空间限制：131072KB
题目描述：
	通过追寻超人无意间发出的氪星讯号，邪恶的Zod将军带领他的军队跨越了漫长的光年，抵达了地球。在漫长的太空旅行中，Zod在氪星人以前探索过的的星球上，搜集了了n个氪星改造器，他将这些改造器带到了地球，试图摧毁地球重建氪星。	正义的超人当然不能允许邪恶的Zod将军摧毁地球，为了摧毁Zod将军散布在世界各地的并派遣重兵把守的氪星改造器，超人需要吸收阳光补充能量。已知超人储存阳光的能量不能大于一个上限m，同时地球各地的光照条件不一样，所以吸收同等的阳光所花费的时间也不一样，超人必须按照顺序摧毁改造器解救地球，问他最少需要多少时间？
题目输入：
		第一个是样例数t(t<=60),每个样例首先是两个数字n，m，代表超人需要摧毁的氪星改造器的数目n，还有他所能最大储存的太阳能量m，接下来是n行，分别有两个数字x，y，代表摧毁第i个氪星改造器的所需消耗的能量x，以及在第i个氪星改造器所在地吸收单位能量所需花费的时间y，超人必须按照从1到n的顺序摧毁改造器,如果超人在能量不够，则因无法摧毁改造器而战死，除t之外的数字大于0不超过100000.	
题目输出：
	如果能摧毁所有的改造器，输出最少需要多长时间（只算吸收阳光的时间，战斗时间忽略不计），如果超人不能摧毁所有的改造器，输出"superman is dead!".
输入样例：
3
3 10
10 5
5 10
2 10
2 20
22 1
10 10
3 5
1 10
2 8
3 5
输出样例：
120
superman is dead!
41
提示：
超人初始能量为0，超人在战斗前吸收阳光，战斗结束后立刻去到下一个地点。



题目：新版炮兵阵地(1116)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
司令部的将军们又一次的打算在N*M的网格地图上部署他们的炮兵部队。一个N*M的地图由N行M列组成，地图的每一格可能是山地（用"H" 表示），也可能是平原（用"P"表示），如下图。与上次不同的是，这次他们装备了新型火炮，隔山打牛牌火炮。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示： 

    
        
            
            P
            
            
            P
            
            
            H
            
            
            P
            
            
            H
            
        
        
            
            P
            
            
            H
            
            
            P
            
            
            H
            
            
            P
            
        
        
            
            P
            
            
            P
            
            
            P
            
            
            H
            
            
            H
            
        
        
            
            H
            
            
            H
            
            
            H
            
            
            P
            
            
            H
            
        
        
            
            H
            
            
            P
            
            
            P
            
            
            H
            
            
            H
            
        
    

如果在地图中的红色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。 现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。
题目输入：
第一行一个正整数T，表示几组测试数据；
每组测试数据 
第一行包含两个由空格分割开的正整数，分别表示N和M；
接下来的N行，每一行含有连续的M个字符('P'或者'H')，中间没有空格。按顺序表示地图中每一行的数据。N < = 200；M <= 24。

题目输出：
每组输出一个整数K，表示最多能摆放的炮兵部队的数量。
输入样例：
1
5 4
PHPP
PPHH
PPPP
PHPP
PHHP

输出样例：
10

提示：




题目：Ilovemath(1220)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	There are n numbers( 1 ~ n ) stand in an order . Now give you a sequence.Please deal with the n numbers using the sequence.such as : n numbers : 1 2 3 4 5  ( sequence 1 )a sequence: 2 1 4 3 5  ( sequence 2 )	sequence 1 change into 2 1 4 3 5 by the sequence 2 once.sequence 1 change into 1 2 3 4 5 by the sequence 2 twice.	so the answer is 2.It means sequence 1 need two times go back to itself.
题目输入：
There are multiple test cases.The first line contain a integer t( t <= 1000 ), indicate t cases.For each case,the first line contain a integer n.next two line contain two sequence (sequence 1 and sequence 2 )
题目输出：
For each case ,please print the answer mod 100007.
输入样例：
1
5
2 1 3 4 5
1 3 2 4 5

HINT:
样例解释：第一步： 2 3 1 4 5      第二步： 2 1 3 4 5 
输出样例：
2

提示：
None



题目：正方形(1015)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
正方形的每条边上有n个点（包括两个端点在内），用m种颜色来涂这些点。注意，如果方案1通过旋转或翻转得到的方案2，则两方案属于同一方案，即等价，问本质不同的方案数
题目输入：
多组测试数据,以文件尾结束.
每行包括两个整数n，m（2<=n<=7,1<=m<=4）

题目输出：
每行输出所求的不同方案数
输入样例：

2  2
3  2
输出样例：
6
51

提示：




题目：ACM队进新人(一)(1663)
时间限制：1000MS
空间限制：65535K
题目描述：
	今年NJUST ACM队来了n个新人，按照传统，鱼头让他们做了一个游戏。首先，所有人围坐在一张圆桌周围，指定一个人编号为1，从这个人开始，按顺时针方向将所有人编号为1至n。然后，从编号为1的人开始从1报数，数到m的人出列，下一个人又从1开始报数，数到m的人又出列。依此规律重复下去，直到圆桌周围的人全部出列。鱼头想知道每一个人在第几轮报数中出列，这个问题就交给你来解决。
题目输入：
	输入由很多组样例组成，每组样例只有一行，包含三个正整数n、m、k（1<=n<=1000，1<=m<=10000，1<=k<=n），分别代表新队员的个数、出列的人报到的数字、问题求解的人的编号。输入以文件尾结束。
题目输出：
	对每一个样例，输出一行，开头是样例的编号（从1开始编号），然后输出编号为k的人在第几轮报数中出列。
输入样例：
3 2 2
6 5 3
输出样例：
Case 1: 1
Case 2: 5
提示：
None



题目：Blackandwhitepainting(1362)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
You are visiting the Centre Pompidou which contains a lot of modern paintings. In particular you notice one painting which consists solely of black and white squares, arranged in rows and columns like in a chess board (no two adjacent squares have the same colour). By the way, the artist did not use the tool of problem A to create the painting.
Since you are bored, you wonder how many 8 × 8 chess boards are embedded within this painting. The bottom right corner of a chess board must always be white.
题目输入：
The input contains several test cases. Each test case consists of one line with three integers n, m and c. (8 ≤ n, m ≤ 40000), where n is the number of rows of the painting, and m is the number of columns of the painting. c is always 0 or 1, where 0 indicates that the bottom right corner of the painting is black, and 1 indicates that this corner is white. 

The last test case is followed by a line containing three zeros.

题目输出：
For each test case, print the number of chess boards embedded within the given painting.
输入样例：
8 8 0
8 8 1
9 9 1
40000 39999 0
0 0 0

输出样例：
0
1
2
799700028

提示：




题目：PrefaceNumbering(1463)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A certain book's prefaces are numbered in upper case Roman numerals. Traditional Roman numeral values use a single letter to represent a certain subset of decimal numbers. Here is the standard set:         I   1     L   50    M  1000        V   5     C  100        X  10     D  500As many as three of the same marks that represent 10n may be placed consecutively to form other numbers: III is 3 CCC is 300 Marks that have the value 5x10n are never used consecutively. Generally (with the exception of the next rule), marks are connected together and written in descending order to form even more numbers: CCLXVIII = 100+100+50+10+5+1+1+1 = 268 Sometimes, a mark that represents 10^n is placed before a mark of one of the two next higher values (I before V or X; X before L or C; etc.). In this case, the value of the smaller mark is SUBTRACTED from the mark it precedes: IV = 4 IX = 9 XL = 40 This compound mark forms a unit and may not be combined to make another compound mark (e.g., IXL is wrong for 39; XXXIX is correct). Compound marks like XD, IC, and XM are not legal, since the smaller mark is too much smaller than the larger one. For XD (wrong for 490), one would use CDXC; for IC (wrong for 99), one would use XCIX; for XM (wrong for 990), one would use CMXC. 90 is expressed XC and not LXL, since L followed by X connotes that successive marks are X or smaller (probably, anyway). Given N (1 <= N < 3,500), the number of pages in the preface of a book, calculate and print the number of I's, V's, etc. (in order from lowest to highest) required to typeset all the page numbers (in Roman numerals) from 1 through N. Do not print letters that do not appear in the page numbers specified. If N = 5, then the page numbers are: I, II, III, IV, V. The total number of I's is 7 and the total number of V's is 2.
题目输入：
There are several test cases, end by EOF, for each test case:A single line containing the integer N.
题目输出：
The output lines specify, in ascending order of Roman numeral letters, the letter, a single space, and the number of times that letter appears on preface page numbers. Stop printing letter totals after printing the highest value letter used to form preface numbers in the specified set.
输入样例：
5
输出样例：
I 7
V 2
提示：




题目：LeadorGold(1563)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	How to make gold from lead has baffled alchemists for centuries. At thelast Alchemists Club Meeting (ACM), a sensational breakthrough was announced.By mixing the three chemicals Algolene, Basicine and Cobolase in the correctratio, one can create a mixture that transforms lead into gold. Since Algolene,Basicine and Cobolase (or A, B, C for short) are generally not soldindividually, but rather mixed into solutions, this may not be easy as itseems. 	Consider the following example. Two mixtures of Algolene, Basicine andCobolase are available, in weights 1:2:3 and 3:7:1, respectively. By mixingthese solutions in a ratio of 1:2 we obtain a solution of A, B, C with weights7:16:5. But there is no way to combine these mixtures into a new one withweights 3:4:5. If we additionally had a solution of weights 2:1:2, then a 3:4:5mixture would be possible by combining eight parts of 1:2:3, one part of 3:7:1and five parts of 2:1:2. As you see in both examples, weights for eachcomponent must be integers. Determining which mixing weights we can obtain from agiven set of solutions is no trivial task. But, as the ACM has shown, it ispossibly a very profitable one. You must write a program to find mixing ratios. 
题目输入：
	The input file contains several test cases. The firstline of each test case contains an integer n ( 0	Finally, there is one line containing three non-negative integers a, b, c, which specify the weights a : b : c inthe desired solution. At least one of these integers is not 0. The input file is terminated with the integer `0'on a line by itself following the last test case. 
题目输出：
For each test case, outputthe word `Mixture', followed by the ordinal number of the test case. Onthe next line, if it is possible to obtain the desired solution by mixing theinput solutions, output the word `Possible'. Otherwise, outputthe word `Impossible'. Print a blank line between consecutive test cases.
输入样例：
2
1 2 3
3 7 1
3 4 5
3
1 2 3
3 7 1
2 1 2
3 4 5
0

输出样例：
Mixture 1
Impossible

Mixture 2
Possible

提示：
None



题目：鱼头买菜(1768)
时间限制：4000MS
空间限制：131072KB
题目描述：
	鱼头有一天想去给鱼儿子做一顿丰盛的大餐。由于他不太会挑菜，所以他决定去超市里买包装好的现成的材料。到了超市，鱼头发现超市里共有n种菜的食材，每种都装在一个保鲜盒中。每一盒都可以做一样菜，包含若干种不同的食材，比如蒜苗、肉丝就放在一个袋子里。并且，不同盒子里可能有相同的食材，鱼头可以将它们放在一起供自己调配。	   由于鱼头是个勤俭节约的好孩子，他想花最少的钱买到尽可能丰富多彩的食材。这个“丰富多彩”就定义为，对于他买的任意k盒，必须包含至少k（k为任意非负整数）种不同的食材，并且，最终买多少盒就要有多少种食材。	   现在告诉你每一盒的营养综合指标Pi（Pi为整数，Pi越小，表示能吸收的营养越多，价值越高），请你帮帮鱼头，他买的食材的营养价值最多可以达到多高？（如果实在没有足够营养的东西，他也可以不买）
题目输入：
	有多组输入，每组输入之间以空行隔开。	   每组的第一行：n(1<=n<=300)	   下面n行，每行以mi(1<=mi<=n)开头，表示第i个袋子里有mi种食材，然后mi个正整数a(i,j)，表示不同的食材(1<=a(i,j)<=n)。	   最后一行n个数，表示每盒的营养综合指标Pi.
题目输出：
	 对每组数据，第一行输出Case数；第二行输出最高营养价值和购买盒数，并以空格隔开；第三行输出购买方案（按盒子编号从小到大输出，若不买，则不输出此行）。
输入样例：
3
1 1
2 2 3
1 3
10 20 -3

5
2 1 2
2 2 3
2 3 4
2 4 5
2 5 1
1 -1 1 -1 1
输出样例：
Case #1:
-3 1
3
Case #2:
0 0
提示：
None



题目：跳马(1117)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
相信大家都玩过象棋，象棋中马跳日。Alice 和Bob现在想玩一个游戏，在一个n * n的棋盘，棋盘中放了m个马。游戏规则如下：
1）  Alice先手 
2）  玩家轮流操作，每次合法操作是将其中一个马按照日移到其左上方一点，注意只能往左上方移动。最左上方的位置是（ 1  ， 1 ），同一位置可以有多个马，但是每次移动只能移动一个马。
玩家都很有谋略，他们都以最优策略来下每一步。问最后谁能取胜
题目输入：
第一行输入整数t  (  t  < = 100 ), 则有t 个case。
每个case 先输入 棋盘的大小 n  (   n  < =  500  ) ，马的个数 m（ m < = 20000 ）
下面m行输入马的坐标位置 x ，y （ 1 = < x < = 500  1 = < y < = 500 ）

题目输出：
对于每个case 输出谁会获得最终胜利。
注意：马只要是日就可以跳，而不需要满足象棋中的一些其他规矩

输入样例：
2
5 2
2 2 
2 3
5 2
3 3
2 3

输出样例：
Case 1: Alice
Case 2: Bob

提示：




题目：Judgethechampion(1221)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
In the final of World Dota Cup,two best teams from China(LGD and Ehome) both get 9 wins and rank the first.But there is only one champion,they must decide which team.messIDou loves the two teams very much. He came up with an idea.Randomly given a number(at most 100 digits),change it to binary.So this number only has "0" and "1".And the binary number can't begin with "0" except the number 0.If the number of "0"s is bigger than the number of "1"s,Ehome wins. If the number of "1"s is bigger than the number of "0"s,LGD wins.But if equal,the team from njust_28_409---Super will become the champion.
题目输入：
The first line of the input is a single integer T, representing the number of test cases. Then the T test cases follows. Each line contains a number(at most 100 digits).And the number won't begin with "0" except the number 0
题目输出：
For each test case,If LGD wins,output "LGD",If Ehome wins,output "Ehome",If neither,output "Super",in a single line
输入样例：
3
1
2
8

输出样例：
LGD
Super
Ehome

提示：
None



题目：XiaoMing'sProblem(1016)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
Our little young Xiaoming is a really lovely boy.And he always has a lot of funny ideas.
In recent times, he decides to travel to see beautiful scenaries, such as Nanjing University of Science and Technology. However, he also hears that there are really many beautiful girls in Sichuan Province.
Things do not come easy. What troubles him so much is that since there are some places which he can only go from or go to(the transportation is not that convenient), in some circumstances he cannot go back home in any ways.
Here comes your problem.
Try to help XiaoMing to decide if it is possible.
题目输入：
The first line contains the test cases.
The second line tells you the number of the places N and the number M of the roads between them.
Then M lines follow. Each line has three numbers which mean the the two places .For example   1 2 0 tells that XiaoMing can go from 1 to 2 or from 2 to 1.If the third number is 1,it means that he  can only go from 1to 2 in the only direction.If the number is 0,it means that he can go from 1 to 2 and also can go from 2 to 1.On the other hand, if the two numbers come twice the same as some others that is listed above, it means he should go twice. Totally he should go every way which is listed, and he should return to his starting point in the end.(His starting point is unknown at the beginning.)
题目输出：
If he can go back home and go every way, print “ Yes”.
Else print “No”.
输入样例：
2
5 6
1 3 0
3 1 0
1 2 1
2 5 1
5 4 0
4 3 1
5 8
2 1 0
1 3 0
4 1 1
1 5 0
5 4 1
3 4 0
4 2 1
2 2 0
输出样例：
No
Yes
提示：




题目：ACM队进新人(二)(1664)
时间限制：1000MS
空间限制：65535K
题目描述：
	今年NJUST ACM队来了n个新人，按照传统，鱼头让他们做了一个游戏。首先，每个人在“A”、“C”、“M”三个字母中选择一个作为他们喜爱的字母。然后，让他们所有人以任意顺序站成一排。鱼头不希望出现这样的情况：从左到右的相邻的三个人，他们喜爱的字母依次是“A”、“C”、“M”。最后，从左到右，把所有人喜爱的字母按次序连接成一个字符串，鱼头想知道总共能组成多少满足条件且互不相同的字符串，这个问题就交给你来解决。
题目输入：
	输入由很多组样例组成，每组样例只有一行，包含一个正整数n（3<=n<=40），代表新队员的个数。输入以文件尾结束。
题目输出：
	对每一个样例，输出一行，开头是样例的编号（从1开始编号），然后输出能组成字符串的个数。
输入样例：
3
4
输出样例：
Case 1: 26
Case 2: 75
提示：
None



题目：Cylinder(1363)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Using a sheet of paper and scissors, you can cut out two faces to form a cylinder in the following way: 

Cut the paper horizontally (parallel to the shorter side) to get two rectangular parts. 
From the first part, cut out a circle of maximum radius. The circle will form the bottom of the cylinder. 
Roll the second part up in such a way that it has a perimeter of equal length with the circle's circumference, and attach one end of the roll to the circle. Note that the roll may have some overlapping parts in order to get the required length of the perimeter. 
Given the dimensions of the sheet of paper, can you calculate the biggest possible volume of a cylinder which can be constructed using the procedure described above? 
题目输入：
The input consists of several test cases. Each test case consists of two numbers w and h (1 ≤ w ≤ h ≤ 100), which indicate the width and height of the sheet of paper. 

The last test case is followed by a line containing two zeros.

题目输出：
For each test case, print one line with the biggest possible volume of the cylinder. Round this number to 3 places after the decimal point.
输入样例：
10 10
10 50
10 30
0 0

输出样例：
54.247
785.398
412.095

提示：
In the first case, the optimal cylinder has a radius of about 1.591549, in the second case, the optimal cylinder has a radius of 5, and in the third case, the optimal cylinder has a radius of about 3.621795.



题目：SubsetSums(1464)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
For many sets of consecutive integers from 1 through N (1 <= N <= 39), one can partition the set into two sets whose sums are identical. For example, if N=3, one can partition the set {1, 2, 3} in one way so that the sums of both subsets are identical: {3} and {1,2} This counts as a single partitioning (i.e., reversing the order counts as the same partitioning and thus does not increase the count of partitions). If N=7, there are four ways to partition the set {1, 2, 3, ... 7} so that each partition has the same sum: {1,6,7} and {2,3,4,5} {2,5,7} and {1,3,4,6} {3,4,7} and {1,2,5,6} {1,2,4,7} and {3,5,6} Given N, your program should print the number of ways a set containing the integers from 1 through N can be partitioned into two sets whose sums are identical. Print 0 if there are no such ways. Your program must calculate the answer, not look it up from a table.
题目输入：
There are several test cases, end by EOF, for each test case:The input file contains a single line with a single integer representing N, as above.
题目输出：
The output file contains a single line with a single integer that tells how many same-sum partitions can be made from the set {1, 2, ..., N}. The output file should contain 0 if there are no ways to make a same-sum partition.
输入样例：
7
输出样例：
4
提示：




题目：TowersofPowers(1564)
时间限制：3000 ms
空间限制：655350 ms
题目描述：
	One of the manyproblems in computer-generated graphics is realistically modeling the ``orderlyrandomness'' of things like mountain ranges and city skylines. A new studentintern at a graphics company had an idea--use fluctuations in numberrepresentations to model height. In this problem you will compute several suchnumber representations and show the ``skylines'' they produce.	Let n be any positive integer, and let b be an integer greater than or equalto 2. The completebase - bexpansionofn is obtainedas follows. First write the usual base-b expansion of n, which is just a sum of powers of b, each multiplied by a coefficient between1 and b - 1, omitting terms with zero coefficients.For example, if n = 20000 and b = 3, the base-3expansion of 20000 is given by	20000 = 39 + 35 + 2×33 +2×32 + 2	To obtainthe complete base-b expansion, we apply the sameprocedure to the exponents until all numbers are represented in base b. For n = 20000 and b = 3 we wouldhave	20000 = 332 + 33 + 2 + 2×33 +2×32 + 2	As anotherexample, consider n = 16647 and b = 2. The resultingexpansion is	16647 = 222 + 1 + 22 + 2 + 222 + 1 +22 + 2 + 1	The rising andfalling heights of the numbers form the number's ``skyline.''	For each pair ofintegers n and b in the input, display the completebase-b representationof n. Your displayshould use multiple output lines for different exponent heights. The displaymust begin with n = , followed by the expansion. Answersshould use an asterisk (*) as the multiplication symbol between coefficients and powers of b. Zero terms must not be printed, andunnecessary coefficients and exponents must not be shown (for example, display1 instead of b0, b2 insteadof 1*b2 and binstead of b1). To assist in accurately viewing theskyline of the number, the display must show one character (either adigit, +, or *) per column of the multi-line display; there must be no unnecessaryspaces. The correct format is illustrated in the sample output shown below.	Answers must bedisplayed using no more than 80 columns. Expansions requiring more than 80columns must be split between terms, into two or more sets of display lines toshow the remaining portion of the expansion. The second and following parts ofthe answer must begin in the same column as the first part of the answer andshould contain the same number of (possibly blank) lines. The split may onlyoccur between terms of the number itself (the bottom line), not between termsin an exponent. See the sample output for an example. Note that each set ofdisplay lines starts with a blank line.
题目输入：
	Input is a sequence of pairs of integers, n and b, followed by a pair of zeroes. Each valuefor n will bepositive, and each value for b will be greater than or equal to 2.All values will fit into 64 bits unsigned integers (the maximum is therefore18446744073709551615).
题目输出：
	For each input pair, n and b, print the complete base-b expansion of n as described above. Print a line containing	n incomplete base b:	preceding eachexpansion. Separate the output for consecutive pairs by a line of exactly 80hyphens. All coefficients, bases, and exponents are to be displayed as standardbase 10 integers.
输入样例：
20000 3
16647 2
1000 12
85026244 3
0 0

输出样例：
20000 in complete base 3:

          2
         3   3+2    3    2
20000 = 3  +3   +2*3 +2*3 +2
--------------------------------------------------------------------------------
16647 in complete base 2:

          2+1  2     2+1
         2   +2 +2  2     2
16647 = 2         +2    +2 +2+1
--------------------------------------------------------------------------------
1000 in complete base 12:

           2
1000 = 6*12 +11*12+4
--------------------------------------------------------------------------------
85026244 in complete base 3:

             2           2         2         2         2       2       2
            3 +2*3+1    3 +2*3    3 +3+2    3 +3+1    3 +2    3 +1    3
85026244 = 3        +2*3      +2*3      +2*3      +2*3    +2*3    +2*3


               2*3+2  2*3+1    3
           +2*3     +3     +2*3 +3+1

提示：
None



题目：DesignTheConstructionSite(1769)
时间限制：3000MS
空间限制：65535KB
题目描述：
	南京施工大学为了迎接校庆，要对矩形工地连夜加急施工。在这个工地上规划设计了三种模块，分别是1x1，2x1和1x2的正方形或矩形模块，设计师要用这三种模块填满整个矩形工地。由于分配正方形1x1模块在美观性上有特殊的要求，所以校领导对矩形工地中的1x1模块的数目进行了限制。因为有很多个矩形工地，设计师忙不过来了。他向你寻求帮助，对于给定的一个矩形工地和1x1模块的限制数目，设计师能够给出多少种方案呢？
题目输入：
	多Case（约400000个），以EOF结尾	每行即为一个Case，四个整数：n m c d	n x m即为矩阵工地的规模，0<n<=100,0<m<=10;	c d为该矩阵工地的1x1模块的限制，表示该工地上此1x1模块数目不小于c并且不大于d，0<=c<=d<=20
题目输出：
	每行输出对应的方案数，答案模除1000000007后输出。
输入样例：
1 1 0 0
1 1 1 2
1 2 1 2
1 2 0 2
2 2 0 0
输出样例：
0
1
1
2
2
提示：
None



题目：老队员跟新队员讲题(1118)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
fishhead，我们的教练：每次集训都要老队员跟新队员讲题；而且现在实行了另一种办法：新队员只要向fishhead预定想要听哪些题，鱼头就要去选着老对员去跟他们讲解。可是每个老对员对讲同一道题的次数有限，毕竟讲多了人也会觉得无聊的。而且每个的表达能力也不一样，把新队员讲懂所需时间也不同。现在鱼头想要在最少的时间吧所有的新队员所要求的题跟他们都讲完；现在有N个新队员( 从1到N标记 ),M个老对员( 从1到M标记 )，K道题( 从1到K标记 );
题目输入：
每个测试案例的第一行包含三个整数N, M, K (0 < N, M, K < 50), 如上文所述。

接下来的N行，每行有K个数（0或1）表示第i个新队员第j题他有没有向fishhead预定。1表示预定了，0表示未预定。（1 <= i <= N, 1 <= j <= k）;

接下来的M行，每行含K整数(每个整数x在[0，3]范围)，第i个老对员愿意讲解第j道题x次.(x=0表示这位老对员不想讲这道题)。( 1 <= i <= M, 1 <= j <= K);

然后一共有K个矩阵( 矩阵大小是N*M )，第K个矩阵里的第i行j列的数表示第j个老对员跟第i个新队员讲解第k题所需时间。

输入3个“0”终止输入，这个测试用例应该不会被处理。
题目输出：
对于每个测试用例，如果能满足所有新队员的需求，输出最少时间，否则就输出“-1”。每个测试用例对应一行输出。
输入样例：

1 3 3
1 1 1
0 1 1
1 2 2
1 0 1
1 2 3
1 1 1
2 1 1

1 1 1
1
0
20

0 0 0
输出样例：
4
-1
提示：




题目：Ilovemath(1222)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
There are multiple test cases.The first line contain a integer t( t <= 1000 ), indicate t cases.

For each case,the first line contain a integer n.

next two line contain two sequence (sequence 1 and sequence 2 )
题目输入：
10

10
10 9 8 7 6 5 4 3 2 1
1 3 5 7 9 2 4 6 8 10

10
10 8 9 6 7 5 4 3 2 1
1 3 5 7 9 2 4 6 8 10

77
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77
2 1 4 5 3 7 8 9 10 6 12 13 14 15 16 17 11 19 20 21 22 23 24 25 26 27 28 18 30 31 32 33 34 35 36 37 38 39 40 41 29 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 42 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 59

77
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77
2 1 4 5 3 7 8 9 10 6 12 13 14 15 16 17 11 19 20 21 22 23 24 25 26 27 28 18 30 31 32 33 34 35 36 37 38 39 40 41 29 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 42 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 59

77
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77
2 1 4 5 3 7 8 9 10 6 12 13 14 15 16 17 11 19 20 21 22 23 24 25 26 27 28 18 30 31 32 33 34 35 36 37 38 39 40 41 29 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 42 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 59

77
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77
2 1 4 5 3 7 8 9 10 6 12 13 14 15 16 17 11 19 20 21 22 23 24 25 26 27 28 18 30 31 32 33 34 35 36 37 38 39 40 41 29 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 42 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 59

100
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
2 1 4 5 3 7 8 9 10 6 12 13 14 15 16 17 11 19 20 21 22 23 24 25 26 27 28 18 30 31 32 33 34 35 36 37 38 39 40 41 29 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 42 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 59 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 78

100
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
2 1 4 5 3 7 8 9 10 6 12 13 14 15 16 17 11 19 20 21 22 23 24 25 26 27 28 18 30 31 32 33 34 35 36 37 38 39 40 41 29 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 42 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 59 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 78

100
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
2 1 4 5 3 7 8 9 10 6 12 13 14 15 16 17 11 19 20 21 22 23 24 25 26 27 28 18 30 31 32 33 34 35 36 37 38 39 40 41 29 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 42 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 59 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 78

100
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
2 1 4 5 3 7 8 9 10 6 12 13 14 15 16 17 11 19 20 21 22 23 24 25 26 27 28 18 30 31 32 33 34 35 36 37 38 39 40 41 29 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 42 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 59 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 78

题目输出：

For each case ,please print the answer mod 100007.
输入样例：
1
5
2 1 3 4 5
1 3 2 4 5
输出样例：
2
提示：
(
1: 2 3 1 4 5 
2: 2 1 3 4 5
)




题目：MakingFriends(1017)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
The national college entrance examination has ended and a new semester is coming. Thousands of new students are coming into NJUST to have their university life. As you know, some of them are from the same place so that they know each other before they reach NJUST while some others are still lonely. As a senior student, you should help them to adjust themselves to university life. The most important is to make friends with other freshmen.
So you need to make a survey to find out the maximum set satisfying the condition: there are no two students in the set know each other. This will help you to decide how you do the job later.
题目输入：
The input contains several data sets.
Each data set represents one set of subjects of the study, with the following description:
The first line contains the number of students (N).
Then following N lines, each contains the information of each student, in the following format 
The number of students he/she knows (M): student_id1  student_id2  student_id3 ...student_idM 
(If somebody knows no one else, then M will be 0.)
NOTICE: The student_id is an integer number between 0 and n-1 (n <=500).
题目输出：
For each given data set, the program should output a line containing the result.
输入样例：
7
3: 4 5 6
2: 4 6
0:
0:
2: 0 1
1: 0
2: 0 1
3
2: 1 2
1: 0
1: 0
输出样例：
5
2
提示：




题目：Findme!Findme!!(1665)
时间限制：1000MS
空间限制：65535K
题目描述：
	Neville is a bumbling, plump student in Hogwarts. He always forgets something or makes such a mess.	To avoid such things to happen, Neville decided to take a note to remember something imortant.	However, his old habits are hard to change, his notes are also a mess.	So helpful as you, please help him to clear up those notes.
题目输入：
	There are several cases. Each case has an integer n (0<=n<=10^5) in a distinct line, indicate the number of Neville's notes.	Then followed by n lines, each line includes a time in 24hour system and a string indicating the thing Neville should remember(all the characters are	lowercase letters and the length is no more than 35). Suppose the thing are happen in a day.	The input file ends with EOF.
题目输出：
	For each case, print the notes ordered by time. If there are several notes in the same time, print them in string's lexicographical order.	If the time is out of 00:00~23:59, print "Neville is so careless!".
输入样例：
5
21:18 andfive is a smart and naughty boy
17:00 play with the smartest acmer
17:00 eat delicious food
00:01 sleep
08:00 go to fishhead class
输出样例：
00:01 sleep
08:00 go to fishhead class
17:00 eat delicious food
17:00 play with the smartest acmer
21:18 andfive is a smart and naughty boy
提示：
None



题目：DeliDeli(1364)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Mrs. Deli is running the delicatessen store "Deli Deli". Last year Mrs. Deli has decided to expand her business and build up an online store. She has hired a programmer who has implemented the online store. 
Recently some of her new online customers complained about the electronic bills. The programmer had forgotten to use the plural form in case that an item is purchased multiple times. Unfortunaly the programmer of Mrs. Deli is on holiday and now it is your task to implement this feature for Mrs. Deli. Here is a description how to make the plural form: 

If the word is in the list of irregular words replace it with the given plural. 
Else if the word ends in a consonant followed by "y", replace "y" with "ies". 
Else if the word ends in "o", "s", "ch", "sh" or "x", append "es" to the word. 
Else append "s" to the word.
题目输入：
The first line of the input file consists of two integers L and N (0 ≤ L ≤ 20, 1 ≤ N ≤ 100). The following L lines contain the description of the irregular words and their plural form. Each line consists of two words separated by a space character, where the first word is the singular, the second word the plural form of some irregular word. After the list of irregular words, the following N lines contain one word each, which you have to make plural. You may assume that each word consists of at most 20 lowercase letters from the english alphabet ('a' to 'z').
题目输出：
Print N lines of output, where the ith line is the plural form of the ith input word.
输入样例：
3 7
rice rice
spaghetti spaghetti
octopus octopi
rice
lobster
spaghetti
strawberry
octopus
peach
turkey

输出样例：
rice
lobsters
spaghetti
strawberries
octopi
peaches
turkeys

提示：




题目：RunaroundNumbers(1465)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Runaround numbers are integers with unique digits, none of which is zero (e.g., 81362) that also have an interesting property, exemplified by this demonstration: If you start at the left digit (8 in our number) and count that number of digits to the right (wrapping back to the first digit when no digits on the right are available), you'll end up at a new digit (a number which does not end up at a new digit is not a Runaround Number). Consider: 8 1 3 6 2 which cycles through eight digits: 1 3 6 2 8 1 3 6 so the next digit is 6. Repeat this cycle (this time for the six counts designed by the `6') and you should end on a new digit: 2 8 1 3 6 2, namely 2. Repeat again (two digits this time): 8 1 Continue again (one digit this time): 3 One more time: 6 2 8 and you have ended up back where you started, after touching each digit once. If you don't end up back where you started after touching each digit once, your number is not a Runaround number. Given a number M (that has anywhere from 1 through 9 digits), find and print the next runaround number higher than M, which will always fit into an unsigned long integer for the given test data.
题目输入：
There are several test cases, end by EOF, for each test case:A single line with a single integer, M
题目输出：
A single line containing the next runaround number higher than the input value, M.
输入样例：
81361
输出样例：
81362
提示：




题目：BeeBreeding(1565)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	Professor B. Heif is conducting experiments with a species of SouthAmerican bees that he found during an expedition to the Brazilian rain forest.The honey produced by these bees is of superior quality compared to the honeyfrom European and North American honey bees. Unfortunately, the bees do notbreed well in captivity. Professor Heif thinks the reason is that the placementof the different maggots (for workers, queens, etc.) within the honeycombdepends on environmental conditions, which are different in his laboratory andthe rain forest. 	As a first step to validate his theory, Professor Heif wants to quantify thedifference in maggot placement. For this he measures the distance between thecells of the comb into which the maggots are placed. To this end, the professorhas labeled the cells by marking an arbitrary cell as number 1, and thenlabeling the remaining cells in a clockwise fashion, as shown in the followingfigure. 					For example, two maggots in cells 19 and 30 are 5 cells apart. One of theshortest paths connecting the two cells is via the cells 19 - 7 - 6 - 5 - 15 -30, so you must move five times to adjacent cells to get from 19 to 30. 				Professor Heif needs your help to write a program that computes the distance,defined as the number of cells in a shortest path, between any pair of cells. 	
题目输入：
	The input consists of several lines, each containing twointegers a and b ( a, b<=10000), 			denoting numbers of cells. The integers are alwayspositive, except in the last line where a = b = 0 holds. Thislast line terminates the input and should not be processed. 	
题目输出：
	For each pair of numbers (a, b) in theinput file, output the distance between the cells labeled a and b.The distance is the minimum number of moves to get from a to b. 
输入样例：
19 30
0 0

输出样例：
The distance between cells 19 and 30 is 5.
提示：
None



题目：小游戏(1119)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
来做一个小游戏。首先，你顺时针写下 1,2,3 ,..., 2n-1,2n这n个数字把它们围成一圈，然后用直线两两连接。每个数字一定完全地彼此被连接。并且，没有两条直线相交。是一场简单的游戏，不是吗？但是在你已经写下这 2 n 数字，你能告诉我有多少不同的方法你连接数字吗？生活比较难，对不对？
题目输入：
每一行除了最后一行是一个非负整数n，最后一行是-1，表示输入结束，n的范围为0到100。
题目输出：
对于输入的每一个n，输出连接方法的数目。
输入样例：
2
3
-1
输出样例：
2
5

提示：




题目：Fishhead'sWish(1770)
时间限制：1000MS
空间限制：65535KB
题目描述：
	Nobody could have failed to notice that the 60th anniversary of NJUST is approaching, especially personnel of ACM team. So, they were intended to hold an activity to celebrate it. However, they had no idea about the detail. One day, Xiangzi was surprised to find that Fishhead was praying for his ideal weight. At that moment, an idea appeared in his mind.	The activity is planned to guess Fishhead’s ideal weight X(1≤ X≤ N),and everyone has no more than n chances. When you guess Y, the host will tell you X>Y or X<y or X=Y. If X=Y, you win. Otherwise, you need to continue. Using the best inquiry method, calculate at least how many times you need to guess right in the worst condition. Is it simple? Of course yes. So, there are two new restrictions. First, you won’t get the host’s answer until you put forward the next guess. That’s to say, the answer will be postponed. Second, if you get the answer “X>Y” more than m times, you will fail. Now, can you calculate it?
题目输入：
	The input contains one or more test cases. Each test case contains only three integers N(1 ≤ N≤10^18),n(1≤n≤1000),m(1≤m≤1000).
题目输出：
	Supposing the least times of guessing right in the worst condition is k, if k<=n , output k. Else, output “Fail”(without the quotation mark).
输入样例：
100 15 10
2 2 2
输出样例：
12
Fail
提示：
None



题目：生日礼物的意外(1223)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
我们的大队长xiaoyoulei同学，在过生日的时候收到了rayafjyblue送他的手链，这个手链是什么样子的呢，它有n个珠子，这n个珠子颜色都是不一样的，但是不小心被bobo弄散了，xiaoyoulei很生气，结果把波波揍了一顿，并且从此以后就很低落，bobo看见他那么低落，心里很难过，于是bobo准备自己买n个无色的珠子，并且买了n中染料，准备图成原来的样子，送给xiaoyoulei，但是悲剧的是，他不知道原来的手链是什么颜色。由于他的人品比较尴尬，所以他想知道，到底有多少不同的方案。我们认为经过旋转以后变成一样的是同一种，由于bobo眼神很好，所以他可以保证他每次不会接成一样的方案，现在他很头疼，所以他来问我，但是由于我要出题，所以我就问你们了
题目输入：
第一行有一个整数M，表示测试数据的个数
以下M行:一个整数n，表示有多少个珠子，n<=1000000;一个整数p,表示模除的整数，p=30000
题目输出：
输出一个整数，表示最多尝试的次数，由于数字会很大，所以最后的值模除一个30000
输入样例：
4
1 30000
2 30000
3 30000
4 30000

输出样例：
1
3
11
70

提示：
请使用long long,不要使用__int64



题目：最小公倍数(1666)
时间限制：1000MS
空间限制：65535K
题目描述：
	计算1,2,3,......,n(n<=10000)的最小公倍数模除99999989的值m
题目输入：
	一个整数n,以EOF结束
题目输出：
m
输入样例：
1
2
3
10
输出样例：
1
2
6
2520
提示：
None



题目：套汇(1018)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
套汇是指利用货币兑率的差异，把一个单位的某种货币转换为大于一个单位的同种货币的方法。
输入
输入有多组测试数据，每组测试数据的第一行为整数n(1<=n<=100),m，代表货币的种数和兑换的汇率，接着下面的m行为汇率，
每个汇率i,j,k代表1个单位的i货币可兑换k单位的j货币.
最后第一行代表起始所拥有的货币种类.
题目输入：
输入以n为0结束
题目输出：
如果经过若干步兑换操作（最终还必须兑换成起始时的货币类型），可以获得利润的话输出YES，否则输出NO.
输入样例：
8 14
1 2 0.6
2 1 0.6
1 5 1.5
5 1 0.6
6 1 0.7
1 6 0.8
3 1 1.1
1 3 0.9
4 7 0.86
7 4 0.86
4 8 1.5
8 4 0.6
7 8 0.96
8 7 0.96
1
0
输出样例：
NO
提示：




题目：Expressions(1365)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Arithmetic expressions are usually written with the operators in between the two operands (which is called infix notation). For example, (x+y)*(z-w) is an arithmetic expression in infix notation. However, it is easier to write a program to evaluate an expression if the expression is written in postfix notation (also known as reverse polish notation). In postfix notation, an operator is written behind its two operands, which may be expressions themselves. For example, x y + z w - * is a postfix notation of the arithmetic expression given above. Note that in this case parentheses are not required. 
To evaluate an expression written in postfix notation, an algorithm operating on a stack can be used. A stack is a data structure which supports two operations: 

push: a number is inserted at the top of the stack. 
pop: the number from the top of the stack is taken out. 
During the evaluation, we process the expression from left to right. If we encounter a number, we push it onto the stack. If we encounter an operator, we pop the first two numbers from the stack, apply the operator on them, and push the result back onto the stack. More specifically, the following pseudocode shows how to handle the case when we encounter an operator O: a := pop();
b := pop();
push(b O a);
The result of the expression will be left as the only number on the stack. 
Now imagine that we use a queue instead of the stack. A queue also has a push and pop operation, but their meaning is different: 

push: a number is inserted at the end of the queue. 
pop: the number from the front of the queue is taken out of the queue. 
Can you rewrite the given expression such that the result of the algorithm using the queue is the same as the result of the original expression evaluated using the algorithm with the stack?
题目输入：
The first line of the input contains a number T (T ≤ 200). The following T lines each contain one expression in postfix notation. Arithmetic operators are represented by uppercase letters, numbers are represented by lowercase letters. You may assume that the length of each expression is less than 10000 characters.
题目输出：
For each given expression, print the expression with the equivalent result when using the algorithm with the queue instead of the stack. To make the solution unique, you are not allowed to assume that the operators are associative or commutative.
输入样例：
2
xyPzwIM
abcABdefgCDEF

输出样例：
wzyxIPM
gfCecbDdAaEBF
提示：




题目：PartyLamps(1466)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
To brighten up the gala dinner of the IOI'98 we have a set of N (10 <= N <= 100) colored lamps numbered from 1 to N. The lamps are connected to four buttons:Button 1: When this button is pressed, all the lamps change their state: those that are ON are turned OFF and those that are OFF are turned ON. Button 2: Changes the state of all the odd numbered lamps. Button 3: Changes the state of all the even numbered lamps. Button 4: Changes the state of the lamps whose number is of the form 3xK+1 (with K>=0), i.e., 1,4,7,... A counter C records the total number of button presses. When the party starts, all the lamps are ON and the counter C is set to zero. You are given the value of counter C (0 <= C <= 10000) and the final state of some of the lamps after some operations have been executed. Write a program to determine all the possible final configurations of the N lamps that are consistent with the given information, without repetitions.
题目输入：
There are several test cases, end by EOF, for each test case:No lamp will be listed twice in the input. Line 1:  N  Line 2:  Final value of C  Line 3:  Some lamp numbers ON in the final configuration, separated by one space and terminated by the integer -1.  Line 4:  Some lamp numbers OFF in the final configuration, separated by one space and terminated by the integer -1.  No lamp will be listed twice in the input.
题目输出：
Lines with all the possible final configurations (without repetitions) of all the lamps. Each line has N characters, where the first character represents the state of lamp 1 and the last character represents the state of lamp N. A 0 (zero) stands for a lamp that is OFF, and a 1 (one) stands for a lamp that is ON. The lines must be ordered from least to largest (as binary numbers). If there are no possible configurations, output a single line with the single word `IMPOSSIBLE'
输入样例：
10
1
-1
7 -1

In this case, there are 10 lamps and only one button has been pressed. Lamp 7 is OFF in the final configuration.
输出样例：
0000000000
0101010101
0110110110

In this case, there are three possible final configurations: 
All lamps are OFF 
Lamps 1, 4, 7, 10 are OFF and lamps 2, 3, 5, 6, 8, 9 are ON. 
Lamps 1, 3, 5, 7, 9 are OFF and lamps 2, 4, 6, 8, 10 are ON.
提示：




题目：ADiceyProblem(1566)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	The three-by-three array inFigure 1 is a maze. A standard six-sided die is needed to traverse the maze(the layout of a standard six--sided die is shown in Figure 2). Each maze hasan initial position and an initial die configuration. In Figure 1, the startingposition is row 1, column 2--the ``2'' in the top row of the maze--and theinitial die configuration has the ``5'' on top of the die and the ``1'' facingthe player (assume the player is viewing the maze from the bottom edge of thefigure). 					To move through the maze you must tip the die over on anedge to land on an adjacent square, effecting horizontal or vertical movementfrom one square to another. However, you can only move onto a square thatcontains the same number as the number displayed on the top of the die beforethe move, or onto a ``wild'' square which contains a star. Movement onto a wildsquare is always allowed regardless of the number currently displayed on thetop of the die. The goal of the maze is to move the die off the starting squareand to then find a way back to that same square. 				For example, at the beginning of the maze there are two possible moves. Sincethe 5 is on top of the die, it is possible to move down one square, and sincethe square to the left of the starting position is wild it is also possible tomove left. If the first move chosen is to move down, this brings the 6 to thetop of the die and moves are now possible both to the right and down. If thefirst move chosen is instead to the left, this brings the 3 to the top of thedie and no further moves are possible. 				If we consider maze locations as ordered pairs of row and column numbers ( row, column) with row indexes starting at 1 for the top row and increasingtoward the bottom, and column indexes starting at 1 for the left column andincreasing to the right, the solution to this simple example maze can bespecified as: (1,2), (2,2), (2,3), (3,3), (3,2), (3,1), (2,1), (1,1), (1,2). Abit more challenging example maze is shown in Figure 3. 				The goal of this problem is to write a program to solve dice mazes. The inputfile will contain several mazes for which the program should search forsolutions. Each maze will have either a unique solution or no solution at all.That is, each maze in the input may or may not have a solution. For each inputmaze, either a solution or a message indicating no solution is possible will besent to the output. 					
题目输入：
	The input file begins with a line containing a stringof no more than 20 non-blank characters that names the first maze. The nextline contains six integers delimited by single spaces. These integers are, inorder, the number of rows in the maze (an integer from 1 to 10, call this value R), the number of columns in the maze (an integer from 1 to 10, call thisvalue C), the starting row, the starting column, the number that shouldbe on top of the die at the starting position, and finally the number thatshould be facing you on the die at the starting position. The next R lines contain C integers each, again delimited by single spaces. This R×C array of integers defines the maze. A value of zero indicates an empty locationin the maze (such as the two empty squares in the center column of the maze inFigure 3), and a value of `-1' indicates a wild square. This input sequence isrepeated for each maze in the input. An input line containing only the word `END'(without the quotes) as the name of the maze marks the end of the input. 
题目输出：
	The output should contain the name of each mazefollowed by its solution or the string `No Solution Possible' (without thequotes). All lines in the output file except for the maze names should beindented exactly two spaces. Maze names should start in the leftmost column.Solutions should be output as a comma-delimited sequence of the consecutivepositions traversed in the solution, starting and ending with the same square(the starting square as specified in the input). Positions should be specifiedas ordered pairs enclosed in parentheses. The solution should list 9 positionsper line (with the exception of the last line of the solution for which theremay not be a full 9 positions to list), and no spaces should be present withinor between positions. 
输入样例：
DICEMAZE1
3 3 1 2 5 1
-1 2 4
5 5 6
6 -1 -1
DICEMAZE2
4 7 2 6 3 6
6 4 6 0 2 6 4
1 2 -1 5 3 6 1
5 3 4 5 6 4 2
4 1 2 0 3 -1 6
DICEMAZE3
3 3 1 1 2 4
2 2 3
4 5 6
-1 -1 -1
END

输出样例：
DICEMAZE1
  (1,2),(2,2),(2,3),(3,3),(3,2),(3,1),(2,1),(1,1),(1,2)
DICEMAZE2
  (2,6),(2,5),(2,4),(2,3),(2,2),(3,2),(4,2),(4,1),(3,1),
  (2,1),(2,2),(2,3),(2,4),(2,5),(1,5),(1,6),(1,7),(2,7),
  (3,7),(4,7),(4,6),(3,6),(2,6)
DICEMAZE3
  No Solution Possible

提示：
None



题目：仙剑奇侠传—四(1120)
时间限制：1000 ms
空间限制：65535 ms
题目描述：

最近华哥玩仙四的时候老是碰到一个头疼的问题。请看上图的右上角的进度条，每个人的头像如果走到进度条的最右边，那么他就可以出手（每个人的头像行进速度是不同的）。华哥头疼的是：游戏中往往需要加血，由于他不知道谁先出手，就难以确定应该让谁来做这个加血工作。（一般如果柳梦璃能在怪前面出手，那么就让她加血，因为她攻击效果没有其他人好。但是，万一判断错误，结果怪在柳梦璃前面出手了，很有可能是会死人的，就不划算了）就如图中，如果韩菱纱能在玄宵和夙瑶前面出手的话，那么云天河和慕容紫英就可以出手打人，然后让韩菱纱来做加血工作，但是如果韩菱纱在玄宵后面出手，那么必须要让云天河或慕容紫英来加血(其实本图中不需要加血，我们设想一个需要加血的情况)。
     现在请你帮华哥写一个程序来判断一下进度条中[a,b]区间内最先出手的是谁.
 
题目输入：
一个整数N，表示进度条的总长1 <= N <= 100000.将进度条分为N份，依次标号1~N，每份上有一个人物(如果把每份看成一条线段，人物在线段的左端点,人物到达进度条的右端点才能出手)。输入第二行包括N个整数，Ni表示第i个人的速度. 第三行一个M，表示下面操作的总数0 <= M <= 100000。有2种操作：X  A  V：给A位置的人用仙风云体加速，速度增加V.   Q  A  B:询问区间[A,B]上最先出手的人的编号.
题目输出：
对于每次询问，输出最先出手的人的标号（如果有人同时出手，输出编号较小的）.
输入样例：
5
1  2   3   4   5
2
X   2  20
Q   1  5

输出样例：
2

提示：




题目：MaxDouzi(1771)
时间限制：2000MS
空间限制：65535KB
题目描述：
	这道题目太简单啦！！	平面上面撒了很多豆子（我们把它们看成一个一个点）。小明画了一个圈，恰好把豆子都圈住了！而且他发现，这是半径最小的圈了，没有更小的圈能够圈住所有的豆子。额，小明找到了这个圈的圆心，站在圆心上面之后，天突然黑了！他拿出了随身携带的发散式手电筒，也就是照出去之后正好是圈子中的一个扇形形状。手电筒的光照出去的角度为a度。他旋转着手电筒，想知道怎样能够照到最多的豆子。只要照到擦到一点边都算数~请快快告诉他吧！
题目输入：
	多Case，以EOF结尾	第一行，整数n，有n个豆子被撒下来了。（0<n<=10000）	接下来n行，每行形式：x y，表示豆子的坐标。	接下来一行一个整数m，有m个询问，（0<m<=100）	接下来的m行，每行的每个询问都是一个整数角度值a度（0<a<180）
题目输出：
	对于每个特定的角度输出能够照到的最多的豆子的数目。每行一个答案。
输入样例：
4
-1 0
0 1
1 0
0 -1
3
60
90
100
输出样例：
1
2
2
提示：
None



题目：签到题(1224)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
集训开始很久了，鱼头想要给大一的小孩子们来一场比赛，这次的出题主要由watermelon队负责，但是这个队里的三个人都比较懒惰，每个人出完题以后都不想自己出测试数据，他们打赌，每个人说1000000个数字，规则是：谁说的1000000个数字的最大公约数最小就是谁赢。悲剧的是我最后一个说，结果在我之前他们一个说的序列最大公约数是3，一个是2，所以只有我说的结果1，才能获胜。由于我的数学不好，所以想让你帮忙
题目输入：
不告诉你
题目输出：
1000000个数字，他们的最大公约数是1，要求升序输出，且最小的数字要大于100,最大的数字小于2^60,,每个输出之间有一个空格
输入样例：
不告诉你
输出样例：
更不能告诉你
提示：
题目要求的最大公约数，是指1000000个数共同的公约数，不是指两两的公约数



题目：Glassbeads(1019)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
Rose has a shop which sell beads,one day ,there comes several children,they want to buy some glass beads,Rose has some boxes to place the glass beads.Rose think all the children are lovely .so she want to know their name and make friends with them so she thinks a strategy to sell the glass beads : there are M children and N boxes, 
every child should choose a paper before choosing some glass beads from some boxes, there is a string on the paper ，and  the number of the boxes he can choose from is the number of  vowel letters of the string(every string has vowel letters) ,and the location of the vowel letters decide which boxes he can choose (for example “all”there is a vowel letter in 1-th location ,so he can choose from the first boxes ),the location of the first letter of the string is 1,if the location is more than the number of the boxes N,then should mod N(if equal to 0 then choose from the N-th box ). After a child chooses beads and before another child chooses Rose can change the beads between boxes ,Rose want to know the most number of glass beads she can sold in this condition .So she want you to write a program to solve this problem.
题目输入：
The first line of input contains two integers M and N, 1 <= M <= 500, 1 <= N <= 100, number of boxes and number of children. Beads boxes are numbered from 1 to M and children are numbered from 1 to N.
The next line contains M integeres, for each boxes initial number of beads. The number of beads in each boxes is greater or equal to 0 and less or equal to 500.
The next N lines contains records about the children in the following form ( record about the i-th children is written in the (i+2)-th line): 
sting Q is the name of the children and that he wants to buy P beads at most. Numbers P can be equal to 0.
题目输出：
The only line of the output should contain the maximum number of sold beads.

输入样例：
2 2
3 6
ewro 3
eshdv 5
4 5
3 4 6 5
initial 3
number 6
house 5
mark 5
next 4
输出样例：
8
13
提示：




题目：逆序数(1667)
时间限制：1000MS
空间限制：65535K
题目描述：
	Give you N(0<N<=1000) groups of strings.Each group has 2 strings.Now you are required to sort these groups by the first string ascending order. If first strings are the same, then you should sort them by  the second string descending order.The right order of strings is alphabetical.The length of one string will not be exceed 50.	To make it harder, I want you compute the Inverse number(Do not know it? Find it in Hint).
题目输入：
		The Input consists of mulitiple cases.	In each case, the first line contains an integer N(0<N<=1000).	Then follows N lines. Each line contains two string. The strings consists of only English letters(case-sensitive).	
题目输出：
	output the inverse number a line for each cases.
输入样例：
3
abc cba
cba abc
abc aac
5
abcd aaaa
acbdef aaaa
Abcdek ccccc
aBde ccccc
acbdef AAA
输出样例：
1
4
提示：
Hint
    Inverse number:在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。也就说，对于n个不同的元素，先规定各元素之间有一个标准次序（例如n个 不同的自然数，可规定从小到大为标准次序），于是在这n个元素的任一排列中，当某两个元素的先后次序与标准次序不同时，就说有1个逆序。一个排列中所有逆序总数叫做这个排列的逆序数。



题目：CowPedigrees(1467)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer John is considering purchasing a new herd of cows. In this new herd, each mother cow gives birth to two children. The relationships among the cows can easily be represented by one or more binary trees with a total of N (3 <= N < 200) nodes. The trees have these properties: The degree of each node is 0 or 2. The degree is the count of the node's immediate children. The height of the tree is equal to K (1 < K <100). The height is the number of nodes on the longest path from the root to any leaf; a leaf is a node with no children. How many different possible pedigree structures are there? A pedigree is different if its tree structure differs from that of another pedigree. Output the remainder when the total number of different possible pedigrees is divided by 9901.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1: Two space-separated integers, N and K.
题目输出：
Line 1: One single integer number representing the number of possible pedigrees MODULO 9901.
输入样例：
5 3
输出样例：
2
提示：
Two possible pedigrees have 5 nodes and height equal to 3:            @                   @                /                  /          @   @      and      @   @        /                      /        @   @                   @   @



题目：TheFortifiedForest(1567)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	Once upon a time, in a faraway land, there lived a king. This king owned a small collection of rare and valuable trees, which had been gathered by his ancestors on their travels. To protect his trees from thieves, the king ordered that a high fence be built around them. His wizard was put in charge of the operation.		Alas, the wizard quickly noticed that the only suitable material available to build the fence was the wood from the trees themselves. In other words, it was necessary to cut down some trees in order to build a fence around the remaining trees. Of course, to prevent his head from being chopped off, the wizard wanted to minimize the value of the trees that had to be cut. The wizard went to his tower and stayed there until he had found the best possible solution to the problem. The fence was then built and everyone lived happily ever after.		You are to write a program that solves the problem the wizard faced.
题目输入：
The input contains several test cases, each of which describes a hypothetical forest. Each test case begins with a line containing a single integer n, 2n15, the number of trees in the forest. The trees are identified by consecutive integers 1 to n. Each of the subsequent lines contains 4 integers xi, yi, vi, li that describe a single tree. (xi, yi) is the position of the tree in the plane, vi is its value, and li is the length of fence that can be built using the wood of the tree. vi and li are between 0 and 10,000.	The input ends with an empty test case (n = 0).
题目输出：
For each test case, compute a subset of the trees such that, using the wood from that subset, the remaining trees can be enclosed in a single fence. Find the subset with a minimum value. If more than one such minimum-value subset exists, choose one with the smallest number of trees. For simplicity, regard the trees as having zero diameter.	Display, as shown below, the test case numbers (1, 2, ...), the identity of each tree to be cut, and the length of the excess fencing (accurate to two fractional digits).	Display a blank line between test cases.
输入样例：
6
 0  0  8  3
 1  4  3  2
 2  1  7  1
 4  1  2  3
 3  5  4  6
 2  3  9  8
3
 3  0 10  2
 5  5 20 25
 7 -3 30 32
0
输出样例：
Forest 1
Cut these trees: 2 4 5
Extra wood: 3.16

Forest 2
Cut these trees: 2
Extra wood: 15.00
提示：
None



题目：Frequentvalues(1366)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
You are given a sequence of n integers a1 , a2 , ... , an in non-decreasing order. In addition to that, you are given several queries consisting of indices i and j (1 ≤ i ≤ j ≤ n). For each query, determine the most frequent value among the integers ai , ... , aj.
题目输入：
The input consists of several test cases. Each test case starts with a line containing two integers n and q (1 ≤ n, q ≤ 100000). The next line contains n integers a1 , ... , an (-100000 ≤ ai ≤ 100000, for each i ∈ {1, ..., n}) separated by spaces. You can assume that for each i ∈ {1, ..., n-1}: ai ≤ ai+1. The following q lines contain one query each, consisting of two integers i and j (1 ≤ i ≤ j ≤ n), which indicate the boundary indices for the query. 

The last test case is followed by a line containing a single 0.

题目输出：
For each query, print one line with one integer: The number of occurrences of the most frequent value within the given range.
输入样例：
10 3
-1 -1 1 1 1 1 3 10 10 10
2 3
1 10
5 10
0

输出样例：
1
4
3

提示：
A naive algorithm may not run in time!



题目：weareateam(1772)
时间限制：2000MS
空间限制：65535KB
题目描述：
	我们是一个团队！我们不是一个团队！	总共有n个人在机房，每个整数代表一个人，标号为1~n，他们分成了两个团队；	你会收到m条消息，消息是这样构成的：	a b c	整数a、b分别代表了两个人，整型变量	c==0代表a和b是一个团队的，	c==1代表a和b 不是一个团队的，	当c==0或者c==1的时候你有可能得到与之前消息得到的结果相矛盾的消息，此时聪明的你会忽略这个消息，并输出一行“da pian zi”；	c==2代表查询a和b的关系，如果a和b是一个团队,输出一行“we are a team”，如果不是输出一行“we are not a team”，如果不确定，输出一行“not sure yet”；
题目输入：
	多case，以EOF结尾	n ( 约为100000 )	m ( 约为 100000 )	m条消息，每条一行	格式：a b c
题目输出：
	见上文描述
输入样例：
4
6
1 2 0
1 2 2
1 2 1
1 3 1
2 3 2
1 4 2
输出样例：
we are a team
da pian zi
we are not a team
not sure yet
提示：
None



题目：仙剑奇侠传4(1121)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
最近master正在热火朝天地玩仙四，话说这个游戏剧情生动，引人入胜。这深深地吸引了对面的阿才，阿才对仙四也颇有研究，他发现，仙四里面的很多任务的挑战相当有规律，每一次任务结束会获得很多经验，出于游戏的趣味性，每次的任务所得到的经验值呈现单调递增的状态，比如第一次获得经验值是s，那么第二次获得的经验值就是s+1，假设游戏的初始经验值为s。由于鱼头的严密盯防，他们两人只能使用一台机器游戏，于是上午由阿才游戏，下午由master继续，上午阿才一共玩了n-1个任务，然而由于master不喜欢紧跟着阿才继续游戏，所以master跳过一个任务后继续游戏（即master从第n+1个任务开始），一天下来，master发现最后一次完成的任务经验值是m。这样的话问题就来了，如果一个人玩所得到的经验比另一个人玩的经验多的话，就会出现不公平的情况，这让双方很头疼。恰好有一天master游戏结束后双方发现各自的累积经验值刚好相等，而阿才玩的第一个任务获得的经验是1，相邻的两个经验值之间递增1。千年之后master回忆起这件事仍然感到幸运，然而千年之后的master记忆力有点下降，他忘记了当初最终经验值m的准确值，只记得当时的最后一次经验值m肯定小于某个数max。聪明的程序员，希望你能够帮助他求出当初master到底最后一次得到的经验值m最大可能是多少，当然也给出相应的阿才最后一次得到的经验值n-1是多少。
题目输入：
第一行输入测试用例tc；
接下来的tc行分别表示tc个测试用例max（每行有一个数max（2进制64位））；
题目输出：
对于每一个输入数据，输出一行，依次输出m和n-1，m和n-1之间用一个空格隔开；
输入样例：
2
10
200

输出样例：
8 5
49 34

提示：




题目：活动室的钟(1225)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
南京理工大学计算机学院基础教学部，俗称"ACM队活动室"，是一个有趣的地方。活动室的老大——鱼头哥，是数字逻辑电路的专家，于是，在他的要求下，总管zlly从四号门外的小摊上买来一个二进制钟。
每个二进制钟有三个显示屏，分别代表时、分、秒，每个显示屏里显示六个二进制数字，0或者1。调皮的zhouyuzhe童鞋经常调整时钟的摆放方式，一会儿垂直放置，一会儿水平放置（如图)

 
10:37:49 垂直显示时为 011001100010100011 水平的时候又变成了001010100101110001.很多童鞋都被这个奇怪的钟迷糊了。
作为一个NEW ACMER，赶快来挑战一下，看看你能不能正确分辨这个二进制时钟。
题目输入：
第一行包含一个整数N(1 <= N <= 86400)，代表测试数据的个数，接下来有N行，每行包含一个六十进制表示的时间。
题目输出：
对于每行测试数据，先输是第几组测试数据（从1开始），接着是一个空格，然后输出垂直显示的时间和水平显示的时间，每个包含18个二进制数字，用空格分隔。
输入样例：
2
10:37:49
00:00:01
输出样例：
1 011001100010100011 001010100101110001
2 000000000000000001 000000000000000001
提示：




题目：Fishhead’sRequest(1020)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
It is well known that it is not easy to select courses in the college, because there is usually conflict among the time of the courses and students are always willing to choose the best teacher. At the beginning of each term, students who are keen on studying always want to select courses as more as possible. Of course there should be no conflict among the courses their selects. 
There are 5 classes every day, and 7 days every week (there are also quite a lot of courses on weekends). There are hundreds of courses in the college, and teaching a course needs one class each week. To give students more convenience, though teaching a course needs only one class, a course will be taught several times by different teachers in a week. For example, a course may be taught both at the 3-rd class on Tuesday by Majors and 4-th class on Wednesday by Andy, you should assume that there is no difference between the two classes (though taught by different teachers), and that students can select any teachers teaching the same class to go. Some students consider that selecting courses is not an easy job for them. 
What’s more; our ACM team’s coach Fishhead wants to increase a new elective course taught by him after everyone has already choose their required courses. Avoiding too few students on that course, he request ACMers to change their schedules so that they can take that course. Oh, my God, all ACMers have to obey his request and choose all their courses again. However, some of them cannot take that elective course no matter how to change their schedules, for they have to take the certain required courses. Coach Fishhead is sling, he wants to make sure that all ACMers who don’t take the course have conflict between their required courses and his elective course, or he will kick the guy out of ACM team. Wow, what a tough question. Since Fishhead doesn’t want his brain cells killed, he asks you, the cleverest guy in the ACM team to solve the problem for him. For reciprocation, if you solve the problem nicely, Fishhead promises you to be the captain of the team. Aren’t you excited?  
题目输入：
The input contains several cases. For each case, the first line contains an integer n (1 <= n <= 100), the number of required courses taught by different teachers in the college. The following n lines represent n different courses. In each line, the first string is the name of teacher; the second string is the name of course which the teacher taught. We may assume that the teachers’ names are all different. All the teachers’ and courses’ names are less than 15 chars and there are no spaces in the strings. Then comes a pair of integers p (1 <= p <= 7) and q (1 <= q <= 5), which means that the course will be taught at the q-th class on the p-th day of a week. After that, a new line will be inputted, with a pair of integers px (1 <= px <= 7) and qx (1 <= qx <= 5), which means that the Fishhead’s course will be taught at the qx-th class on the px-th day of a week.
题目输出：
For each test case, if the courses have conflict before Fishhead’s course adding them, output “Impossible”. If the courses don’t have conflict before Fishhead’s course adding them, but have conflict after the course adding, output “Conflict”. If the courses have conflict after Fishhead’s course adding them, output “Prefect”.
输入样例：
6
Andy Math 1 1
Majors English 1 1
Tracy English 2 2
Lucifer Chinese 2 2
Sophie Computer 3 3
Henry Computer 3 2
3 3
1
Andy Math 1 1
1 1
2
Andy Math 1 1
Tracy English 2 2
2 3
输出样例：
Impossible
Conflict
Prefect

提示：




题目：ZeroSum(1468)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Consider the sequence of digits from 1 through N (where N=9) in increasing order: 1 2 3 ... N. Now insert either a `+' for addition or a `-' for subtraction or a ` ' [blank] to run the digits together between each pair of digits (not in front of the first digit). Calculate the result that of the expression and see if you get zero. Write a program that will find all sequences of length N that produce a zero sum.
题目输入：
There are several test cases, end by EOF, for each test case:A single line with the integer N (3 <= N <= 9).
题目输出：
In ASCII order, show each sequence that can create 0 sum with a `+', `-', or ` ' between each pair of numbers.
输入样例：
7
输出样例：
1+2-3+4-5-6+7
1+2-3-4+5+6-7
1-2 3+4+5+6+7
1-2 3-4 5+6 7
1-2+3+4-5+6-7
1-2-3-4-5+6+7
提示：




题目：Whoisthebestteacher?(1668)
时间限制：3000MS
空间限制：65535K
题目描述：
	There are N teachers in a school, each has Ti students. The teachers decide to hold a race among their students to see who teaches best students. The students will get constant points in a race.	Here is the rule:	In each race, each teacher send one student to compete, and his students take turns to compete with others. That is to say, if the jth student compete in race 1 and he will be sent to compete in race 1+Ti (if the teacher hasn't got the prize yet). In a race, we choose the student who gets the highest score, then the teacher of student wins the prize and he is not included in the remaining races among other teachers(Because he is excellent now). If there are more than one student with highest score, we will then not let any get the prize and head to the next.	We are interested in whether all teachers are excellent at teaching and how many races should the school hold when the last good teacher get the prize. You might write a program to help us.
题目输入：
	The first line of contains a single integer T, indicating the number of test cases. (1<=T<=15)	Each test case begins with an integer N(1<=N<=500), the number of teachers.	In the following N lines, each line contains an integer Ti(1<=Ti<=10), indicating the number of students of the i-th teacher, then Ti integers Mj(0<=Mj<=250) follow, indicating the constant points the j-th student get in each race.
题目输出：
	For each test case, print a single line containing two integers E, C, indicating the number of teachers that is not so excellent at teaching as others, and the number of races held when the last excellent teacher get the prize. If all teachers are with equal level in teaching, the second number should be 0.	
输入样例：
1
4
3 2 9 4
1 3 
2 3 4
1 3
输出样例：
2 4
提示：
None



题目：TradeonVerweggistan(1568)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	Since the days of Peter Stuyvesant and Abel Tasman, Dutchmerchants have been traveling all over the world to buy and sell goods. Oncethere was some trade on Verweggistan, but it ended after a short time. Afterreading this story you will understand why. 	At that time Verweggistan was quite popular, because itwas the only place in the world where people knew how to make a `prul'. The endof the trade on Verweggistan meant the end of the trade in pruls (or `prullen',as the Dutch plural said), and very few people nowadays know what a prulactually is. 	Pruls were manufactured in workyards. Whenever a prul wasfinished it was packed in a box, which was then placed on top of the pile ofpreviously produced pruls. On the side of each box the price was written. Theprice depended on the time it took to manufacture the prul. If all went well, aprul would cost one or two florins, but on a bad day the price could easilyrise to 15 florins or more. This had nothing to do with quality; all pruls hadthe same value. 	In those days pruls sold for 10 florins each in Holland.Transportation costs were negligible since the pruls were taken as extra onships that would sail anyway. When a Dutch merchant went to Verweggistan, hehad a clear purpose: buy pruls, sell them in Holland, and maximize his profits.Unfortunately, the Verweggistan way of trading pruls made this more complicatedthan one would think. 	One would expect that merchants would simply buy thecheapest pruls, and the pruls that cost more than 10 florins would remainunsold. Unfortunately, all workyards on Verweggistan sold their pruls in aparticular order. The box on top of the pile was sold first, then the secondone from the top, and so on. So even if the fifth box from the top was thecheapest one, a merchant would have to buy the other four boxes above to obtainit. 	As you can imagine, this made it quite difficult for the merchants to maximizetheir profits by buying the right set of pruls. Not having computers to helpwith optimization, they quickly lost interest in trading pruls at all. 	In this problem, you are given the description of severalworkyard piles. You have to calculate the maximum profit a merchant can obtainby buying pruls from the piles according to the restrictions given above. Inaddition, you have to determine the number of pruls he has to buy to achievethis profit. 
题目输入：
	The input describes several test cases. The first lineof input for each test case contains a single integer w, the number ofworkyards in the test case ( 1	This is followed by w lines, each describing apile of pruls. The first number in each line is the number b of boxes inthe pile ( 0<=b<=20). Following it are b positive integers, indicating the prices (in florins) of the pruls in thestack, given from top to bottom. 	The input is terminated by a description starting with w = 0. This description should not be processed. 
题目输出：
	For each test case, print the case number (1, 2, ...).Then print two lines, the first containing the maximum profit the merchant canachieve. The second line should specify the number of pruls the merchant has tobuy to obtain this profit. If this number is not uniquely determined, print thepossible values in increasing order. If there are more than ten possiblevalues, print only the 10 smallest. 	Display a blank line between test cases. 
输入样例：
1
6 12 3 10 7 16 5
2
5 7 3 11 9 10
9 1 2 3 4 10 16 10 4 16
0

输出样例：
Workyards 1
Maximum profit is 8.
Number of pruls to buy: 4

Workyards 2
Maximum profit is 40.
Number of pruls to buy: 6 7 8 9 10 12 13

提示：
None



题目：Grocerystore(1367)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A cashier in a grocery store seems to have difficulty in distinguishing the multiplication symbol and the addition symbol. To make things easier for him, you want to buy goods in such a way that the product of their prices is the same as the sum of their prices. 
Of course, if you buy only one item, this is always true. With two items and three items, it still seems quite a boring task to you, so now you are interested in finding possible prices of four items such that the sum of the four prices is equal to the product of the four prices. You should consider the prices are in € with two digits after the decimal point. Obviously, each product costs at least one cent.
题目输入：
This problem has no input.
题目输出：
Print all solutions which have a sum of the four items of at most 20.00 €. For each solution, print one line with the prices of the four items in non-decreasing order, with one space character between them. You may print the solutions in any order, but make sure to print each solution only once.
输入样例：

输出样例：
0.50 1.00 2.50 16.00
1.25 1.60 1.75 1.84
1.25 1.40 1.86 2.00
...
提示：




题目：奇特的斐波那契(1773)
时间限制：2000MS
空间限制：65535KB
题目描述：
	我们都知道斐波那契数列是f[1]=f[2]=1,f[n]=f[n-1]+f[n-2]（n>2）	我们最近发现了一种新的斐波那契数列，给出新斐波那契数列的前n项，这前n项围城一个环我们定义为第一层，第二层的元素值是前一层相应位置前后相邻两个元素之和，现在给出第一层的n项：	f[1]=1;	f[2]=2;	f[3]=3;	f[4]=4;	f[5]=5;	第二层的数:		f[6]=7;	f[7]=4;	f[8]=6;	f[9]=8;	f[10]=5;	第三层的数：	f[11]=9;	f[12]=13;	f[13]=12;	f[14]=11;	f[15]=15.	如图所示：	     	现在要我们求出新斐波那契数列的第m项.	
题目输入：
	多组测试数据，第一行输入两个整数n(2<n<=500)，m(0<m<=10^18)。第二行输入n个整数。
题目输出：
	输出新斐波那契数列的第m项模除100000007的结果.
输入样例：
5 12
1 2 3 4 5
输出样例：
13
提示：
None



题目：MoneySystems(1469)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The cows have not only created their own government but they have chosen to create their own money system. In their own rebellious way, they are curious about values of coinage. Traditionally, coins come in values like 1, 5, 10, 20 or 25, 50, and 100 units, sometimes with a 2 unit coin thrown in for good measure. The cows want to know how many different ways it is possible to dispense a certain amount of money using various coin systems. For instance, using a system of {1, 2, 5, 10, ...} it is possible to create 18 units several different ways, including: 18x1, 9x2, 8x2+2x1, 3x5+2+1, and many others. Write a program to compute how many ways to construct a given amount of money using supplied coinage. It is guaranteed that the total will fit into both a signed long long (C/C++) and Int64 (Free Pascal).
题目输入：
There are several test cases, end by EOF, for each test case:The number of coins in the system is V (1 <= V <= 25). The amount money to construct is N (1 <= N <= 10,000). Line 1:  Two integers, V and N  Lines 2..:  V integers that represent the available coins (no particular number of integers per line)
题目输出：
A single line containing the total number of ways to construct N money units using V coins.
输入样例：
3 10
1 2 5
输出样例：
10
提示：




题目：String(1122)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Dccmx很喜欢字符串，于是他想让一个字符串有更多的子串，于是他定义：有一个字符串str，我们把在str的头尾及中间插入若干多个空格后构成的新字符串称为str的加空子串，如字符串str为“abcbcd”，则字符串“ab□cb□c□d”，“□a□b□□□cb□cd□”和“a□bcb□cd□”都是str的加空子串，这里“□”代表空格字符。那么我们定义字符串A1与B1的距离为相应位置上的字符的距离总和，如果A1是字符串A的加空子串串，B1是字符串B的加空子串，A1与B1具有相同的长度，而两个非空格字符的距离定义为它们的ASCII码的差的绝对值，而空格字符与其它任意字符之间的距离为已知的定值K，空格字符与空格字符的距离为O。在字符串A、B的所有加空子串中，必定存在两个等长的加空子串A1、B1，使得A1与B1之间的距离达到最小，我们将这一距离定义为字符串A、B的距离。请你写一个程序，求出字符串A、B的距离。
题目输入：
输入文件第一行为字符串A，第二行为字符串B，A、B均由小写字母组成且长度均不超过2000，第三行为一个整数K，1 ≤ K ≤ 100，表示空格与其它字符的距离。
题目输出：
输出文件仅一行包含一个整数，表示要求的字符串A、B的距离。
输入样例：
cmc
snmn
2
输出样例：
10
提示：




题目：SinglePointofFailure(1021)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Consider the two networks shown below. Assuming that data moves around these networks only between directly connected nodes on a peer-to-peer basis, a failure of a single node, 3, in the network on the left would prevent some of the still available nodes from communicating with each other. Nodes 1 and 2 could still communicate with each other as could nodes 4 and 5, but communication between any other pairs of nodes would no longer be possible. 
Node 3 is therefore a Single Point of Failure (SPF) for this network. Strictly, an SPF will be defined as any node that, if unavailable, would prevent at least one pair of available nodes from being able to communicate on what was previously a fully connected network. Note that the network on the right has no such node; there is no SPF in the network. At least two machines must fail before there are any pairs of available nodes which cannot communicate. 
题目输入：
The input will contain the description of several networks. A network description will consist of pairs of integers, one pair per line, that identify connected nodes. Ordering of the pairs is irrelevant; 1 2 and 2 1 specify the same connection. All node numbers will range from 1 to 1000. A line containing a single zero ends the list of connected nodes. An empty network description flags the end of the input. Blank lines in the input file should be ignored.
For each network in the input, you will output its number in the file, followed by a list of any SPF nodes that exist. 
题目输出：
The first network in the file should be identified as "Network #1", the second as "Network #2", etc. For each SPF node, output a line, formatted as shown in the examples below, that identifies the node and the number of fully connected subnets that remain when that node fails. If the network has no SPF nodes, simply output the text "No SPF nodes" instead of a list of SPF nodes. 
输入样例：
1 2
5 4
3 1
3 2
3 4
3 5
0
1 2
2 3
3 4
4 5
5 1
0
1 2
2 3
3 4
4 6
6 3
2 5
5 1
0
0
输出样例：
Network #1
SPF node 3 leaves 2 subnets
Network #2
No SPF nodes
Network #3
SPF node 2 leaves 2 subnets
SPF node 3 leaves 2 subnets
提示：




题目：雷区(1669)
时间限制：1000MS
空间限制：65535K
题目描述：
	Once in a war, a soldier HaVE is ordered to send a secret document. To save time, he decides to move to destination with a straight line. If we consider his route as a number axis, then his starting point will be zero, and his destination will be N(0<N<=10000).	Unfortunately, the enemies laid a lot of landmines in his route. The mines are so dangerous that once HaVE step on one of them and make it explode, it is impossible for him to survive. However, of great luck, each of mines has a probability P to explode.This is to say, if a mine has a explosion probability as 0.5 and HaVE step on it unfortunately, then the mine will explode or not, as both are equally possible.Although the future is hard, HaVE is brave,he will never move back but move forward.	Since HaVE know this fact, he decide to gamble his life and honor by moving forward randomly. He might move x steps at a time. This is to say hve might move from i to i+x at a time. And well, because of his limited stamina, he can move at most L steps(0<L<=100).If you ask him how many steps he want to move,he can't not tell you because only God knows. But you know every kind of steps choose will be equally possibe.	Now, if you know HaVE's destination N, maximum steps a time L, and all positions and explosion probabilities of landmines, can you forcast that he will survive and reach the destination or die on the way? Give me the possiblity of his survive exactly at destination.
题目输入：
	The Input consists of mulitiple cases.	Each case will start with a line contains two integers: N(0<N<=10000), the destination of HaVE, and L(0<L<=100), the maximum steps a time.	The second line contains only an integer M(0<M<100), the number of landmines.	Then follows M lines.Each line describe a mine with an integer x (0<x<N), the position of mine, and an real number p, the explosion probability of it.	The Input will end with EOF.
题目输出：
	Output the survive possibility with exactly six digits after decimal point in one line for each case.
输入样例：
3 2
2
1 0.6
2 0.9

输出样例：
0.160000
提示：
None



题目：Robot(1569)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	A robot arm used in an automated factory consists of N connectedlinks: link1 which is connected to link2,..., and linkN - 1 which is connected to linkN.Each link is a straight rod of a specified length, len1, len2,..., lenN. Between each pair of connected links is a servo, servo2 (between link1 and link2), ..., and servoN (between linkN - 1 and linkN) that can beactivated to adjust the angle between the connected links. Link1 is also connected by a servo, servo1, to the factory floor(at the point x = 0, y = 0, z = 0 in a Cartesiancoordinate system). At the free (unconnected) end of the last link (linkN)is a ``hand'' that can be used to grasp objects. 	In the initial setting of the robot arm, each servo is set to no rotation (0degrees), and the links in the robot arm coincide with the z-axis. The xy plane is horizontal (the factory floor), and the entire robot arm is initiallypointing up, vertically. From this initial setting, each servo can effect arotation of up to 90 degrees in either of two directions. Servo1 moves the entire robot arm in the xz plane by rotation about the y-axis. Servo2 moves the arm (except link1) in the(perhaps rotated) yz plane by rotation about the x-axis. In asimilar manner, each odd-numbered servo can rotate the remaining part of thearm in the (perhaps rotated) xz plane, and each even-numbered servo canrotate the remaining part of the arm in the (perhaps rotated) yz plane.In effect, the servos rotate the links about the y and x-axes ofcoordinate systems fixed to the end of each link. Counterclockwise rotationsabout a coordinate axis are produced with positive rotation angles, if we arelooking along the positive half of the axis toward the coordinate origin. Thesample data has been carefully chosen to illustrate the effects of theserotations. 	There are two restrictions on the final positioning of the robot's arm. No partof the arm can be below the factory floor, and the links in the robot's armcannot intersect with each other (except where they are connected by theservos). 	You should check only the final position of the arm. 	Given the number of links in a robot's arm, their lengths, and the proposedsettings of the servos, first determine if the proposed positioning of the armis allowable. If the arm can be positioned as proposed, then determine thecoordinates of the robot's hand, accurate to three fractional digits. Otherwiseidentify the first (smallest numbered) servo that has an inappropriate setting,and why that setting is inappropriate. Links are assumed to intersect if theycome within 0.001 length units of each other. 
题目输入：
	The input data will contain multiple test cases. Eachtest case includes, in order, the number of links, N, their lengths, len1, len2,..., lenN, and the proposed angles towhich the servos (starting with servo1) are to be set. Thelengths and servo angles are real numbers, and the number of links is aninteger. There will be no more than 10 links in any robot arm. The last testcase is followed by a negative integer. 
题目输出：
	For each test case, display the test case number(starting with 1). Then, if the proposed setting is allowable, display theposition of the robot's hand in the original (factory floor) coordinate system(with three fractional digits). Otherwise display the identity of the firstservo with an inappropriate setting and why that setting is inappropriate. Anoutput format similar to that shown below is acceptable. 
输入样例：
2 25 15 0 90.0
1 1.0 45.0
2 1 1 0 45
4 1 2 3 4 90 0 0 0
3 1 1 1 0 90 90
2 1 1 45.0 45
4 1 1 1 2 0 90 0 90
8 10 1 1 1 1 1 1 2
   0 0 90 0 90 0 90 0
-1

输出样例：
Case 1: robot's hand is at (0.000,-15.000,25.000)
Case 2: robot's hand is at (0.707,0.000,0.707)
Case 3: robot's hand is at (0.000,-0.707,1.707)
Case 4: robot's hand is at (10.000,0.000,0.000)
Case 5: robot's hand is at (1.000,-1.000,1.000)
Case 6: robot's hand is at (1.207,-0.707,1.207)
Case 7: servo 4 attempts to move arm below floor
Case 8: servo 8 causes link collision

提示：
None



题目：我会打括号！！(1226)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
hdd不仅不擅长计算，有时候连括号也写不对，他经常写出这样的表达式：5*（3+4]=50 ,3+(5/[4+5)]*}3+4{=8等等。
现在我们把等式的右边省去，并且把左边的数字和运算符省去，只留下括号，请你写一个程序判断这些括号是否匹配，在这里我们允许小括号套在大括号外面的情况发生。
题目输入：
多组数据，EOF结束，每组一行字符（长度不超过1000），仅包含()[]{}。
题目输出：
匹配输出Yes，否则输出No
输入样例：
({}[{()}])
(]

输出样例：
Yes
No

提示：




题目：Halloweentreats(1368)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Every year there is the same problem at Halloween: Each neighbour is only willing to give a certain total number of sweets on that day, no matter how many children call on him, so it may happen that a child will get nothing if it is too late. To avoid conflicts, the children have decided they will put all sweets together and then divide them evenly among themselves. From last year's experience of Halloween they know how many sweets they get from each neighbour. Since they care more about justice than about the number of sweets they get, they want to select a subset of the neighbours to visit, so that in sharing every child receives the same number of sweets. They will not be satisfied if they have any sweets left which cannot be divided. 
Your job is to help the children and present a solution.
题目输入：
The input contains several test cases. 
The first line of each test case contains two integers c and n (1 ≤ c ≤ n ≤ 100000), the number of children and the number of neighbours, respectively. The next line contains n space separated integers a1 , ... , an (1 ≤ ai ≤ 100000 ), where ai represents the number of sweets the children get if they visit neighbour i. 

The last test case is followed by two zeros.

题目输出：
For each test case output one line with the indices of the neighbours the children should select (here, index i corresponds to neighbour i who gives a total number of ai sweets). If there is no solution where each child gets at least one sweet, print "no sweets" instead. Note that if there are several solutions where each child gets at least one sweet, you may print any of them.
输入样例：
4 5
1 2 3 7 5
3 6
7 11 2 5 13 17
0 0

输出样例：
3 5
2 3 4

提示：




题目：拉网线(1774)
时间限制：4000MS
空间限制：655350KB
题目描述：
	小明要给一个乡村的所有居民铺设网络，这个乡村总共有N户居民，为了节约网线，老板要求小明所使用的网线总长度最短，并且所有人都可以上网。	当然，这个要求对于小明来说毫无压力，正当小明准备工作的时候，老板又来了，他告诉小明，这些居民中有两家A，B非常不和睦，所以千万不要在A，B之间拉网线，而应该通过第三方C供网。遗憾的是老板不知道哪两家人不和睦。老板希望小明拿出一个万全的方案，无论哪两户人家不合都能很快的知道网线总长度。
题目输入：
	第一行 T,表明case数。(T<=30)	第二行 N.表示居民数（3<= N <= 3000）。	接下来N-1行，第一行有一个整数，第二行有两个整数，依次类推，第N-1行有N-1个整数，其中每一行的第一个数表示到居民0的距离，其他依次类推。例如，样例中的第二行 第一个数表示居民2到居民0的距离，第二个数表示居民2到居民1的 距离。	接下来一个整数Q（Q<= 100000）	接下来Q行，每行输入两个整数0<=A，B<N。（A != B）表示A，B之间不和睦。
题目输出：
	Q次查询的平均网线长度(保留四位有效数字)。
输入样例：
1
3
7
10 5
3
2 1
2 0
1 0
输出样例：
14.6667
提示：
None



题目：AnotherAdvancedRobot(1123)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The Robot Moving Institute is using a robot in their local store to transport different items. Of course the robot should spend only the minimum time necessary when travelling from one place in the store to another. The robot can move only along a straight line (track). All tracks form a rectangular grid. Neighbouring tracks are one meter apart. The store is a rectangle N x M meters and it is entirely covered by this grid. The distance of the track closest to the side of the store is exactly one meter. The robot has a circular shape with diameter equal to 1.6 meter. The track goes through the center of the robot. The robot always faces north, south, west or east. The tracks are in the south-north and in the west-east directions. The robot can move only in the direction it faces. The direction in which it faces can be changed at each track crossing. Initially the robot stands at a track crossing. The obstacles in the store are formed from pieces occupying 1m x 1m on the ground. Each obstacle is within a 1 x 1 square formed by the tracks. The movement of the robot is controlled by two commands. These commands are GO and TURN. The GO command has zero or one integer parameter n in {n1,n2,n3,……}. After receiving this command the robot moves n meters in the direction it faces. The TURN command has one parameter which is either left or right. After receiving this command the robot changes its orientation by 90o in the direction indicated by the parameter. The execution of each command lasts one second. Help researchers of RMI to write a program which will determine the minimal time in which the robot can move from a given starting point to a given destination. 
题目输入：
The input consists of blocks of lines. The first line of each block contains two integers M <= 50 and N <= 50 separated by one space. In each of the next M lines there are N numbers one or zero separated by one space. One represents obstacles and zero represents empty squares. (The tracks are between the squares.) The M lines is followed by one integer 0 <= P <= 6, representing the number of the possible parameter of the GO command. In the next line, there is (are) P different non-negative integers (from 1 to P) separated by whitespace, representing the P parameters. The block is terminated by a line containing four positive integers B1 B2 E1 E2 each followed by one space and the word indicating the orientation of the robot at the starting point. B1, B2 are the coordinates of the square in the north-west corner of which the robot is placed (starting point). E1, E2 are the coordinates of square to the north-west corner of which the robot should move (destination point). The orientation of the robot when it has reached the destination point is not prescribed. We use (row, column)-type coordinates, i.e. the coordinates of the upper left (the most north-west) square in the store are 0,0 and the lower right (the most south-east) square are M - 1, N - 1. The orientation is given by the words north or west or south or east. The last block contains only one line with N = 0 and M = 0. 
题目输出：
The output contains one line for each block except the last block in the input. The lines are in the order corresponding to the blocks in the input. The line contains minimal number of seconds in which the robot can reach the destination point from the starting point. If there does not exist any path from the starting point to the destination point the line will contain -1. 
输入样例：
9 10
0 0 0 0 0 0 1 0 0 0
0 0 0 0 0 0 0 0 1 0
0 0 0 1 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 1 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 1 0
3
1 2 3
7 2 2 7 south
0 0

输出样例：
12
提示：




题目：ControllingCompanies(1470)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Some companies are partial owners of other companies because they have acquired part of their total shares of stock. For example, Ford owns 12% of Mazda. It is said that a company A controls company B if at least one of the following conditions is satisfied: Company A = Company B Company A owns more than 50% of Company B Company A controls K (K >= 1) companies denoted C1, ..., CK with each company Ci owning xi% of company B and x1 + .... + xK > 50%. Given a list of triples (i,j,p) which denote company i owning p% of company j, calculate all the pairs (h,s) in which company h controls company s. There are at most 100 companies. Write a program to read the list of triples (i,j,p) where i, j and p are positive integers all in the range (1..100) and find all the pairs (h,s) so that company h controls company s.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  n, the number of input triples to follow Line 2..n+1:  Three integers per line as a triple (i,j,p) described above.
题目输出：
List 0 or more companies that control other companies. Each line contains two integers that denote that the company whose number is the first integer controls the company whose number is the second integer. Order the lines in ascending order of the first integer (and ascending order of the second integer to break ties). Do not print that a company controls itself.
输入样例：
3
1 2 80
2 3 80
3 1 20
输出样例：
1 2
1 3
2 3
提示：




题目：Ambiguouspermutations(1369)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Some programming contest problems are really tricky: not only do they require a different output format from what you might have expected, but also the sample output does not show the difference. For an example, let us look at permutations.A permutation of the integers 1 to n is an ordering of these integers. So the natural way to represent a permutation is to list the integers in this order. With n = 5, a permutation might look like 2, 3, 4, 5, 1. However, there is another possibility of representing a permutation: You create a list of numbers where the i-th number is the position of the integer i in the permutation. Let us call this second possibility an inverse permutation. The inverse permutation for the sequence above is 5, 1, 2, 3, 4. An ambiguous permutation is a permutation which cannot be distinguished from its inverse permutation. The permutation 1, 4, 3, 2 for example is ambiguous, because its inverse permutation is the same. To get rid of such annoying sample test cases, you have to write a program which detects if a given permutation is ambiguous or not.
题目输入：
The input contains several test cases.
The first line of each test case contains an integer n (1 ≤ n ≤ 100000). Then a permutation of the integers 1 to n follows in the next line. There is exactly one space character between consecutive integers. You can assume that every integer between 1 and n appears exactly once in the permutation. 
The last test case is followed by a zero.
题目输出：
For each test case output whether the permutation is ambiguous or not. Adhere to the format shown in the sample output.
输入样例：
4
1 4 3 2
5
2 3 4 5 1
1
1
0

输出样例：
ambiguous
not ambiguous
ambiguous

提示：




题目：WangLuoLiu(1022)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The terrorist group leaded by a well known international terrorist Ben Bladen is buliding a nuclear reactor to produce plutonium for the nuclear bomb they are planning to create. Being the wicked computer genius of this group, you are responsible for developing the cooling system for the reactor.
The cooling system of the reactor consists of the number of pipes that special cooling liquid flows by. Pipes are connected at special points, called nodes, each pipe has the starting node and the end point. The liquid must flow by the pipe from its start point to its end point and not in the opposite direction.
Let the nodes be numbered from 1 to N. The cooling system must be designed so that the liquid is circulating by the pipes and the amount of the liquid coming to each node (in the unit of time) is equal to the amount of liquid leaving the node. That is, if we designate the amount of liquid going by the pipe from i-th node to j-th as fij, (put fij = 0 if there is no pipe from node i to node j), for each i the following condition must hold:
fi,1+fi,2+...+fi,N = f1,i+f2,i+...+fN,i 
Each pipe has some finite capacity, therefore for each i and j connected by the pipe must be fij <= cij where cij is the capacity of the pipe. To provide sufficient cooling, the amount of the liquid flowing by the pipe going from i-th to j-th nodes must be at least lij, thus it must be fij >= lij.
Given cij and lij for all pipes, find the amount fij, satisfying the conditions specified above.
This problem contains multiple test cases!
The first line of a multiple input is an integer N, then a blank line followed by N input blocks. Each input block is in the format indicated in the problem description. There is a blank line between input blocks.
The output format consists of N output blocks. There is a blank line between output blocks.
题目输入：
The first line of the input file contains the number N (1 <= N <= 200) - the number of nodes and and M - the number of pipes. The following M lines contain four integer number each - i, j, lij and cij each. There is at most one pipe connecting any two nodes and 0 <= lij <= cij <= 10^5 for all pipes. No pipe connects a node to itself. If there is a pipe from i-th node to j-th, there is no pipe from j-th node to i-th.
题目输出：
On the first line of the output file print YES if there is the way to carry out reactor cooling and NO if there is none. In the first case M integers must follow, k-th number being the amount of liquid flowing by the k-th pipe. Pipes are numbered as they are given in the input file.
输入样例：
2
4 6
1 2 1 2
2 3 1 2
3 4 1 2
4 1 1 2
1 3 1 2
4 2 1 2
4 6
1 2 1 3
2 3 1 3
3 4 1 3
4 1 1 3
1 3 1 3
4 2 1 3
输出样例：
NO
YES
1
2
3
2
1
1
提示：




题目：Canyoufindit?(1670)
时间限制：1000MS
空间限制：65535K
题目描述：
	Hi smart guys, you must know thecommon divisor of two integers. But do you know the common divisor of twostrings.	Now,let’s define the it. First, you should know the divisor of a string : Given a stringstr, if there is a string sub, and we can get string str by write string sub ttimes, where t is an integer. For example string “abab” has two divisors “ab”and “abab”. Now you must have guessed the common divisor of the twostrings.  Your task is that given twostrings, find the smallest common divisor of them.
题目输入：
	First line of input is an integerT(1<=T<=300) indicate the number of test case.	The next 2T lines, each line have a non-empty string, every two lines indicating a test case.	The length of every string not exceed 10000, and only consist of lowercase letters.
题目输出：
	For each case output the smallest common divisor of the two string in one line. If they have no common divisor, just output “I am just kidding!” in one line.
输入样例：
3
aa
aaa
abcabc
abcabcabcabc
aaa
bbb
输出样例：
a
abc
I am just kidding!
提示：
None



题目：阵营pk(1775)
时间限制：4000MS
空间限制：65535KB
题目描述：
	现在有两个阵营A,B，你是A阵营的决策者。每个阵营中都有实力相当的选手n名，他们的实力分别以a[0]~a[n-1]的整数来描述，a[i]表示选手i一天正好取走a[i]个资源，不能多也不能少。有k个仓库，每个仓库里面都放着mi堆资源，每堆资源分别以b[0]~b[mi-1]的整数来表示个数。Pk规则是这样的：A,B在每个仓库进行pk，以便得到k次pk后的结果。在一个当前pk的仓库中，pk规则如下：	1.每天只允许一个阵营从n个选手中派一个选手来取资源，且必须派遣，总是A阵营最先派遣；	2.两个阵营轮流派遣；	3.选手只能从现有堆中的某一堆取与其实力相当的资源，不能多取也不能少取，也不能不取；	4.没办法继续取得资源的阵营失去该仓库的使用权；	5.阵营A,B均采用最优策略；	问，如果你想要获得仓库的使用权，对于每个仓库你首先该派遣哪位选手？	而且，你会考虑到，你第一次会搞该仓库中资源号尽可能小的资源，在这种情况下，如果还有多位选手可以派遣的话，你会派遣实力最小的那个选手。输出那名选手的实力值即可。如果你无法赢得使用权，那么输出“CaLei”。
题目输入：
	以下列形式输入，多case，EOF结尾	n   a[0]~a[n-1]	k	m0  b[0]~b[m0-1]	m1  b[0]~b[m1-1]	……	mk-1  b[0]~b[mk-1-1]		数据范围	0<n<=100  0<a[i]<=10000  0<k<=100  0<mi<=100  0<b[i]<=10000
题目输出：
	见描述
输入样例：
2 2 5
3
2 5 12
3 2 4 7
4 2 3 7 12
5 1 2 3 4 5
3
2 5 12
3 2 4 7
4 2 3 7 12
输出样例：
CaLei
2
2
5
1
CaLei
提示：
None



题目：TheLetterCarrier'sRounds(1570)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	For an electronic mail application you are to describe the SMTP-basedcommunication that takes place between pairs of MTAs. The sender's User Agentgives a formatted message to the sending Message Transfer Agent (MTA). Thesending MTA communicates with the receiving MTA using the Simple Mail TransferProtocol (SMTP). The receiving MTA delivers mail to the receiver's User Agent.After a communication link is initialized, the sending MTA transmits commandlines, one at a time, to the receiving MTA, which returns a three-digit codedresponse after each command is processed. The sender commands are shown belowin the order sent for each message. There is more than one RCPT TO line whenthe same message is sent to several users at the same MTA. A message to usersat different MTAs requires separate SMTP sessions. 		HELO  myname Identifies the sender to thereceiver (yes, there is only one L) 	MAIL  FROM:< sender > Identifies the message sender 	RCPT  TO:< user > Identifies onerecipient of the message 	DATA  Followed by an arbitrary number of lines oftext comprising the message 		body, ending with a linecontaining a period in column one. 	QUIT  Terminates the communication.	The following response codes are sent by the receiving MTA: 	221	Closing connection(after QUIT) 	250	Action was okay(after MAIL FROM and RCPT TO specifying an acceptable user, or completion of amessage) 	354	Start sending mail(after DATA) 	550	Action not taken;no such user here (after RCPT TO with unknown user) 
题目输入：
	The input contains descriptions of MTAs followed by anarbitrary number of messages. Each MTA description begins with the MTAdesignation and its name (1 to 15 alphanumeric characters). Following the MTAname is the number of users that receive mail at that MTA and a list of theusers (1 to 15 alphanumeric characters each). The MTA description is terminatedby an asterisk in column 1. Each message begins with the sending user's nameand is followed by a list of recipient identifiers. Each identifier has theform user@mtaname. The message (each line containing no more than 72characters) begins and terminates with an asterisk in column 1. A line with anasterisk in column 1 instead of a sender and recipient list indicates the endof the entire input. 
题目输出：
	For each message, show the communication between thesending and receiving MTAs. Every MTA mentioned in a message is a valid MTA;however, message recipients may not exist at the destination MTA. The receivingMTA rejects mail for those users by responding to the RCPT TO command with the550 code. A rejection will not affect delivery to authorized users at the sameMTA. If there is not at least one authorized recipient at a particular MTA, theDATA is not sent. Only one SMTP session is used to send a message to users at aparticular MTA. For example, a message to 5 users at the same MTA will haveonly one SMTP session. Also a message is addressed to the same user only once.The order in which receiving MTAs are contacted by the sender is the same as inthe input file. As shown in the sample output, prefix the communication withthe communicating MTA names, and indent each non-empty communication line. Noinnecessary spaces should be printed. 
输入样例：
MTA London 4 Fiona Paul Heather Nevil
MTA SanFrancisco 3 Mario Luigi Shariff
MTA Paris 3 Jacque Suzanne Maurice
MTA HongKong 3 Chen Jeng Hee
MTA MexicoCity 4 Conrado Estella Eva Raul
MTA Cairo 3 Hamdy Tarik Misa
*
Hamdy@Cairo Conrado@MexicoCity Shariff@SanFrancisco Lisa@MexicoCity
*
Congratulations on your efforts !!
--Hamdy
*
Fiona@London Chen@HongKong Natasha@Paris
*
Thanks for the report!  --Fiona
*
*

输出样例：
Connection between Cairo and MexicoCity
     HELO Cairo
     250
     MAIL FROM:
     250
     RCPT TO:
     250
     RCPT TO:
     550
     DATA
     354
     Congratulations on your efforts !!
     --Hamdy
     .
     250
     QUIT
     221
Connection between Cairo and SanFrancisco
     HELO Cairo
     250
     MAIL FROM:
     250
     RCPT TO:
     250
     DATA
     354
     Congratulations on your efforts !!
     --Hamdy
     .
     250
     QUIT
     221
Connection between London and HongKong
     HELO London
     250
     MAIL FROM:
     250
     RCPT TO:
     250
     DATA
     354
     Thanks for the report!  --Fiona
     .
     250
     QUIT
     221
Connection between London and Paris
     HELO London
     250
     MAIL FROM:
     250
     RCPT TO:
     550
     QUIT
     221

提示：
None



题目：Boringgame(1227)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
      hdd和zyz小朋友最近貌似挺无聊。无聊到了一定的程度。他们就想了一个很无聊的游戏。他们让huangc小朋友给他们一个随机序列（数字)，他们从头到尾选择N个数字。鉴于两个家伙都是很贪心的家伙。他们选取的后一个数字必定不会小于前一个数字，且他们的目的是最终选取数字的个数尽可能多。      hdd一个一个很努力地数着。zyz，很不好意思偷懒了。他开了台电脑。他们最终的得到了相同的结果。问zyz怎么做到的。。。
题目输入：
	第一行：一个整数T , (T组测试数据）
	第二到T+1行：一个整数N代表n(1<=n<=100000)个数字。后面是N个数字,代表huangc的那个随机序列。 
题目输出：
    T行，每组测试数据中选取数字个数的最大值；
输入样例：
1
10  4   5   3   2   5   3   2   1   7   12
输出样例：
5    
提示：
4->5->5->7->12   zyz选取这五个数字



题目：TheTamworthTwo(1471)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A pair of cows is loose somewhere in the forest. Farmer John is lending his expertise to their capture. Your task is to model their behavior. The chase takes place on a 10 by 10 planar grid. Squares can be empty or they can contain: an obstacle, the cows (who always travel together), or Farmer John. The cows and Farmer John can occupy the same square (when they `meet') but neither the cows nor Farmer John can share a square with an obstacle. Each square is represented as follows: . Empty square * Obstacle C Cows F Farmer  Here is a sample grid: *...*...........*......*...*...............*.F....*.....*......*........C......*...*.*.....*.*...... The cows wander around the grid in a fixed way. Each minute, they either move forward or rotate. Normally, they move one square in the direction they are facing. If there is an obstacle in the way or they would leave the board by walking `forward', then they spend the entire minute rotating 90 degrees clockwise. Farmer John, wise in the ways of cows, moves in exactly the same way. The farmer and the cows can be considered to move simultaneously during each minute. If the farmer and the cows pass each other while moving, they are not considered to have met. The chase ends when Farmer John and the cows occupy the same square at the end of a minute. Read a ten-line grid that represents the initial state of the cows, Farmer John, and obstacles. Each of the ten lines contains exactly ten characters using the coding above. There is guaranteed to be only one farmer and one pair of cows. The cows and Farmer John will not initially be on the same square. Calculate the number of minutes until the cows and Farmer John meet. Assume both the cows and farmer begin the simulation facing in the `north' direction. Print 0 if they will never meet.
题目输入：
There are several test cases, end by EOF, for each test case:Lines 1-10:  Ten lines of ten characters each, as explained above
题目输出：
A single line with the integer number of minutes until Farmer John and the cows meet. Print 0 if they will never meet.
输入样例：
*...*.....
......*...
...*...*..
..........
...*.F....
*.....*...
...*......
..C......*
...*.*....
.*.*......
输出样例：
49
提示：




题目：如何判断一棵树？(1124)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
树是一种重要的数据结构，大家都经常用。树的描述：
只有唯一的一个节点作为根，它没有初度，其它节点都有且仅有一条边指向它。
注意树的边是有方向的，因此如果有节点指向它父亲也不是树。
（下面前两棵是树，最后一棵不是） 

下面你将得到几组有向边，请输出是不是树。
题目输入：
边的表示就是从边的起点到终点，图中每一个节点都将出现在这些边集中（也就是说，没有出现的序号，节点就不存在于图中，看第一张图） 0 0代表边集输入结束。-1 -1表示所有测试结束。

题目输出：
每组测试输出"Case k is a tree." 或者 "Case k is not a tree.", k从1开始。
输入样例：
6 8  5 3  5 2  6 4
5 6  0 0

8 1  7 3  6 2  8 9  7 5
7 4  7 8  7 6  0 0

3 8  6 8  6 4
5 3  5 6  5 2  0 0
-1 -1
输出样例：
Case 1 is a tree.
Case 2 is a tree.
Case 3 is not a tree.
提示：
提示：注意空树等特殊情况。



题目：BullshitBingo(1370)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Bullshit Bingo is a game to make lectures, seminars or meetings less boring. Every player has a card with 5 rows and 5 columns. Each of the 25 cells contains a word (the cell in the middle has always the word "BINGO" written in it). Whenever a player hears a word which is written on his card, he can mark it. The cell in the middle is already marked when the game starts. If a player has marked all the words in a row, a column or a diagonal, he stands up and shouts "BULLSHIT". After this, the game starts over again.
Sitting in a lecture, you observe that some students in the audience are playing Bullshit Bingo. You wonder what the average number of different words is until "BULLSHIT" is exclaimed. For the purpose of this problem, a word consists of letters of the English alphabet ('a' to 'z' or 'A' to 'Z'). Words are separated by characters other than letters (for example spaces, digits or punctuation). Do the comparison of words case-insensitively, i.e., "Bingo" is the same word as "bingo". When counting the number of different words, ignore the word BULLSHIT (indicating the end of the game), and consider only the words of the current game, i.e., if a word has already occurred in a previous game, you may still count it in the current game. If the last game is unfinished, ignore the words of that game.
题目输入：
The input file consists of the text of the lecture, with "BULLSHIT" occurring occasionally. The first game starts with the first word in the input. Each occurrence of "BULLSHIT" indicates the end of one game.
You may assume, that 

the word "BULLSHIT" occurs only in uppercase letters 
every word has at most 25 characters, and each line has at most 100 characters 
there are at most 500 different words before a game ends 
the players follow the rules, so there is no need to check if a game is valid or not
题目输出：
The output consists of one number: the average number of different words needed to win a game. Write the number as a reduced fraction in the format shown below. Reduced fraction means that there should be no integer greater than 1 which divides both the numerator and denominator. For example if there were 10 games, and the number of different words in each game summed up to 55, print "11 / 2".
输入样例：
Programming languages can be classified BULLSHIT into following types:
- imperative and BULLSHIT procedural languages
- functional languages
- logical BULLSHIT programming languages
- object-oriented BULLSHIT languages

输出样例：
9 / 2

提示：
In the sample input, there are 4 completed games. The number of different words is 5, 5, 4 and 4, respectively.



题目：UniqueShutDown(1023)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
N computers are connected into a network.
The rule is: M different pairs of computers are connected to each other by an link. All connections are two-way, that is, they can be used in both directions. 
There is always two students playing internet computer games,so Yutou make up his mind to stop them ! That is to say ,he want to shut down the connection between the two boys.
Now  Yutou want to know if there are no two different sets of link connections that can be destroyed, such that the two boy’s computers cannot connect to each other after shut down only one set of link 
题目输入：
The input file consists of several cases.
 In each case, the first line of the input file contains N, M, A and B (2 <= N <= 100, 1 <= M <= 100, 1 <= A,B <= N, A != B), specifying the number of computers in the network, the number of link connections, and the numbers of the boy’s computers respectively. A case with 4 zeros indicates the end of file.
Next M lines describe link connections. 
For each connection the numbers of the computers it connects are given and the cost of destroying this connection. It is guaranteed that all costs are non-negative integer numbers not exceeding 105, no two computers are directly connected by more than one link, no link connects a computer to itself and initially there is the way to transmit data from one main supercomputer to another.
题目输出：
If there is only one way to shut down, output "UNIQUE" in a single line. In the other case output "AMBIGUOUS".
输入样例：
4 4 1 2
1 2 1
2 4 2
1 3 2
3 4 1
4 4 1 2
1 2 1
2 4 1
1 3 2
3 4 1
0 0 0 0
输出样例：
UNIQUE
AMBIGUOUS
提示：




题目：跳马(1671)
时间限制：1000MS
空间限制：65535K
题目描述：
	Andfive是个三国杀高手，但是玩象棋就是菜鸟了，有一天他遇到了这样的一个问题。	在一个8*8矩阵中，有一个马要从一个位置跳到另一个位置。但是下象棋的人都知道，“马是走日，象走田”。并且马在跳的时候，会遇到“蹩马脚”的情况，一旦在跳向这个方向的时候马脚被蹩住，是不能想这个方向跳的。（马向要跳的那个方向和马同一条直线上马的前面有子就是马脚。如图红马可以跳到标记O的地方，但是由于红炮蹩住了马脚，所以不能跳到标记X的地方。）		Andfive想知道从起始位置到达目标位置最少可以用多少步到达，采用最少步数的路径有多少条，面对Andfive的求助，想成为ACM大神的你快来帮帮他吧。	
题目输入：
	第一行输入一个整数n（n<10000），代表n个8*8的矩阵，每个矩阵中“#”代表可以行走的位置，“*”代表障碍物，“S”代表起点，“T”代表终点。	
题目输出：
	若不能到达终点“T”，输出“No way!”	如果可以到达，请输出最短路径大小和条数。
输入样例：
2
*###*###
####S###
##**####
#*##***#
########
#*#*##*#
#*######
T##*####

********
S######*
########
#####T##
########
********
#######*
########
输出样例：
No way!
3 4
提示：
起点终点都有吗？（提示很重要）



题目：高富帅与屌丝(1776)
时间限制：2000MS
空间限制：65535KB
题目描述：
	高富帅的三个特征 --高 ，富 ， 帅。如果一个人发现有人比自己高，比自己富，比自己帅。那么他就认为自己是屌丝。。	现在总共有N个人，让你统计总共有多少只屌丝。
题目输入：
	第一行一个整数N （N <= 500000）	接下来N行。每行三个整数。a,b,c。分别表示高，富，帅的程度。（0 <= a,b,c <= 10^9，a值越大表示越高。b,c同理）
题目输出：
	多少只屌丝。
输入样例：
9
48 9 5
89 69 84
85 95 22
52 96 90
50 15 45
85 80 21
36 1 44
100 90 10
86 44 43
输出样例：
4
提示：
None



题目：AnIndustrialSpy(1125)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Industrial spying is very common for modern  research  labs.  I am such an industrial spy - don't tell anybody!  My recent job was to steal  the latest  inventions  from a famous math  research  lab.  It was hard  to obtain  some of their  results  but  I got their  waste out of a document shredder.I have already  reconstructed that their  research  topic is fast factorization. But  the remaining  paper snippets  only have single digits on it and I cannot  imagine what  they are for. Could it be that those digits  form prime  numbers?   Please  help  me to  find out  how many  prime  numbers  can be formed using the given digits.
题目输入：
The first line of the input  holds the number  of test  cases c (1 ≤ c ≤ 200). Each test  case consists of a single line.  This line contains  the digits (at  least one, at most seven) that are on the paper  snippets.
题目输出：
For each test case, print one line containing the number of di erent primes that can be reconstructedby shu ing the digits. You may ignore digits while reconstructing the primes (e.g., if you getthe digits 7 and 1, you can reconstruct three primes 7, 17, and 71). Reconstructed numbers that(regarded as strings) di er just by leading zeros, are considered identical (see the fourth case of thesample input).
输入样例：
4
17
1276543
9999999
011
输出样例：
3
1336
0
2
提示：
None



题目：Overfencing(1472)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
Farmer John went crazy and created a huge maze of fences out in a field. Happily, he left out two fence segments on the edges, and thus created two "exits" for the maze. Even more happily, the maze he created by this overfencing experience is a `perfect' maze: you can find a way out of the maze from any point inside it. Given W (1 <= W <= 38), the width of the maze; H (1 <= H <= 100), the height of the maze; 2*H+1 lines with width 2*W+1 characters that represent the maze in a format like that shown later - then calculate the number of steps required to exit the maze from the `worst' point in the maze (the point that is `farther' from either exit even when walking optimally to the closest exit). Of course, cows walk only parallel or perpendicular to the x-y axes; they do not walk on a diagonal. Each move to a new square counts as a single unit of distance (including the move "out" of the maze. Here's what one particular W=5, H=3 maze looks like: +-+-+-+-+-+|         |+-+ +-+ + +|     | | |+ +-+-+ + +| |     |  +-+ +-+-+-+Fenceposts appear only in odd numbered rows and and odd numbered columns (as in the example). The format should be obvious and self explanatory. Each maze has exactly two blank walls on the outside for exiting.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  W and H, space separated  Lines 2 through 2*H+2:  2*W+1 characters that represent the maze
题目输出：
A single integer on a single output line. The integer specifies the minimal number of steps that guarantee a cow can exit the maze from any possible point inside the maze.
输入样例：
5 3
+-+-+-+-+-+
|         |
+-+ +-+ + +
|     | | |
+ +-+-+ + +
| |     |  
+-+ +-+-+-+
输出样例：
9
提示：
The lower left-hand corner is *nine* steps from the closest exit.



题目：Flooded!(1571)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	To enable homebuyers to estimate the cost of flood insurance, areal-estate firm provides clients with the elevation of each 10-meter by10-meter square of land in regions where homes may be purchased. Water fromrain, melting snow, and burst water mains will collect first in those squareswith the lowest elevations, since water from squares of higher elevation willrun downhill. For simplicity, we also assume that storm sewers enable waterfrom high-elevation squares in valleys (completely enclosed by still higherelevation squares) to drain to lower elevation squares, and that water will notbe absorbed by the land. 	From weather data archives, we know the typical volume of water that collectsin a region. As prospective homebuyers, we wish to know the elevation of thewater after it has collected in low-lying squares, and also the percentage ofthe region's area that is completely submerged (that is, the percentage of10-meter squares whose elevation is strictly less than the water level). Youare to write the program that provides these results. 
题目输入：
	The input consists of a sequence of region descriptions.Each begins with a pair of integers, m and n, each less than 30,giving the dimensions of the rectangular region in 10-meter units. Immediatelyfollowing are m lines of n integers giving the elevations of thesquares in row-major order. Elevations are given in meters, with positive andnegative numbers representing elevations above and below sea level,respectively. The final value in each region description is an integer thatindicates the number of cubic meters of water that will collect in the region.A pair of zeroes follows the description of the last region. 
题目输出：
	For each region, display the region number (1, 2, ...),the water level (in meters above or below sea level) and the percentage of theregion's area under water, each on a separate line. The water level andpercentage of the region's area under water are to be displayed accurate to twofractional digits. Follow the output for each region with a blank line. 
输入样例：
3 3
25 37 45
51 12 34
94 83 27
10000
0 0

输出样例：
Region 1
Water level is 46.67 meters.
66.67 percent of the region is under water.

提示：
None



题目：纯净水(1228)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
        鱼儿子只喜欢喝纯净水，但是鱼头觉得这样对健康不好，他想让鱼儿子改喝矿泉水，鱼儿子不想喝矿泉水。于是鱼头对鱼儿子说：我们来做一个游戏，如果你赢了，就让你喝纯净水。        这个游戏当然和纯净水有关，鱼头会给鱼儿子两个杯子，容量分别为a毫升和b毫升（1<=a,b<=500），鱼儿子可以进行如下三种操作：                1. FILL(i)：将第i个杯子装满                2. DROP(i)：将第i个杯子倒空                3. POUR(i,j)：将第i个杯子中的水倒进第j个杯子。如果第i个杯子中的水较少（少于第j个杯子的剩余空间），则第i个杯子被倒空；否则第j个杯子被倒满，第i个杯子中剩余的水继续留在杯中。        鱼头给鱼儿子一个整数X，要求鱼儿子在X个操作内用两个杯子取到c(c>=0)毫升水（这些水必须装在一个杯子里），如果鱼儿子能取回，则鱼儿子赢了。当然，鱼头必须保证在X步内能完成任务，现在鱼头想让他的新队员帮助他编一个程序计算出最小的X（两个杯子最开始是空的，鱼头提供足够的纯净水给鱼儿子玩，并且鱼儿子在玩水的过程中不会把水洒出来）。
题目输入：
有多组输入数据，以文件尾结束，每组数据仅一行：三个整数a,b,c，意义如上。
题目输出：
对于每组输入，输出最小的X，如果该组测试数据无解，输出‘impossible’。
输入样例：
300 500 400
5 3 2
3 5 8
50 48 49

输出样例：
6
2
impossible
impossible

提示：
对于第一组数据，最快的方法为：FILL(2)，POUR(2,1)，DROP(1)，POUR(2,1)，FILL(2)，POUR(2,1)，至少需要6步。对于第二组数据，最快的方法为FILL(1)，POUR(1,2) ，至少需要2步。第三组显然要求的水量比杯子的容量大，不能满足。第四组，显然两个偶数容量的杯子不能取到奇数容量的水。



题目：106milestoChicago(1371)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
In the movie "Blues Brothers", the orphanage where Elwood and Jack were raised may be sold to the Board of Education if they do not pay 5000 dollars in taxes at the Cook Country Assessor's Office in Chicago. After playing a gig in the Palace Hotel ballroom to earn these 5000 dollars, they have to find a way to Chicago. However, this is not so easy as it sounds, since they are chased by the Police, a country band and a group of Nazis. Moreover, it is 106 miles to Chicago, it is dark and they are wearing sunglasses.As they are on a mission from God, you should help them find the safest way to Chicago. In this problem, the safest way is considered to be the route which maximises the probability that they are not caught.
题目输入：
The input file contains several test cases.
Each test case starts with two integers n and m (2 ≤ n ≤ 100 , 1 ≤ m ≤ n*(n-1)/2). n is the number of intersections, m is the number of streets to be considered.
The next m lines contain the description of the streets. Each street is described by a line containing 3 integers a, b and p (1 ≤ a, b ≤ n , a ≠ b, 1 ≤ p ≤ 100): a and b are the two end points of the street and p is the probability in percent that the Blues Brothers will manage to use this street without being caught. Each street can be used in both directions. You may assume that there is at most one street between two end points. 
The last test case is followed by a zero. 
题目输出：
For each test case, calculate the probability of the safest path from intersection 1 (the Palace Hotel) to intersection n (the Honorable Richard J. Daley Plaza in Chicago). You can assume that there is at least one path between intersection 1 and n.
Print the probability as a percentage with exactly 6 digits after the decimal point. The percentage value is considered correct if it differs by at most 10-6 from the judge output. Adhere to the format shown below and print one line for each test case. 
输入样例：
5 7
5 2 100
3 5 80
2 3 70
2 1 50
3 4 90
4 1 85
3 1 70
0

输出样例：
61.200000 percent

提示：
The safest path for the sample input is 1 -> 4 -> 3 -> 5



题目：迷宫问题(1024)
时间限制：1000 ms
空间限制：65535 kb
题目描述：
设计一个程序解决迷宫问题，迷宫中可通行的格子置为1，不可通行的格子置为0；由于此迷宫是由石头做成，所以只可以前后左右前进，要求：求出最短路径所经过的格子数，并将不可通行以及四周的格子置为’#’，最短路径置为’*’，剩余可通行格子置为’@’，并输出此矩阵,每个格子间用空格隔开,若有多条路径，输出最上面一条。若无可行路径，输出“no pace!”
题目输入：
第一行：迷宫的行和列（整数,n<=10）；（i,j）;接下来i行输入迷宫矩阵；接下来两行分别输入入口和出口的行与列。
题目输出：
第一行：最短路径格子数；接下来第i+2行输出经变动后的迷宫矩阵，并输出最短路径的每个格子的坐标；若无最短路径只输出”no pace!”
输入样例：
5 5
1 0 0 0 0
1 1 1 1 0
0 1 0 1 0
0 1 1 1 1
1 1 0 0 1
1 1
5 5
输出样例：
9
# # # # # # #
# * # # # # #
# * * * * # #
# # @ # * # #
# # @ @ * * #
# @ @ # # * #
# # # # # # #
(1,1)(2,1)(2,2)(2,3)(2,4)(3,4)(4,4)(4,5)(5,5)

提示：
None



题目：数据结构课！(1672)
时间限制：1000MS
空间限制：65535K
题目描述：
	现在是数据结构授课时间，有请Ttian123老师。“咳咳，大家好啊！今天我们来学习堆极其应用”Ttian123老师说道。Ttian老师说了：堆，是一种经过排序的树形数据结构，每个结点都有一个值，并且可以有两个子节点。堆可以分为最大堆和最小堆，其特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。堆的操作主要是添加，删除，和查询堆顶元素。在下面以最小堆为例讲解。	添加元素：将添加元素放入堆的最后，然后根据该节点与其父节点之间的大小关系调整位置，以维持最小堆性质。	删除元素：用当前堆中最后的元素填补被删除元素的的位置，在调整该结点与其父节点和两个子节点的关系，以保证满足最小堆行者。其中，如果该节点大于其子节点中的任意一个，则该节点与子节点中值最小的结点交换位置。	查询：查询堆中最小的元素，即根节点。	好了，大家都学会了吧。那么现在布置作业，首先规定：从根节点开始，从左到右,逐层向下，将结点依次编号1、2、3.......，现给大家一个已有n（n<100000）个结点的最小堆。按顺序给出各节点中的值。然后是一系列的添加删除操作，add x :加入值为x的结点。delete x:删除值为x的结点。（保证各结点的值不同）请大家给出每次操作后的堆。
题目输入：
	第一行：n ， m 堆中已有元素数和操作数	第二行：按顺序给出的n个元素，均为整数，所有整数都在int范围内。	接下来的是 m行操作。	输入以EOF结束。
题目输出：
	在每次操作以后，输出当前的堆！（注意，在数字之间有空格作为区分，不要输出多余的空格，每次查询后输出一个空行，具体见Sample Output）
输入样例：
5 4
1
2 3
4 5 
add 6
delete 3
delete 2
add 2 
输出样例：
1
2 3
4 5 6

1
2 6
4 5

1
4 6
5

1
2 6
5 4
提示：
None



题目：一排9(1777)
时间限制：1000ms
空间限制：131071kb
题目描述：
	一维世界里有一种叫做9的生物，9的基因是一个整数，它的名字等于它的基因模L。它们从左往右排成一排，每一天，排在最右边的9会分裂出一个新的9，新的9排在最右边。假设旧的9的基因是a，那么新分裂出来的9的基因是(a * 999 + 9)模65536的值。从一个9的位置向左到它或它之前的某个9，这一连串的9的名字连在一起将形成一个符卡。所以到第i天的时候，排在最右边的9能得到i个不同的符卡。如果这i个符卡中的某个符卡已经被之前的某个9得到，那么这个符卡对当前的这个9来说是没有效果的；否则就是有效的。第一天只有一个基因为Q的9，到第N天的时候，拥有有效符卡最多的9有多少符卡？
题目输入：
	多组数据，每组有三个数字L（1<=L<=1024）、Q（0<=Q<65536）、N（0<N<=10000）。以EOF结尾。
题目输出：
	对于每组输入数据输出一行一个数字，表示拥有最多符文的9的符文数。
输入样例：
3 3 3
1024 3 3
9 9 9
输出样例：
1
3
8
提示：
None



题目：BusinessCards(1126)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
	Running a paper shop is not an easy job, especially with harsh customers. Today they brought their own rectangular sheets of paper, asking you to cut it into rectangular business cards of specific size.Moreover, they require that all the paper (which may not be cheap, but is definitely not that expensive!) has to be used, i.e. no tiny bit may be left over. Moreover, the brilliant idea of cutting the sheet into very small pieces, and then gluing them together in desired sheets was laughed at.An example of a 9 *6 paper sheet divided into 2 * 3 cards is given below.	 	
题目输入：
The input contains several test cases. The first line contains the number of test cases t (t <= 10^5). Then t test cases follow. Each of them consists of one line containing four integers a, b, c, d (1 <=a, b, c, d <= 10^9).Numbers a and b are dimensions of each business card; c and d are dimensions of the paper sheet.
题目输出：
For each test case output one line containing word YES if it is possible to divide the whole sheet into business cards, and NO otherwise.
输入样例：
4
2 3 9 6
2 3 8 6
2 3 6 8
2 3 5 7
输出样例：
YES
YES
YES
NO
提示：
None



题目：CowTours(1473)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer John has a number of pastures on his farm. Cow paths connect some pastures with certain other pastures, forming a field. But, at the present time, you can find at least two pastures that cannot be connected by any sequence of cow paths, thus partitioning Farmer John's farm into multiple fields. Farmer John would like add a single a cow path between one pair of pastures using the constraints below. A field's `diameter' is defined to be the largest distance of all the shortest walks between any pair of pastures in the field. Consider the field below with five pastures, located at the points shown, and cow paths marked by lines:                 15,15   20,15                  D       E                  *-------*                  |     _/|                  |   _/  |                  | _/    |                  |/      |         *--------*-------*         A        B       C         10,10   15,10   20,10The `diameter' of this field is approximately 12.07106, since the longest of the set of shortest paths between pairs of pastures is the path from A to E (which includes the point set {A,B,E}). No other pair of pastures in this field is farther apart when connected by an optimal sequence of cow paths. Suppose another field on the same plane is connected by cow paths as follows:                          *F 30,15                         /                        _/                       _/                        /                         *------                    G      H                   25,10   30,10In the scenario of just two fields on his farm, Farmer John would add a cow path between a point in each of these two fields (namely point sets {A,B,C,D,E} and {F,G,H}) so that the joined set of pastures {A,B,C,D,E,F,G,H} has the smallest possible diameter. Note that cow paths do not connect just because they cross each other; they only connect at listed points. The input contains the pastures, their locations, and a symmetric "adjacency" matrix that tells whether pastures are connected by cow paths. Pastures are not considered to be connected to themselves. Here's one annotated adjacency list for the pasture {A,B,C,D,E,F,G,H} as shown above:                 A B C D E F G H              A 0 1 0 0 0 0 0 0              B 1 0 1 1 1 0 0 0              C 0 1 0 0 1 0 0 0              D 0 1 0 0 1 0 0 0              E 0 1 1 1 0 0 0 0              F 0 0 0 0 0 0 1 0              G 0 0 0 0 0 1 0 1              H 0 0 0 0 0 0 1 0Other equivalent adjacency lists might permute the rows and columns by using some order other than alphabetical to show the point connections. The input data contains no names for the points. The input will contain at least two pastures that are not connected by any sequence of cow paths. Find a way to connect exactly two pastures in the input with a cow path so that the new combined field has the smallest possible diameter of any possible pair of connected pastures. Output that smallest possible diameter.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  An integer, N (1 <= N <= 150), the number of pastures  Line 2-N+1:  Two integers, X and Y (0 <= X ,Y<= 100000), that denote that X,Y grid location of the pastures; all input pastures are unique.  Line N+2-2*N+1:  lines, each containing N digits (0 or 1) that represent the adjacency matrix as described above, where the rows' and columns' indices are in order of the points just listed.
题目输出：
810 1015 1020 1015 1520 1530 1525 1030 100100000010111000010010000100100001110000000000100000010100000010
输入样例：
The output consists of a single line with the diameter of the newly joined pastures. Print the answer to exactly six decimal places. Do not perform any special rounding on your output.
输出样例：
22.071068
提示：




题目：Decoratethewall(1372)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
After building his huge villa, Mr. Rich cannot help but notice that the interior walls look rather blank. To change that, he starts to hang paintings from his wonderful collection. But soon he realizes that it becomes quite difficult to find a place on the wall where a painting can be placed without overlapping other paintings. Now he needs a program which would tell him, given the already placed paintings, where to place the next painting without moving any other paintings (or indicating that this is impossible). Paintings have a rectangular shape and are to be placed parallel to the side of the wall. If you do not mind a nice reward from Mr. Rich, go on and solve the problem.
题目输入：
The first line of the input file contains a number representing the number of test cases to follow. Each test case starts with a line containing three numbers n, w and h. n is the number of paintings already hanging on the wall, w is the width of the wall and h is the height of the wall. The next n lines contain 4 integers x1, y1, x2, y2 each (0 ≤ x1 < x2 ≤ w, 0 ≤ y1 < y2 ≤ h); the x-coordinates give the distance to the left end of the wall, the y-coordinates give the distance to the bottom of the wall. (x1, y1) is the position of the lower left corner of a painting, (x2, y2) is the position of the upper right corner. The last line of each test case contains the dimensions of the next painting to be placed, first its width w', then its height h' (1 ≤ w' ≤ w, 1 ≤ h' ≤ h). You are not allowed to rotate the painting. 
You can assume that 0 ≤ n ≤ 200 and 1 ≤ w, h ≤ 1000000. Moreover, all paintings already hanging do not overlap. 
题目输出：
Produce one line of output for each test case. Write "Fail!" if there is no place left on the wall where the painting could be placed without overlapping other paintings. Otherwise, write the coordinates where the lower left corner of the painting should be placed. In case there is more than one solution, select the solution with a minimum y-coordinate, and break ties using the minimum x-coordinate.
输入样例：
2
1 10 9
5 4 10 9
9 5
2 10 10
5 5 10 10
0 0 4 3
3 4

输出样例：
Fail!
4 0

提示：




题目：为什么要用笔算呢？(1229)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
        话说我们的女生部长hdd同学计算能力非常差，经常连简单的加减乘除都会算错。上小学的时候hdd就经常因为把三角的面积算错而被老师罚站，后来有学了圆，扇形，弓形，矩形等复杂的图形，使得hdd苦不堪言。于是hdd决心进入计算机专业来减轻他的痛苦。        但是hdd没想到，虽然学会编程后能解决许多简单的计算，但是又会面对更多复杂的问题，hdd上高数的时候还是会经常被老师罚站。这次hdd需要计算两个圆的公共面积，他又算不出来了，于是找你求救。
题目输入：
多组输入数据，每组数据占一行，每行有六个浮点数，x1,y1,r1，x2,y2,r2，分别为两个圆的横坐标，纵坐标，半径，|x|<1000,|y|<1000,r>0。
题目输出：
一个整数：两个圆的公共面积，精确到小数点后3位。
输入样例：
0 0 1 1 1 1
0 0 1 1 0 1
766.428428 -412.317317 196.921437 -519.124124 -783.128128 1141.041950

输出样例：
0.571
1.228
0.000

提示：
    以下hint只有女生能看
    作为一位资深的女生部长，hdd想提醒他亲爱的学妹们注意不要输出-0.000这种数据



题目：Abbott’sRevenge(1572)
时间限制：10000 ms
空间限制：65535 ms
题目描述：
 	The 1999 World Finals Contest included a problem based on a “dice maze.”At the time the problem was written, the judges were unable to discover theoriginal source of the dice maze concept. Shortly after the contest, however,Mr. Robert Abbott, the creator of numerous mazes and an author on the subject,contacted the contest judges and identified himself as the originator of dicemazes. We regret that we did not credit Mr. Abbott for his original concept inlast year’s problem statement. But we are happy to report that Mr. Abbott hasoffered his expertise to this year’s contest with his original and unpublished“walk-through arrow mazes.”    	As are most mazes, a walk-through arrow maze is traversed by moving fromintersection to intersection until the goal intersection is reached. As eachintersection is approached from a given direction, a sign near the entry to theintersection indicates in which directions the intersection can be exited.These directions are always left, forward or right, or any combination ofthese.    	    	Figure 1 illustrates a walk-through arrow maze. The intersections areidentified as “(row, column)” pairs, with the upper left being (1,1). The“Entrance” intersection for Figure 1 is (3,1), and the “Goal” intersection is(3,3). You begin the maze by moving north from (3,1). As you walk from (3,1) to(2,1), the sign at (2,1) indicates that as you approach (2,1) from the south(traveling north) you may continue to go only forward. Continuing forward takesyou toward (1,1). The sign at (1,1) as you approach from the south indicatesthat you may exit (1,1) only by making a right. This turns you to the east nowwalking from (1,1) toward (1,2). So far there have been no choices to be made.This is also the case as you continue to move from (1,2) to (2,2) to (2,3) to(1,3). Now, however, as you move west from (1,3) toward (1,2), you have theoption of continuing straight or turning left. Continuing straight would takeyou on toward (1,1), while turning left would take you south to (2,2). Theactual (unique) solution to this maze is the following sequence ofintersections: (3,1) (2,1) (1,1) (1,2) (2,2) (2,3) (1,3) (1,2) (1,1) (2,1)(2,2) (1,2) (1,3) (2,3) (3,3).   You must write a program to solve valid walk-througharrow mazes. Solving a maze means (if possible) finding a route through themaze that leaves the Entrance in the prescribed direction, and ends in theGoal. This route should not be longer than necessary, of course. But if thereare several solutions which are equally long, you can chose any of them.
题目输入：
 	The input file will consist of one or more arrow mazes. The first line ofeach maze description contains the name of the maze, which is an alphanumeric stringof no more than 20 characters. The next line contains, in the following order,the starting row, the starting column, the starting direction, the goal row,and finally the goal column. All are delimited by a single space. The maximumdimensions of a maze for this problem are 9 by 9, so all row and column numbersare single digits from 1 to 9. The starting direction is one of the charactersN, S, E or W, indicating north, south, east and west, respectively.    	All remaining input lines for a maze have this format: two integers, oneor more groups of characters, and a sentinel asterisk, again all delimited by asingle space. The integers represent the row and column, respectively, of amaze intersection. Each character group represents a sign at that intersection.The first character in the group is N, S, E or W to indicate in what directionof travel the sign would be seen. For example, S indicates that this is thesign that is seen when travelling south. (This is the sign posted at the northentrance to the intersection.) Following this first direction character are oneto three arrow characters. These can be L, F or R indicating left, forward, andright, respectively.   The list of intersections is concluded by a linecontaining a single zero in the first column. The next line of the input startsthe next maze, and so on. The end of input is the word END on a single line byitself.
题目输出：
 	For each maze, the output file should contain a line with the name of themaze, followed by one or more lines with either a solution to the maze or thephrase “No Solution Possible”. Maze names should start in column 1, and allother lines should start in column 3, i.e., indented two spaces. Solutionsshould be output as a list of intersections in the format “(R,C)” in the orderthey are visited from the start to the goal, should be delimited by a singlespace, and all but the last line of the solution should contain exactly 10intersections.   The first maze in the following sample input is themaze in Figure 1.
输入样例：
SAMPLE
3 1 N 3 3
1 1 WL NR *
1 2 WLF NR ER *
1 3 NL ER *
2 1 SL WR NF *
2 2 SL WF ELF *
2 3 SFR EL *
0
NOSOLUTION
3 1 N 3 2
1 1 WL NR *
1 2 NL ER *
2 1 SL WR NFR *
2 2 SR EL *
0
END

输出样例：
SAMPLE
  (3,1) (2,1) (1,1) (1,2) (2,2) (2,3) (1,3) (1,2) (1,1) (2,1)
  (2,2) (1,2) (1,3) (2,3) (3,3)
NOSOLUTION
  No Solution Possible

提示：
None



题目：中缀表达式(1025)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
计算中缀表达式(式子中可以有+，-，*，/，括号()),按等号结束，若为非法表达式输出error!。注意有多组数据。
题目输入：
要计算的表达式。
题目输出：
计算结果(整数)。
输入样例：
23+54*4/(43-3*13)-7=
输出样例：
70
提示：
None



题目：BessieComeHome(1474)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
It's dinner time, and the cows are out in their separate pastures. Farmer John rings the bell so they will start walking to the barn. Your job is to figure out which one cow gets to the barn first (the supplied test data will always have exactly one fastest cow). Between milkings, each cow is located in her own pasture, though some pastures have no cows in them. Each pasture is connected by a path to one or more other pastures (potentially including itself). Sometimes, two (potentially self-same) pastures are connected by more than one path. One or more of the pastures has a path to the barn. Thus, all cows have a path to the barn and they always know the shortest path. Of course, cows can go either direction on a path and they all walk at the same speed. The pastures are labeled `a'..`z' and `A'..`Y'. One cow is in each pasture labeled with a capital letter. No cow is in a pasture labeled with a lower case letter. The barn's label is `Z'; no cows are in the barn, though.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  Integer P (1 <= P <= 10000) the number of paths that interconnect the pastures (and the barn)  Line 2..P+1:  Space separated, two letters and an integer: the names of the interconnected pastures/barn and the distance between them (1 <= distance <= 1000)
题目输出：
5A d 6B d 3C e 9d Z 8e Z 3
输入样例：
A single line containing two items: the capital letter name of the pasture of the cow that arrives first back at the barn, the length of the path followed by that cow.
输出样例：
B 11
提示：




题目：小丁丁学网络(1778)
时间限制：5000s
空间限制：128M
题目描述：
	最近小丁丁在研究计算机网络的协议。他想自己建立一种新的协议。小丁丁是一个想做就做的人，所以他就开始着手设计了。期间，他遇到了一些关于数据包压缩和MTU的问题。	最大传输单元（Maximum Transmission Unit，MTU）是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）。因特网协议允许IP分片，这样就可以将数据报分成足够小的片段以通过那些最大传输单元小于该数据报原始大小的链路了。这一分片过程发生在 IP 层（OSI模型的第三层，即网络层），它使用的是将分组发送到链路上的网络接口的最大传输单元的值。原始分组的分片都被加上了标记，这样目的主机的 IP 层就能将分组重组成原始的数据报了。在因特网协议中，一条因特网传输路径的“路径最大传输单元”被定义为从源地址到目的地址所经过“路径”上的所有IP跳的最大传输单元的最小值。或者从另外一个角度来看，就是无需进一步分片就能穿过这条“路径”的最大传输单元的最大值。	在小丁丁的协议中，一个数据包是只包含小写字母的字符串。由于网络MTU的限制，一个字符串不能太大。所以小丁丁的协议中将这一个字符串分割成了若干个小串。小丁丁是一个追求卓越的人。仅仅将字符串切割远不能满足他的要求。在切分字符串的时候他还同时想将字符串进行压缩。压缩用的是一个很奇葩的方法。每个字符串S被分割成s[1],s[2]...s[n]，这些被分割的字符串包含小写字母和数字。字母就是原字符串S中的部分内容。数字表示这个地方在解压缩的时候由序号为这个数字的子串替换。比如s[1]=”abc2”，这个2表示由s[2]替换。为了保证正确性，s[i]子串中，数字只能为i+1到N。为了满足MTU的限制，所以每个子串的长度必须不大于limit[i]。这种压缩算法毕竟只是小丁丁在吃饭的时候无意中想的，所以可行性有待验证。所以想请你帮忙写个程序来检验一下，对于一个长字符串S，是否存在可行的按照上述要求的，符合长度限制的切分方案。也就是说，按照上述过程的逆过程，能将这些子字符串还原成原字符串。
题目输入：
	多组数据，对于每组数据:	第一行N，1 ≤ N ≤ 6，表示子串的个数。	第二行N个数，表示对应子串的长度限制limit[i]，1 ≤ limit[i] ≤ 6。	第三行一个字符串，表示原字符串。最后以EOF结尾。
题目输出：
	如果存在这样的切分方案，输出“Yes”，否则“No”
输入样例：
1
1
abcdefg
4
4 4 4 4
abcdefg

输出样例：
No
Yes

提示：
None



题目：DivisibleSubsequences(1127)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	Given a sequence of positive integers,  count all contiguous  subsequences (sometimes called substrings, in contrast to subsequences, which may leave out elements)  the sum of which is divisible by a given number.  These subsequences  may overlap.  For example,  the sequence (see sample input)	2, 1, 2, 1, 1, 2, 1, 2	contains  six contiguous  subsequences the sum of which is divisible by four: the first to eighth number, the second to fourth  number,  the second to seventh  number,  the third  to fifth number,  the fourth  to sixth  number,  and the fifth to seventh  number.
题目输入：
The  first line of the  input  consists  of an integer  c (1 ≤ c ≤ 200), the  number  of test cases.  Then follow two lines per test  case.Each  test  case starts with  a line consisting  of two  integers  d (1 ≤ d ≤ 1 000 000) and  n (1 ≤ n ≤50 000), the divisor of the sum of the subsequences  and the length  of the sequence, respectively.  The second line of a test  case contains  the  elements  of the  sequence,  which are integers  between  1 and1 000 000 000, inclusively.
题目输出：
For each test case, print a single line consisting of a single integer, the number of contiguous subse-quences the sum of which is divisible by d.
输入样例：
2
7 3
1 2 3
4 8
2 1 2 1 1 2 1 2
输出样例：
0
6
提示：
None



题目：谁是冠军？(1673)
时间限制：2000ms
空间限制：65535K
题目描述：
有n个人赛跑，编号为1-n。小明没有去看比赛，但他通过询问m个人，了解到一些情况。这些人都告诉他xi比yi跑的快。问小明能否知道谁得了冠军。
题目输入：
	第一行：n,m;分别表示n个人赛跑，询问了m个人；(0<n,m<=100)	下面m行第i行：xi yi，表示第i人回答是xi比yi跑的快
题目输出：
	情况1：询问中出现了矛盾的情况，输出：第一个出现矛盾的人的编号m‘和impossible.	情况2：若没有矛盾，问道第几（m'）人时就可以判断出谁（n'）得了冠军。输出 m’，n’。	情况3：最终也不能判断谁得了冠军，输出：-1.
输入样例：
4 3
2 1 1 3 3 4
4 3
1 2 2 3 1 3
4 3
1 2 2 3 3 1

输出样例：
Case 1:
3 2
Case 2:
-1
Case 3:
3 impossible

提示：
None



题目：迷宫中的最少步数(1026)
时间限制：5000 ms
空间限制：65535 kb
题目描述：
约定：起点用字符‘2’表示，不能走的地方用字符‘1’表示，能走的则用‘0’表示。处理后称之为 迷宫“012”图  。迷宫最多99行99列；输入以‘！’结束
题目输入：
测试直到文件尾
题目输出：
最短步数；(如果有路径)silu(如果没有路径 输出：）
输入样例：
21111
10111
11011
11101
！
输出样例：
The least step is:3
提示：
None



题目：Europeanrailroadtracks(1373)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
As you may already know, different countries in Europe use different railroad systems. Not only do they use different voltages for their trains, but also the distance between the two rails (gauge) differs. The following table shows some railway gauges used: 




Broad gauge (Spain):
1674 mm

Broad gauge (Portugal):
1665 mm

Broad gauge (Ireland):
1600 mm

Broad gauge (Finland):
1524 mm

Broad gauge (former USSR):
1520 mm

Standard gauge:
1435 mm

Narrow gauge (meter gauge):
1000 mm
A museum has trains from several countries. It needs tracks for every train type in order to show visitors the trains in use. However, since only one train is used at a time, a rail can be used by trains of different types. It follows that for n trains, each requiring a different railway gauge, n + 1 rails are sufficient (each train uses the leftmost rail and a rail that has exactly the required distance to it). But sometimes it is possible to save even more rails.Given the required railway gauges, your task is to construct a railway track that can be used by every train and requires the least number of rails. Note that a train can use any two rails, provided the distance between them is right.
题目输入：
The first line of the input file contains a number representing the number of test cases to follow. Each test case starts with an integer n (the number of different railway gauges required). The next line contains n integers between 1000 and 5000, each defining one required railway gauge.
You can assume that 1 ≤ n ≤ 8. Moreover, for every test case in the input file, there will be a solution requiring at most 5 rails.
题目输出：
The output for each test case consists of three lines:
The first line is of the form "Scenario #X", where X is the test case number starting with 1. The second line describes the solution your program has found; first your program should print how many rails are needed, followed by a colon, then the positions of each rail in increasing order (the first rail should be at position 0). The third line should be blank. If there are several solutions with the minimum number of rails, any one will do.
输入样例：
3
4
1524 1520 1609 1435
3
1000 1520 1600
6
1000 2000 3000 4000 1500 2500

输出样例：
Scenario #1
4: 0 1520 1609 3044

Scenario #2
4: 0 1000 1520 1600

Scenario #3
5: 0 1500 3000 4000 5000

提示：




题目：AccordingtoBartjens(1573)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	The widedissemination of calculators and computers has its disadvantages. Even studentsin technical disciplines tend to exhibit a surprising lack of calculatingability. Accustomed to the use of calculators and computers, many of them areunable to make calculations like 7 * 8 mentally or like 13 * 17 using penciland paper. We all know, but who cares?	Professor Bartjenscares. Professor Bartjens is a bit old fashioned. He decided to give hisstudents some training in calculating without electronic equipment by creatinga collection of calculation problems, (like 2100 - 100 = ...). To simplifygrading the problems, he constructed them so that almost all of them had 2000as an answer. Not all of them, of course. His students would be smart enough torecognize the pattern, and fill in 2000 everywhere without further thinking.	UnfortunatelyProfessor Bartjens’ printer driver turned out to be even more old-fashionedthan the professor himself, and it could not interface with his new printer.Inspecting the printed problems, he soon recognized the pattern: none of theoperations was transmitted to the printer. A problem like: 2100-100= was printed as: 2100100= Fortunately, all the digits and the equal sign were still printed.	To make this badsituation much worse, Professor Bartjens’ source file had disappeared. SoProfessor Bartjens has another problem: what were his original problems? Giventhe fact that the answer (most likely) should be 2000, the line 2100100= couldhave been any one of the lines: 	2100-100=2*100*10+0=2*100*10-0=2*10*0100=2*-100*-10+0=	Professor Bartjensdoes remember a few things about how he wrote the problems:			He is sure that whenever he wrote down a number     (other than 0), it would not start with a zero. So 2*10*0100= could not     have been one of his problems.				He also knows he never wrote the number zero as     anything but 0. So he would not have a problem like 2*1000+000=.				He used only binary operators, not the unary     minus or plus, so 2*-100*-10+0= was not an option either.				He used the operators +, - and * only, avoiding     the operator / (after all, they were first year students).				He knew all problems followed the usual     precedence and associativity rules.		You are to help Professor Bartjens recover his problem set by writing aprogram that when given a row of digits, insert one or more of the operators +,- and * in such a way that the value of the resulting expression equals 2000.
题目输入：
	The input consistsof one or more test cases. Each test case is a single line containing n digits('0'–'9'), 1 ≤n ≤9, followed by an equal sign. There will not be any blanksembedded in the input, but there may be some after the equal sign.	The last test caseis followed by a line containing only the equal sign. This line should not beprocessed.
题目输出：
	For each testcase, print the word Problem, then the number of the case, then all possibleways of inserting operators in the row of digits such that the resultingexpression has the value 2000, subject to Professor Bartjens’ memory of how hewrote the problems. Use the format shown below. If there is more than onepossible problem, write the problems in lexicographic order. Each possibleproblem should be on a new line, indented 2 spaces. If there is no solution theanswer IMPOSSIBLE should be printed, indented 2 spaces.
输入样例：
2100100=
77=
=

输出样例：
Problem 1
  2*100*10+0=
  2*100*10-0=
  2100-100=
Problem 2
  IMPOSSIBLE

提示：
None



题目：xiaoyoulei_code(1230)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
尤利乌斯·凯撒生活在一个充满战争与阴谋的时代，敌人们在他身边安插了无数间谍，时刻监视着他的一举一动。为了让自己的军事部署不被泄露，凯撒发明了一套密码用来与自己的将军们通信。
凯撒密码的加密方式如下：首先将原文中的每个字母改写为字母表中在其之后的第N个字母，若超出了字母表的范围则回到字母‘a’继续计数。比如N=1时就把原文中的‘a’全部改写为‘b’，‘b’改写为‘c’……而把‘z’改写为‘a’。完成这一步后，再将此时密文中所有的字符向后推M位（最后的M个字符放到开头），加密工作就完成了。现在给出N、M和密文，请你还原出加密前的原文
                                                         
 
题目输入：
输入数据有多组，每组数据的第一行给出N和M（|N|，|M|<=10），之后一行给出加密后的文本，密文仅含大小写英文字母以及空格‘ ’、逗号‘,’、句号‘.’这三种字符。数据保证加密前原文以字母开头，以句号结束,长度不超过100个字符。
题目输出：
每组数据输出一行解密后得到的原文，输出时要求答案中每句话（以句号为结束符）的第一个字母大写，其余所有字母小写。
输入样例：
2 2
U.Kp yct, gxgpvu qh korqtvcpeg ctg vjg tguwnv qh vtkxkcn ecwug

输出样例：
In war, events of importance are the result of trivial causes.
提示：




题目：FractionstoDecimals(1475)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Write a program that will accept a fraction of the form N/D, where N is the numerator and D is the denominator and print the decimal representation. If the decimal representation has a repeating sequence of digits, indicate the sequence by enclosing it in brackets. For example, 1/3 = .33333333...is denoted as 0.(3), and 41/333 = 0.123123123...is denoted as 0.(123). Use xxx.0 to denote an integer. Typical conversions are: 1/3     =  0.(3)22/5    =  4.41/7     =  0.(142857)2/2     =  1.03/8     =  0.37545/56   =  0.803(571428)
题目输入：
There are several test cases, end by EOF, for each test case:A single line with two space separated integers, N and D, 1 <= N,D <= 100000.
题目输出：
The decimal expansion, as detailed above. If the expansion exceeds 76 characters in length, print it on multiple lines with 76 characters per line.
输入样例：
45 56
输出样例：
0.803(571428)
提示：




题目：吃零食(1674)
时间限制：1000MS
空间限制：65535K
题目描述：
	coldsheep 最近吃东西越来越多，所以决定减肥.为了实施减肥计划，所以每天吃零食的数目越来越少。但是不想减的太快，这样太忧伤了。所以制定了一个计划，是由一个二维数组构成。数组的每个数字代表零食的数目。下面是一个例子 	 1  2   3   4  5	16 17 18 19 6	15 24 25 20 7	14 23 22 21 8	13 12 11 10 9	当然选取零食数目只能由当前点像上下左右四个方向延伸。那么零食的数目可以为24-17-16-1。当然25-24-23-...-3-2-1更长。事实上，这是最长的一条。
题目输入：
	多组测试数据，以EOF结束。	输入的第一行表示区域的行数R和列数C(1 <= R,C <= 100)。下面是R行，每行有C个整数，代表数目h，0<=h<=10000。
题目输出：
	输出最长区域的长度。
输入样例：
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9

输出样例：
25

提示：




题目：Fractal(1128)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	Fractals are  really  cool mathematical objects.   They  have  a lot  of interesting properties, often  including:	• fine structure at arbitrarily small scales;	• self-similarity,  i.e., magnified it looks like a copy of itself;	• a simple, recursive definition.	Approximate fractals  are found a lot in nature, for example, in structures such as clouds, snow flakes, mountain ranges,  and river networks.				In this problem,  we consider fractals  generated by the following algorithm:  we start with a polyline, i.e.,  a  set of connected  line segments.    This  is what  we call a  fractal  of depth  one (see  leftmost picture). To obtain  a fractal  of depth  two, we replace  each line segment with  a scaled and  rotated version of the original polyline (see middle picture). By repetitively replacing the line segments with the  polyline,  we obtain  fractals  of arbitrary depth  and  very  fine structures arise.   The  rightmost picture  shows a fractal  of depth  three.	The complexity  of an approximate fractal  increases quickly as its depth  increases.  We want to know where we end up after  traversing a certain  fraction  of its length.	 
题目输入：
The  input  starts with a single number  c (1 ≤ c ≤ 200) on one line, the  number  of test  cases.  Then each test  case starts with one line with n (3 ≤ n ≤ 100), the number  of points  of the polyline.  Then follow n lines with  on the  ith  line two integers  xi and  yi  (−1 000 ≤ xi , yi  ≤ 1 000), the  consecutive points  of the polyline.  Next follows one line with an integer  d (1 ≤ d ≤ 10), the depth  of the fractal. Finally,  there  is one line with a floating point number  f (0 ≤ f ≤ 1), the fraction  of the length  that is traversed.The  length  of each line segment of the  polyline is smaller  than  the  distance  between  the  first point (x1 , y1 ) and  the  last  point  (xn , yn ) of the  polyline.   The  length  of the  complete  polyline is smaller than  twice this distance.
题目输出：
Per test case, the output contains  one line with the coordinate  where we end up.  Format it as (x,y), with two floating point numbers  x and y. The absolute  error in both  coordinates  should be smaller than  10^(-6).
输入样例：
1
4
-2 -2
0 0
0 2
2 2
3
0.75

输出样例：
(0.4267766953,2)
提示：
None



题目：Comedi方程(1779)
时间限制：1500ms
空间限制：65535kb
题目描述：
	请求出方程x^k≡0(mod n)在1<=x<=n的情况下解的个数（x^k表示x的k次方，下同）。
题目输入：
	输入以EOF结束，每行两个整数n和k,其中（1<n<=2^63, 1<k<=100)。
题目输出：
	每行一个整数，方程的解的个数。
输入样例：
4 2

输出样例：
2

提示：
unsigned long long 使用%llu读入



题目：Anyfoolcandoit(1374)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Surely you know someone who thinks he is very clever. You decide to let him down with the following problem:

"Can you tell me what the syntax for a set is?", you ask him. 
"Sure!", he replies, "a set encloses a possibly empty list of elements within two curly braces. Each element is either another set or a letter of the given alphabet. Elements in a list are separated by a comma." 
"So if I give you a word, can you tell me if it is a syntactically correct representation of a set?" 
"Of course, any fool can do it!" is his answer. Now you got him! You present him with the following grammar, defining formally the syntax for a set (which was described informally by him): Set          ::= "{" Elementlist "}"
Elementlist  ::= <empty> | List
List         ::= Element | Element "," List
Element      ::= Atom | Set
Atom         ::= "{" | "}" | ","
<empty> stands for the empty word, i.e., the list in a set can be empty.Soon he realizes that this task is much harder than he has thought, since the alphabet consists of the characters which are also used for the syntax of the set. So he claims that it is not possible to decide efficiently if a word consisting of "{", "}" and "," is a syntactically correct representation of a set or not.To disprove him, you need to write an efficient program that will decide this problem.
题目输入：
The first line of the input file contains a number representing the number of lines to follow. 
Each line consists of a word, for which your program has to decide if it is a syntactically correct representation of a set. You may assume that each word consists of between 1 and 200 characters from the set { "{", "}", "," }.
题目输出：
Output for each test case whether the word is a set or not. Adhere to the format shown in the sample output.
输入样例：
4
{}
{{}}
{{}},{,}}
{,,}

输出样例：
Word #1: Set
Word #2: Set
Word #3: Set
Word #4: No Set

提示：




题目：中缀表达式的计算(1027)
时间限制：1000 ms
空间限制：65535 kb
题目描述：
你随意的输入一个合法的中缀运算式，得到它的结果。中缀运算式可以由 ‘数字’ ‘+’ ‘-’  ‘/’ ‘*’ ‘（’ ‘）’ ‘=’组成；小括号只要合法，可以嵌套如“(  (  )  ) ,  (  (  )  (  )  )”；数字是int 型；范围是int 的范围；
题目输入：
表达式
题目输出：
结果
输入样例：
15+10*(40-30/(12-10+3)*2*(66-63))+9=
输出样例：
64
提示：
None



题目：票(1231)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
       回家，火车票是个很纠结的问题。。。嗯。火车站有M个窗口在卖票，丫的，竟然有N个人在买票。（N应该是远远大于M的），然而每个人买票的时间明显不一致。给你一个每个人买票的时间的期望，让你安排，使得每人购买到票的时间总和最小。（时间总和保证不超过int的范围）
题目输入：
第一行:一个整数N和一个整数M.
第二行:N个整数，即每个人买票时间的期望En (M<=N,且N是不超过100000的正整数)
题目输出：
一行：每个人买到票的时间总和的最小值
输入样例：
7  3
5 3 3 6 7 1 2
输出样例：
37
提示：




题目：InternetBandwidth(1574)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	On the Internet, machines (nodes) are richly interconnected, and manypaths may exist between a given pair of nodes. The total message-carryingcapacity (bandwidth) between two given nodes is the maximal amount of data perunit time that can be transmitted from one node to the other. Using a techniquecalled packet switching, this data can be transmitted along several paths atthe same time. 	For example, the following figure shows a network withfour nodes (shown as circles), with a total of five connections among them.Every connection is labeled with a bandwidth that represents its data-carryingcapacity per unit time. 		 			In our example, the bandwidth between node 1 and node 4 is 25, which mightbe thought of as the sum of the bandwidths 10 along the path 1-2-4, 10 alongthe path 1-3-4, and 5 along the path 1-2-3-4. No other combination of pathsbetween nodes 1 and 4 provides a larger bandwidth.  	You must write a program that computes the bandwidthbetween two given nodes in a network, given the individual bandwidths of allthe connections in the network. In this problem, assume that the bandwidth of aconnection is always the same in both directions (which is not necessarily truein the real world). 				
题目输入：
	The input file contains descriptions of several networks. Everydescription starts with a line containing a single integer n (2 ≤n ≤1000), whichis the number of nodes in the network. The nodes are numbered from 1 to n. Thenext line contains three numbers s, t, and c. The numbers s and t are thesource and destination nodes, and the number c is the total number ofconnections in the network. Following this are c lines describing theconnections. Each of these lines contains three integers: the first two are thenumbers of the connected nodes, and the third number is the bandwidth of theconnection. The bandwidth is a non-negative number not greater than 1000. 	There might be more than one connection between a pair of nodes, but anode cannot be connected to itself. All connections are bi-directional, i.e.data can be transmitted in both directions along a connection, but the sum ofthe amount of data transmitted in both directions must be less than thebandwidth. 	A line containing the number 0 follows the last network description, andterminates the input. 
题目输出：
	For each network description, first print the number of the network. Thenprint the total bandwidth between the source node s and the destination node t,following the format of the sample output. Print a blank line after each testcase. 
输入样例：
4
1 4 5
1 2 20
1 3 10
2 3 5
2 4 10
3 4 20
0

输出样例：
Network 1
The bandwidth is 25.

提示：
None



题目：Agri-Net(1476)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer John has been elected mayor of his town! One of his campaign promises was to bring internet connectivity to all farms in the area. He needs your help, of course. Farmer John ordered a high speed connection for his farm and is going to share his connectivity with the other farmers. To minimize cost, he wants to lay the minimum amount of optical fiber to connect his farm to all the other farms. Given a list of how much fiber it takes to connect each pair of farms, you must find the minimum amount of fiber needed to connect them all together. Each farm must connect to some other farm such that a packet can flow from any one farm to any other farm. The distance between any two farms will not exceed 100,000.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  The number of farms, N (3 <= N <= 100).  Line 2..end:  The subsequent lines contain the N x N connectivity matrix, where each element shows the distance from on farm to another. Logically, they are N lines of N space-separated integers. Physically, they are limited in length to 80 characters, so some lines continue onto others. Of course, the diagonal will be 0, since the distance from farm i to itself is not interesting for this problem.
题目输出：
The single output contains the integer length that is the sum of the minimum length of fiber required to connect the entire set of farms.
输入样例：
4
0 4 9 21
4 0 8 17
9 8 0 16
21 17 16 0
输出样例：
28
提示：




题目：JUMP(1675)
时间限制：1000MS
空间限制：65535K
题目描述：
	Andfive很喜欢玩跳跳游戏，游戏规则是这个样子的：玩家站在0点位置，他可以向前跳或者向后跳。第一次，从0点开始跳，到达距离0点为1的位置，第二次，从上一位置开始跳，到达距离上一位置为2的位置.......第k次，从上一位置开始跳，到达距离上一位置为k的位置。	Andfive想跳到n位置，但是他的脚受伤了，现在求助聪明的你。请问要跳到n位置，最少跳几次。
题目输入：
	每行输入一个整数n（-10^9<n<10^9）。
题目输出：
	输出到达n位置，最少跳的次数。
输入样例：
2
6
输出样例：
3
3

提示：
None



题目：MountainRoad(1129)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
In the  Franconian Switzerland, there  is a narrow  mountain road.  With  only a single lane, this  is a bottleneck for two-way traffic.  Your job is to schedule  incoming  cars at  both  ends so that the  last car leaves the road as early as possible.Each  car  is specified by  three  values:   the  direction  in  which  it  is going,  the  arrival  time  at  the corresponding  beginning  of the road, and the driving time this car needs to get through, provided  it is not  slowed down by other  cars in front.  Cars  cannot  overtake  each other  on the  mountain road, and reordering  cars in the queues at the ends of the road is not allowed.For  safety  reasons,  two  successive cars  going in the  same  direction  may  not  pass  any  point  of the road within  less than  10 seconds.  This ensures that the second car will not crash into the first car if the  latter brakes  hard.   However, if another  car passes in the  other  direction  in between,  it will be clear that the road is empty,  so in this case, this rule does not apply.
题目输入：
The first line of the input consists of a single integer  c (1 ≤ c ≤ 200), the number  of test  cases.Then follow the test  cases, each beginning with a single line consisting of an integer n (1 ≤ n ≤ 200), the number  of cars you are to consider in this test  case.  The remainder of each test  case consists of n lines, one line per car,  starting with  a single upper  case letter  (“A” or “B”), giving the  direction in which the  car  is going.  Then  follow, on the  same  line, two  integers  t (0 ≤ t ≤ 100 000) and  d (1 ≤ d ≤ 100 000), giving the arrival  time at the beginning of the road and the minimum  travel  time, respectively,  both  in seconds.Within  a test  case, the cars are given in order of increasing  arrival  time,  and no two cars will arrive at the same time.
题目输出：
For each test  case, print a single line consisting  of the  point in time  (in seconds) the last  car leaves the road when the cars are scheduled  optimally.
输入样例：
2
4
A 0 60
B 19 10
B 80 20
A 85 100
4
A 0 100
B 50 100
A 100 1
A 170 100

输出样例：
200
270

提示：
None



题目：Comedi函数(1780)
时间限制：2000ms
空间限制：65535kb
题目描述：
	已知一常N-1维向量A=(a1,a2,a3……an-1)，Comedi函数定义如下：Y=f(X)，其中X，Y都是N-1维向量，X=(x1,x2,x3……xn-1)，Y=(y1,y2,y3……yn-1)，并且yi=(xi*ai)%N。称Y=f(X)为一次迭代，Y=f(f(x))为两次迭代……。	现在，给定N（N为奇素数），向量A，以及目标向量Y（y1,y2,y3,……yn-1)。请问向量X=（1,1,1……）是否能够经过有限次迭代得到向量Y？如果可以，请输出最少经过多少次迭代。如果不可能，请输出-1。
题目输入：
	共有多组数据，每组数据含有三行，第一行：一个整数N。第二行N-1个整数代表a1,a2……an-1。第三行N-1个整数代表y1,y2……yn-1。第二、三行的整数范围在[1,N-1]。相互之间可能相同。其中n的范围是(1, 30000)               
题目输出：
	一个整数，表示最小迭代步数，如果不可能，请输出-1。
输入样例：
5
1 2 3 4
1 4 4 1
5
1 2 3 4
1 3 2 4

输出样例：
2
3

提示：
None



题目：ab+(1028)
时间限制：1000 ms
空间限制：65535 kb
题目描述：
你随意的输入一个合法的中缀运算式，得到它的结果。中缀运算式可以由 ‘数字’ ‘+’ ‘-’ ‘空格’ ‘/’ ‘*’ ‘（’ ‘）’ ‘=’组成；小括号只要合法，可以嵌套如“(  (  )  ) ,  (  (  )  (  )  )”；数字是int 型；范围是int 的范围；空格只出现在‘=’之前；
题目输入：
	第一行case数	接下来是表达式各占一行
题目输出：
输出结果
输入样例：
3
10 + 20 =
11-22=
15+10*(40-30/(12-10+3)*2*(66-63))+9=
输出样例：
30
-11
64


提示：
None



题目：Gameschedulerequired(1375)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Sheikh Abdul really loves football. So you better don't ask how much money he has spent to make famous teams join the annual tournament. Of course, having spent so much money, he would like to see certain teams play each other. He worked out a complete list of games he would like to see. Now it is your task to distribute these games into rounds according to following rules:

In each round, each remaining team plays at most one game 
If there is an even number of remaining teams, every team plays exactly one game 
If there is an odd number of remaining teams, there is exactly one team which plays no game (it advances with a wildcard to the next round) 
The winner of each game advances to the next round, the loser is eliminated from the tournament 
If there is only one team left, this team is declared the winner of the tournament As can be proved by induction, in such a tournament with n teams, there are exactly n - 1 games required until a winner is determined. Obviously, after round 1, teams may already have been eliminated which should take part in another game. To prevent this, for each game you also have to tell which team should win.
题目输入：
The input file contains several test cases. Each test case starts with an integer n (2 ≤ n ≤ 1000), the number of teams participating in the tournament. The following n lines contain the names of the teams participating in the tournament. You can assume that each team name consists of up to 25 letters of the English alphabet ('a' to 'z' or 'A' to 'Z').
Then follow n - 1 lines, describing the games the sheikh would like to see (in any order). Each line consists of the two names of the teams which take part in that game. You can assume that it is always possible to find a tournament schedule consisting of the given games.
The last test case is followed by a zero.
题目输出：
For each test case, write the game schedule, distributed in rounds.
For each round, first write "Round #X" (where X is the round number) in a line by itself. Then write the games scheduled in this round in the form: "A defeats B", where A is the name of the advancing team and B is the name of the team being eliminated. You may write the games of a round in any order. If a wildcard is needed for the round, write "A advances with wildcard" after the last game of the round, where A is the name of the team which gets the wildcard. After the last round, write the winner in the format shown below. Print a blank line after each test case.
输入样例：
3
A
B
C
A B
B C
5
A
B
C
D
E
A B
C D
A E
C E
0

输出样例：
Round #1
B defeats A
C advances with wildcard
Round #2
C defeats B
Winner: C

Round #1
A defeats B
C defeats D
E advances with wildcard
Round #2
E defeats A
C advances with wildcard
Round #3
E defeats C
Winner: E

提示：
Note that there is always more than one possible game schedule; you may print any of them.



题目：ScoreInflation(1477)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
The more points students score in our contests, the happier we here at the USACO are. We try to design our contests so that people can score as many points as possible, and would like your assistance. We have several categories from which problems can be chosen, where a "category" is an unlimited set of contest problems which all require the same amount of time to solve and deserve the same number of points for a correct solution. Your task is write a program which tells the USACO staff how many problems from each category to include in a contest so as to maximize the total number of points in the chosen problems while keeping the total solution time within the length of the contest. The input includes the length of the contest, M (1 <= M <= 10,000) (don't worry, you won't have to compete in the longer contests until training camp) and N, the number of problem categories, where 1 <= N <= 10,000. Each of the subsequent N lines contains two integers describing a category: the first integer tells the number of points a problem from that category is worth (1 <= points <= 10000); the second tells the number of minutes a problem from that category takes to solve (1 <= minutes <= 10000). Your program should determine the number of problems we should take from each category to make the highest-scoring contest solvable within the length of the contest. Remember, the number from any category can be any nonnegative integer (0, one, or many). Calculate the maximum number of possible points.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  M, N -- contest minutes and number of problem classes  Lines 2-N+1:  Two integers: the points and minutes for each class
题目输出：
A single line with the maximum number of points possible given the constraints.
输入样例：
300 4
100 60
250 120
120 100
35 20
输出样例：
605
提示：
(Take two problems from #2 and three from #4.)



题目：PageHopping(1575)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	It was recentlyreported that, on the average, only 19 clicks are necessary to move from anypage on the World Wide Web to any other page. That is, if the pages on the webare viewed as nodes in a graph, then the average path length between arbitrarypairs of nodes in the graph is 19.	Given a graph inwhich all nodes can be reached from any starting point, your job is to find theaverage shortest path length between arbitrary pairs of nodes. For example,consider the following graph. Note that links are shown as directed edges,since a link from page a to page b does not imply a link from page b to page a.					The length of theshortest path from node 1 to nodes 2, 3, and 4 is 1,1, and 2 respectively. Fromnode 2 to nodes 1, 3 and 4, the shortest paths have lengths of 3, 2, and 1.From node 3 to nodes 1, 2, and 4, the shortest paths have lengths of 1, 2, and3. Finally, from node 4 to nodes 1, 2, and 3 the shortest paths have lengths of2, 3, and 1. The sum of these path lengths is 1 + 1 + 2 + 3 + 2 + 1 + 1 + 2 + 3+ 2 + 3 + 1 = 22. Since there are 12 possible pairs of nodes to consider, weobtain an average path length of 22/12, or 1.833 (accurate to three fractionaldigits).	
题目输入：
	The input datawill contain multiple test cases. Each test case will consist of an arbitrarynumber of pairs of integers, a and b, each representing a link from a pagenumbered a to a page numbered b. Page numbers will always be in the range 1 to 100.The input for each test case will be terminated with a pair of zeroes, whichare not to be treated as page numbers. An additional pair of zeroes will followthe last test case, effectively representing a test case with no links, whichis not to be processed. The graph will not include self-referential links (thatis, there will be no direct link from a node to itself), and at least one pathwill exist from each node in the graph to every other node in the graph.
题目输出：
	For each testcase, determine the average shortest path length between every pair of nodes,accurate to three fractional digits. Display this length and the test caseidentifier (they're numbered sequentially starting with 1) in a form similar tothat shown in the sample output below.
输入样例：
1 2 2 4 1 3 3 1 4 3 0 0
1 2 1 4 4 2 2 7 7 1 0 0
0 0

输出样例：
Case 1: average length between pages = 1.833 clicks
Case 2: average length between pages = 1.750 clicks

提示：
None



题目：FareySequence(1232)
时间限制：1000 ms
空间限制：32768 ms
题目描述：
A farey sequence is a set of all reduced fractions between 0 and 1 inclusive with denominators less than or equal to N. For instance, here is the set when N = 5: 
0/1 1/5 1/4 1/3 2/5 1/2 3/5 2/3 3/4 4/5 1/1 
Write a program that, given an integer N between 1 and 500 inclusive, prints the fractions in order of increasing magnitude.
题目输入：
The input has several cases ended by EOF. For each case, a line must be read which has only one integer. 
题目输出：
For each case you should output a line which includes the answer, which contains the farey sequence of n. Print a white blank between each two fractions. No more blank should be output.
输入样例：
1
2
输出样例：
0/1 1/1
0/1 1/2 1/1
提示：




题目：世界杯预言(1676)
时间限制：1000MS
空间限制：65535K
题目描述：
	为了争夺世界杯的门票，一场世界范围类的足球巡回淘汰赛正在进行。假设共有2^n队伍，标号为1~2^n。在每一轮的比赛中，所有还留在淘汰赛中队伍按初始顺序排列，然后第1支队伍和第2支队伍比，第3支队伍和第4支队伍比...经过n轮候仅有1支队伍保持不败，这就是冠军！	提供一个矩阵P=p[i,j],pij表示i队伍打败j队伍的概率，然后确定哪支队伍最有可能赢得冠军！
题目输入：
	多组测试数据，以EOF结束。	每个测试样列：以n开始（1<=n<=8)	下面是矩阵 P，满足条件pij=1.0-pji，pii=0；
题目输出：
一个整数，表示哪支队伍最有可能获得最后的冠军！
输入样例：
2
0.0 0.1 0.2 0.3
0.9 0.0 0.4 0.5
0.8 0.6 0.0 0.6
0.7 0.5 0.4 0.0

输出样例：
2

提示：
假设开始n=2共4支队伍，一轮后剩下2支，win（1，2），win（3，4）；第二轮后剩下一支队伍
win（win(1,2),win(3,4));



题目：Foodportionsize(1130)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	The university canteen does not want any student to leave the canteen hungry. Therefore, as long as a student is hungry, he can get another portion of food for free. The canteen uses a fixed food portion size, because it would take too much time to first ask a student how much food he wanted. It can happen that a student doesn't finish his last portion of food and the remainder has to be thrown away.	To minimize costs, the manager of the canteen wants to determine a food portion size S such that the amount of food that is wasted is small, but also the number of times the students have to fetch another portion of food is not too big. Note that these two goals can be conflicting:	 	By choosing a very small food portion size, one does not waste food, but simultaneously the number of times the students have to fetch food is big.	By choosing a large food portion size, one can make sure each student has to fetch only one portion, but at the same time it may happen that a large quantity of food is wasted.	 	The manager of the canteen has collected data about how many units of food each student eats. The problem to be solved can now be formulated mathematically as follows: Let x be the amount of food that is wasted, and y the number of times the students go to fetch food. Then, the goal is to minimize a × x + b × y, where a, b are weights that represent the relative importance of the two opposing goals. Note that x and y depend on the food portion size S and the quantities of food each student eats. We impose the additional constraint that no student should have to go more than 3 times to fetch food.
题目输入：
The input file contains several test cases. Each test case starts with a line containing an integer n, (1 ≤ n ≤ 1000), the number of students eating in the canteen. The next line contains the values a and b (1 ≤ a, b ≤ 10). The third line of each test case consists of n integers y1, ..., yn (1 ≤ yi ≤ 100), where yi is the amount of food student i eats. Input is terminated by n=0.
题目输出：
For each test case print one line containing the costs resulting from an optimal choice of the food portion size. Print each value as a reduced fraction. If the result is an integer, do not print the denominator 1. See the sample output for details.
输入样例：
5
1 1
3 7 1 9 12
3
10 1
11 13 17
2
2 3
6 3
0

输出样例：
35 / 2
154 / 3
9

提示：
In the first sample input, the optimal food portion size is 4.5. Note that a food portion size of 3 would yield a smaller cost of 16, the 5th student, however, would have to fetch food 4 times.



题目：我有一窝喵(1781)
时间限制：1000ms
空间限制：65535kb
题目描述：
	_Jessica家有一窝喵星人，每一只都有不同的花纹，为了区分它们，_Jessica学会了一种神奇的编号方法，把它们的花纹颜色都转化成了对应的字母序列。最乖的那只是abbabbab，最爱挠人的是cfedfdd ... :p	我们假设从a到z分别对应着1到26的值，那么a+1=b,b+1=c,同理b-1=a，以此类推（到z不循环回a）。	这一窝喵都有一定的血缘关系，所以很多都有着相同的图案。例如aab和bbc是相同的图案，虽然颜色不同，但颜色的变化趋势是相同的。那么图案相同可以理解为：当存在两个序列A、B，若存在常数d，使得所有A[i]+d=B[i]成立（1 <= i <= len(A), len(A)=len(B)>1）,则认为序列A与B表示的图案相同。	_Jessica观察发现，有一种图案在超过一半的喵星人身上共同存在，她认为这种图案可以作为这一窝喵星人的一个“家族记号”（在同一只身上不同的家族记号可以是重叠的）。实际上这窝喵星人的“家族记号”很可能不止一个，但肉眼计数太困难了，请你写一个程序帮她找出最长的“家族记号”。
题目输入：
	多组输入数据。	对于每组输入 第1行 输入一个整数n(1<n<=100)表示这一窝喵星人的数量	第2~n+1行 输入每只喵星人的花纹序列(小写字母序列,长度不超过1000)	n=0时结束。
题目输出：
	对于每组输入，输出最长“家族记号”的长度len，及该长度“家族记号”的种类数量num，以空格分隔。	若不存在“家族记号”则输出"@_@"（不含括号）。	每组输出之间空一行。
输入样例：
3
abcfikl
abcdgij
abcdegj
0

输出样例：
4 3

提示：
None



题目：迷宫英雄救美(1029)
时间限制：1000 ms
空间限制：65535 kb
题目描述：
有一PLMM在玩迷宫时不能走出来了；还好迷宫设计者在每一个地方设计了求救电话；并且可以根据电话号码和这个求救时间得图1这种图形。现在知道每个出口(及在边上，假如美女一开始就在出口不算在出口，要另找出口)都有一个想要英雄救美得工作人员，你能找出谁能最先救美吗（找出一个就行）？（时间只与步骤有关）有时会有很多美女求救，可惜这些工作人员喜欢竞争每次只救一个美女；然后再救下一个。有时迷宫会变，因而可能求救时，可能救不到。当然事先你要进行迷宫处理；美女位置用字符‘2’表示，不能走的地方用字符‘1’表示，能走的则用‘0’表示。处理后称之为 迷宫“012”图  。迷宫最多99行99列
题目输入：
第1行输入一个整数 n是表示 求救美女 人数，（测试n次）下面是迷宫“012”图以‘#’表示迷宫图处理完了。
题目输出：
对任意不大于99行99列的迷宫；能救到得输出最少步数；不能救到的则输出“Impossible”
输入样例：
2
0101010
1000101
1100010
1001201
1010110
1000001
0100100
#
011111
110201
101011
111111
#
输出样例：
The least step is:2
Impossible

提示：
None



题目：Helptheproblemsetter(1376)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Preparing a problem for a programming contest takes a lot of time. Not only do you have to write the problem description and write a solution, but you also have to create difficult input files. In this problem, you get the chance to help the problem setter to create some input for a certain problem.For this purpose, let us select the problem which was not solved during last year's local contest. The problem was about finding the optimal binary search tree, given the probabilities that certain nodes are accessed. Your job will be: given the desired optimal binary search tree, find some access probabilities for which this binary search tree is the unique optimal binary search tree. Don't worry if you have not read last year's problem, all required definitions are provided in the following.Let us define a binary search tree inductively as follows:

The empty tree which has no node at all is a binary search tree 
Each non-empty binary search tree has a root, which is a node labelled with an integer, and two binary search trees as left and right subtree of the root 
A left subtree contains no node with a label ≥ than the label of the root 
A right subtree contains no node with a label ≤ than the label of the root 
Given such a binary search tree, the following search procedure can be used to locate a node in the tree:Start with the root node. Compare the label of the current node with the desired label. If it is the same, you have found the right node. Otherwise, if the desired label is smaller, search in the left subtree, otherwise search in the right subtree.The access cost to locate a node is the number of nodes you have to visit until you find the right node. An optimal binary search tree is a binary search tree with the minimum expected access cost.
题目输入：
The input file contains several test cases. Each test case starts with an integer n (1 ≤ n ≤ 50), the number of nodes in the optimal binary search tree. For simplicity, the labels of the nodes will be integers from 1 to n. The following n lines describe the structure of the tree. The i-th line contains the labels of the roots of the left and right subtree of the node with label i (or -1 for an empty subtree). You can assume that the input always defines a valid binary search tree.
The last test case is followed by a zero.
题目输出：
For each test case, write one line containing the access frequency for each node in increasing order of the labels of the nodes. To avoid problems with floating point precision, the frequencies should be written as integers, meaning the access probability for a node will be the frequency divided by the sum of all frequencies. Make sure that you do not write any integer bigger than 263 - 1 (the maximum value fitting in the C/C++ data type long long or the Java data type long). Otherwise, you may produce any solution ensuring that there is exactly one optimal binary search tree: the binary search tree given in the input.
输入样例：
3
-1 -1
1 3
-1 -1
10
-1 2
-1 3
-1 4
-1 5
-1 6
-1 7
-1 8
-1 9
-1 10
-1 -1
0

输出样例：
1 1 1
512 256 128 64 32 16 8 4 2 1

提示：
Note that the first test case in the sample input describes a tree looking like 
  2  
 / \ 
1   3





题目：HumbleNumbers(1478)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
For a given set of K prime numbers S = {p1, p2, ..., pK}, consider the set of all numbers whose prime factors are a subset of S. This set contains, for example, p1, p1p2, p1p1, and p1p2p3 (among others). This is the set of `humble numbers' for the input set S. Note: The number 1 is explicitly declared not to be a humble number. Your job is to find the Nth humble number for a given set S. Long integers (signed 32-bit) will be adequate for all solutions.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  Two space separated integers: K and N, 1 <= K <=100 and 1 <= N <= 100,000.  Line 2:  K space separated positive integers that comprise the set S.
题目输出：
The Nth humble number from set S printed alone on a line.
输入样例：
4 19
2 3 5 7
输出样例：
27
提示：




题目：修路(1233)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
1-n个村庄，它们需要建一些路使相互之间连通，已知它们之间已经有一些建得很好的路，希望剩下的要建的路长度之和，越短越好。
题目输入：
第一行 n，m，k，n表示村庄数（2<=n<=10000），m表示已建好的道路数(m<=10000)，k（k<=100000）表示可以修建的路。2到m+1行，有a，b，c（1<=a,b<=n）三个整数表示村庄a和b之间已经修好了长度为c(0<=c<=100)的路，余下的k行，有a，b，c(1<=a,b<=n)表示村庄a和b可以建一条长度为c(0<=c<=100)的路径，使两村庄连通。
（多组case 以n为0结尾,会有重边）
题目输出：
如果不能连通输出-1；否则输出最小的修路总长度。
输入样例：
3 1 2
1 2 5
1 3 1
3 2 1
0
输出样例：
1 
提示：




题目：StopperStumper(1576)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	Stephen Stepper's Supply Store sells stoppersrubbercorks for sealing jars, bottles, and other containers that have round openings.A stopper is shaped like two concentric cylinders, each of height 1.5centimeters, glued together. Figure 1 shows two stoppers of different sizes.					When Stephenpackages an order to be shipped by mail, he tries to use space efficiently toconserve packing material. Since stoppers are the smallest items in his store,he packs them last, and finds that he must often pack several stoppers intosmall triangular gaps at the top of the shipping carton. Stoppers must insertedin one of the two orientations shown in Figure 1. The triangular spaces areonly 3 cm deep, so stoppers cannot be placed on top of one another; however,the large cylinder of one stopper is permitted to overlap the large cylinder ofanother inverted stopper as shown in Figures 1 and 2. Your job is to helpStephen decide what collections of stoppers will fit into a triangular space.				For instance,suppose a triangular space with side lengths 8, 7, and 10 were available, andwe had to fit three stoppers in it with inside/outside diameters of 2cm/3cm,1.5cm/3cm, and 1cm/3cm. One way to pack them is as shown in Figure 2. (Thedotted circle indicates that the smaller cylinder of one of the stoppers isunderneath the larger one.) The only packing Stephen will consider has thelarger cylinder of each stopper touching two sides of the triangle, with no twolarger cylinders touching the same pair of sides.							
题目输入：
	The input consistsof a sequence of triangle specifications and descriptions of three stoppers foreach triangle. Each triangular space is specified by three positive integersrepresenting the lengths of the three sides; only valid triangles will appearin the input. A pair of positive real numbers represents each stopper. Thefirst number in the pair represents the diameter of the smaller cylinder, andthe second represents the diameter of the larger cylinder. The final line ofthe input file contains zeros for all the data values.
题目输出：
	For each triangle,print a line identifying its sequence number in the input data and a lineindicating whether or not the stoppers can be packed into the triangular space.Separate the output for each triangle with a blank line. Do not print anythingfor the final line of zeros in the input. Imitate the sample output as closelyas possible.
输入样例：
6 6 6 0.5 1.0 0.3 2.0 0.4 1.0
10 10 10 2.0 3.0 1.0 2.0 1.5 3.5
20 6 20 3.0 4.5 0.5 1.0 4.0 5.0
8 7 10 2.0 3.0 1.5 3.0 1.0 3.0
8 7 10 2.0 3.0 2.5 3.0 2.0 3.0
0 0 0 0.0 0.0 0.0 0.0 0.0 0.0

输出样例：
Triangle number 1:
All three stoppers will fit in the triangular space

Triangle number 2:
All three stoppers will fit in the triangular space

Triangle number 3:
Stoppers will not fit in the triangular space

提示：
None



题目：HarryPotterandtheGoldenSnitch(1677)
时间限制：1000MS
空间限制：65535K
题目描述：
	BrothersFred and George Weasley once got into the sporting goods store and opened a boxof Quidditch balls. After long and painful experiments they found out that theGolden Snitch is not enchanted at all. It is simply a programmed device. It always moves along the same trajectory, which is a polyline with vertices atthe points (x0, y0, z0), (x1, y1, z1), ...,(xn, yn, zn). At the beginning of the game the snitch is positioned at the point (x0, y0, z0),and then moves along the polyline at the constant speed vs. The twins have not yet found out how the snitch behaves then.Nevertheless, they hope that the retrieved information will help Harry Potterand his team in the upcoming match against Slytherin. Harry Potter learned thatat the beginning the game he will be at the point (Px, Py, Pz) and his super fast Nimbus 2011 broomallows him to move at the constant speed vp in any direction or remain idle. vp is not less than the speed of the snitch vs.Harry Potter, of course, wants to catch the snitch as soon as possible. Or, if catching the snitch while it is moving along the polyline is impossible, he wants to hurry the Weasley brothers with their experiments. Harry Potter catches the snitch at the time when they are at the same point. Help Harry.
题目输入：
	The first line contains a singleinteger n (1 <= n <= 10000). The following n + 1 lines contain the coordinates xi,yi, zi, separated by single spaces. The coordinates of any two consecutivepoints do not coincide. The next line contains the velocities vp and vs, thelast line contains Px, Py, Pz, separated by single spaces. All the numbers inthe input are integers, their absolute value does not exceed 10^4. The speeds are strictly positive. It is guaranteed that vs<=vp.	The input file ends with EOF.
题目输出：
	If HarryPotter can catch the snitch while it is moving along the polyline (includingthe end(xn, yn, zn)), print "YES" in the first line (without thequotes). Print in the second line t, which is the earliest moment of time, whenHarry will be able to catch the snitch. On the third line print three numbers X,Y, Z, the coordinates of the point at which this happens. The answer should be accurate to 10^-6. If Harry is not able to catch the snitch during its moving along the described polyline, print "NO".
输入样例：
4
0 0 0
0 10 0
10 10 0
10 0 0
0 0 0
1 1
5 5 25

4
0 0 0
0 10 0
10 10 0
10 0 0
0 0 0
1 1
5 5 50
输出样例：
YES
25.500000
10.000000 4.500000 0.000000
NO
提示：
None



题目：AutomaticCorrectionofMisspellings(1377)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Some text editors offer a feature to correct words which seem to be written incorrectly. In this problem you are asked to implement a simple Automatic Correction of Misspellings (ACM). 
ACM takes care of the following misspellings of words: 

One letter is missing (e.g., letter is written leter) or too much (e.g., letter is written lettter). 
One letter is wrong (e.g., letter is written ketter) 
The order of two adjacent letters is wrong (e.g., letter is written lettre) 
ACM is based on a dictionary of known words. When a text contains a word which is not in the dictionary, ACM will try to replace it by a similar word of the dictionary. Two words are similar if we can transform one word into the other by doing exactly one of the misspellings listed above. An unknown word is left unchanged if there is no similar word in the dictionary.
题目输入：
The first line of the input file will give the number n of words in the dictionary (n ≤ 10000). The next n lines contain the dictionary words. The following line contains an integer q ≤ 1000, the number of query words. The next q lines contain the query words. You may assume that each word in the input consists of 1 to 25 lower case letters ('a' to 'z').
题目输出：
For each query word, print one line with the query word followed by one of the following possibilities:

is correct, if the word occurs in the dictionary. 
is a misspelling of , where  is a word of the dictionary similar to the query word, and the query word is not in the dictionary. In the case that there are several possibilities, select the word from the dictionary which appeared earlier in the input. 
is unknown, if cases 1 and 2 do not apply.
输入样例：
10
this
is
a
dictionary
that
we
will
use
for
us
6
su
as
the
dictonary
us
willl

输出样例：
su is a misspelling of us
as is a misspelling of is
the is unknown
dictonary is a misspelling of dictionary
us is correct
willl is a misspelling of will

提示：




题目：God(1782)
时间限制：1000ms
空间限制：65535kb
题目描述：
	小明很萌的，你们不要黑他。	小明是个萌汉纸，可整天想着萌妹纸。这不，小明看中了一个非常萌的妹纸，简直就是小明心中的女神，可女神瞬间就消失了。自那以后，小明茶不思，饭不香，日渐消瘦。神看不下去了，告诉小明他的女神所在的城市，还答应免费一部分车费。	小明和女神处在一张无向图中，N（1<=N<=1000）个节点，P(1<=p<=10000)条边。小明在1节点，女神在N节点。小明要从中选择一条路径来找到他的女神。每条道路都有费用li（1<=li<=1000000），神可以为小明支付k(1<=k<=1000)条道路的费用，小明当然很开心啦，可是小明又不是高富帅，接下来的路费之和也可能使小明崩溃。所以，身为基友的你便来帮助小明指定k条免费道路，使之后的路费之和最小。
题目输入：
	输入有多组数据，对于每组数据，第一行包含三个数字n,p,k，第二行到第p+1行，每行分别都为三个整数ai,bi,li。
题目输出：
	一个整数，表示该项工程的最小支出，如果不可能完成则输出-1。
输入样例：
5 7 1
1 2 5
3 1 4
2 4 8
3 2 3
5 2 9
3 4 7
4 5 6

输出样例：
5

提示：
None



题目：代码相似(1131)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
鱼头曾经曰过：比赛的时候大家不要贴代码呀！
dccmx曰：鱼头曰得对，唐骏学历门告诉我们诚信很重要，我来弄个程序揪出那些猥琐男吧。
dccmx苦思冥想，终于想出了方法：
对于C语言，dccmx做出了如下定义：

1.	如果两个函数的参数个数相同，则认为这两个函数签名雷同。
2.	如果两个函数所调用的雷同签名的函数的次数一样（顺序不关心），则这两个函数逻辑雷同。
3.	如果要判定两个函数F1和F2逻辑相似，则这两个函数必须逻辑雷同，且这两个函数调用的函数集合S1和S2存在一种对应关系使得S1和S2里的所有函数都在对方集合里找到唯一的函数与之逻辑相似。
4.	如果程序的main函数的逻辑相似，则两个程序代码相似。

dccmx又曰：我妈妈喊我回家吃饭，张珂你来写这个程序吧。
张珂曰：NO！我是来打酱油的。。。

所以，任务交给你了。
注意：代码没有注释，没有宏等预处理语句，没有重载，字符串中不会出现函数调用，最多会出现20个自己定义的函数，不会出现函数参数如果为空不会出现void，如func(void)，其它定义参考C语言语法。

题目输入：
第一行，N，测试用例数。
下面N块，每块两个程序，对于每个程序，先来一个M，表示行数，然后是M行代码。

题目输出：
输出这N个测试用例是否相似，如果相似输出：Similar! 否则输出Not Similar。每行一个结果。
输入样例：
2
10
int fa(int a, int b)
{
    return a+b;
}
int main()
{
    int c, d;
    int c=fa (c, d);
    printf("%d", c);
}
5
int fb(int c, int d){return c+d;}
int main(){
    int a, b;
    printf("%d", fb(a,b));
} 
8
int fa(int a, int b){return a+b;}
int fb(int c){return c+1;}
int main()
{
    int c, d;
    int c=fa (c, d);
    printf("%d", fb(c));
}
5
int fb(int c, int d){return c+d;}
int main(){
    int a, b;
    printf("%d", fb(a,b));
} 

输出样例：
Similar!
Not Similar

提示：




题目：abka(1030)
时间限制：1000 ms
空间限制：65535 kb
题目描述：
abka 计算能力差。于是请你帮他设计一个程序：能计算+、-、*、/及带括号运算 的算式。其中各个数字大于等于0 小于等于9。等号为输入结束的标志。
题目输入：
表达式
题目输出：
先给出其对应的后缀表达式，再给出运算结果。
输入样例：
1+2*3=
输出样例：
1 2 3 * + =
7

提示：
None



题目：ShapingRegions(1479)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
N opaque rectangles (1 <= N <= 1000) of various colors are placed on a white sheet of paper whose size is A wide by B long. The rectangles are put with their sides parallel to the sheet's borders. All rectangles fall within the borders of the sheet so that different figures of different colors will be seen. The coordinate system has its origin (0,0) at the sheet's lower left corner with axes parallel to the sheet's borders.
题目输入：
There are several test cases, end by EOF, for each test case:The order of the input lines dictates the order of laying down the rectangles. The first input line is a rectangle "on the bottom". Line 1:  A, B, and N, space separated (1 <= A,B <= 10,000) Lines 2-N+1:  Five integers: llx, lly, urx, ury, color: the lower left coordinates and upper right coordinates of the rectangle whose color is `color' (1 <= color <= 2500) to be placed on the white sheet. The color 1 is the same color of white as the sheet upon which the rectangles are placed.
题目输出：
The output file should contain a list of all the colors that can be seen along with the total area of each color that can be seen (even if the regions of color are disjoint), ordered by increasing color. Do not display colors with no area.
输入样例：
20 20 3
2 2 18 18 2
0 8 19 19 3
8 0 10 19 4
输出样例：
1 91
2 84
3 187
4 38
提示：
Note that the rectangle delineated by 0,0 and 2,2 is two units wide and two high. Here's a schematic diagram of the input: 1111111111111111111133333333443333333331333333334433333333313333333344333333333133333333443333333331333333334433333333313333333344333333333133333333443333333331333333334433333333313333333344333333333133333333443333333331333333334433333333311122222244222222221111222222442222222211112222224422222222111122222244222222221111222222442222222211112222224422222222111111111144111111111111111111441111111111The '4's at 8,0 to 10,19 are only two wide, not three (i.e., the grid contains a 4 and 8,0 and a 4 and 8,1 but NOT a 4 and 8,2 since this diagram can't capture what would be shown on graph paper). An array of all 'points' is too big; 16MB maximum. Keep track of the rectangles' coordinates; split the rectangle when an overlap occurs, e.g.: +--------+      +-+--+--+|        |      | |2 |  ||        |      + +--+  ||  +-+   |  --> | |  |  ||  +-+   |      |1|  |3 ||        |      | +--+  ||        |      | | 4|  |+--------+      +-+--+--+



题目：Squares(1577)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	A children's board game consists of a square array of dots that contains lines connecting some of the pairs of adjacent dots. One part of the game requires that the players count the number of squares of certain sizes that are formed by these lines. For example, in the figure shown below, there are 3 squares-2 of size 1 and 1 of size 2. (The ``size" of a square is the number of lines segments required to form a side.)								Your problem is to write a program that automates the process of counting all the possible squares.		
题目输入：
	The input file represents a series of game boards. Each board consists of a description of a square array of n2 dots (where 2 <= n <= 9) and some interconnecting horizontal and vertical lines. A record for a single board with n2 dots and m interconnecting lines is formatted as follows:			Line 1: 	n 	the number of dots in a single row or column	of the array		Line 2: 	m 	the number of interconnecting lines			Each of the next m lines are of one of two types:			H i j  indicates a horizontal line in row i which connects			the dot in column j to the one to its right in column	j + 1			or			V i j  indicates a vertical line in column i which connects			the dot in row j to the one below in row j + 1		Information for each line begins in column 1. The end of input is indicated by end-of-file. The first record of the sample input below represents the board of the square above.	
题目输出：
	For each record, label the corresponding output with ``Problem #1", ``Problem #2", and so forth. Output for a record consists of the number of squares of each size on the board, from the smallest to the largest. lf no squares of any size exist, your program should print an appropriate message indicating so. Separate output for successive input records by a line of asterisks.	
输入样例：
4
16
H 1 1
H 1 3
H 2 1
H 2 2
H 2 3
H 3 2
H 4 2
H 4 3
V 1 1
V 2 1
V 2 2
V 2 3
V 3 2
V 4 1
V 4 2
V 4 3
2
3
H 1 1
H 2 1
V 1 1
输出样例：
Problem #1

2 square (s) of size 1
1 square (s) of size 2

**********************************

Problem #2

No completed squares can be found.

**********************************
提示：
None



题目：愿(1678)
时间限制：1000ms
空间限制：65535KB
题目描述：
		安排学生打扫卫生让徐老师感到头疼，一个班级共分为四组，每天由一个小组集体打扫卫生。由于有些同学要求在某一天进行打扫，为满足这些同学要求整个小组就在这一天打扫。而且为了不让学生太辛苦，不能安排一个小组连续两天打扫卫生。徐老师想知道一共有多少种安排值日表的方案。
题目输入：
	多组数据。	每组数据第一行为两个整数N和M。N表示一个学期有N天（1<=n<=10000000）,M表示有M个同学请求在特定一天打扫卫生（0<=M<=10）。接下来M行，是每个请求，形式是一个整数+一个字母。整数表示特定的某一天，字母表示小组编号（编号为A、B、C、D）
题目输出：
	满足每个学生的请求且不能出现一个小组连续两天打扫卫生，共有多少种安排方法。(结果对5201314取模)
输入样例：
3 2
1 A
3 C

2 1
1 D

100 10
5  A
17 B
23 C
38 D
49 A
52 B
61 C
75 D
86 A
99 B

输出样例：
2
3
2220366

提示：
None



题目：Hardestproblemofthiscontest(1234)
时间限制：2000 ms
空间限制：65536 ms
题目描述：
给你很多个1*2的长方形（可以旋转）和很多个2*2的正方形，你需要填满一个2*n的长方形。显然随意的摆放都是可行的，所以我很好奇一共有多少种摆放方式。
题目输入：
多case,EOF结束。每个case包含一行，一个整数n。1<=n<=250。
题目输出：
输出可以摆放的种数
输入样例：
1
2
输出样例：
1
3
提示：
以下Hint只有女生能看
作为一位资深的女生部长，hdd想提醒他亲爱的学妹们：这题要写高精度的。



题目：Basicwallmaze(1378)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	In this problem you have to solve a very simple maze consisting of:			a 6 by 6 grid of unit squares					3 walls of length between 1 and 6 which are placed either horizontally or vertically to separate squares							one start and one end marker																A maze may look like this:				 									You have to find a shortest path between the square with the start marker and the square with the end marker. Only moves between adjacent grid squares are allowed; adjacent means that the grid squares share an edge and are not separated by a wall. It is not allowed to leave the grid.				
题目输入：
The input consists of several test cases. Each test case consists of five lines: The first line contains the column and row number of the square with the start marker, the second line the column and row number of the square with the end marker. The third, fourth and fifth lines specify the locations of the three walls. The location of a wall is specified by either the position of its left end point followed by the position of its right end point (in case of a horizontal wall) or the position of its upper end point followed by the position of its lower end point (in case of a vertical wall). The position of a wall end point is given as the distance from the left side of the grid followed by the distance from the upper side of the grid. You may assume that the three walls don't intersect with each other, although they may touch at some grid corner, and that the wall endpoints are on the grid. Moreover, there will always be a valid path from the start marker to the end marker. Note that the sample input specifies the maze from the picture above. The last test case is followed by a line containing two zeros.
题目输出：
For each test case print a description of a shortest path from the start marker to the end marker. The description should specify the direction of every move ('N' for up, 'E' for right, 'S' for down and 'W' for left).There can be more than one shortest path, in this case you can print any of them.
输入样例：
1 6
2 6
0 0 1 0
1 5 1 6
1 5 3 5
0 0

输出样例：
NEEESWW

提示：
None



题目：奇怪的矩阵(1783)
时间限制：1000ms
空间限制：65535kb
题目描述：
	有一个n * n的0、1矩阵，有两种操作：把0变为1或者把1变为0。	问：最少要几步操作可以使每个元素的上、下、左、右的位置上的元素（如果存在）之和为偶数。
题目输入：
	多组数据（不超过30组），每组数据的第一行为一个正整数 n,(2<=n<=15)，接下来是n行，每行包含n个0或者1，相邻整数间用空格隔开。(n = 0时结束，不用处理)
题目输出：
	对每组输入，输出最少的操作数。如果无解，输出-1。
输入样例：
5
0 0 0 0 1 
1 1 1 1 1 
0 0 0 0 1 
1 1 0 0 0 
0 0 1 0 0 
3
0 1 0 
1 0 1 
0 1 0 

输出样例：
9
0

提示：
 

	对于样例一，可以将原矩阵变为


	0 0 0 0 1


	0 0 0 1 0


	0 0 1 0 0


	0 1 0 0 0


	1 0 0 0 0


	一共需要改变9个位置上的数；


	样例二不须改变。


	

 

	
 




题目：SettlersofCatan(1132)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	The popular  board game “Settlers of Catan” starts by creating  a random  board.  This board consists of hexagonal  resource tiles containing  five different resources:  clay, lumber,  wool, grain, and ore.  For simplicity,  we will denote  these by the numbers  1 to 5.	Random  boards,  however,  often have multiple  equal resource  tiles next  to each other.   This  annoys some players.  Therefore,  we have invented  a new way of creating  the playing board.  Starting in the middle and  spiraling  outwards, each time  we add  a new tile to the  board  we choose the  resource of the tile according  to the following rules:		• the new tile must  be different from its neighboring  tiles on the board  so far;	 	• in case multiple  tiles are possible, we choose a resource that occurs the  least  number  of times on the board  so far;		       • in case multiple  tiles are still possible, the new resource must  have the lowest number  possible. 		The  figure underneath shows how to spiral  outwards and  which resource  tiles are chosen first.  We	are curious  what  the  number  of the  resource is on the  nth  tile that is added  to the  board  (starting	with n = 1).	 		 
题目输入：
On the  first line of the  input  there  is one integer  c (1 ≤ c ≤ 200), the  number  of test  cases.  Each following test  case consists  of a single line with  one integer  n (1 ≤ n ≤ 10 000), the  number  of the tile we are curious about.
题目输出：
For each test  case, print a single line with one integer,  specifying the resource of the nth  tile.
输入样例：
4
1
4
10
100
输出样例：
1
4
5
5
提示：
None



题目：简单的计算器(1031)
时间限制：1000 ms
空间限制：65535 kb
题目描述：
设计一个计算器程序，能够计算简单的计算算术表达式。只有 + ，—  ,  *  ,  /  ,  (  ,  ) 的个位数算术表达式
题目输入：
测试数据组数t<100表达式s(长度<100)
题目输出：
计算结果(结果保留两位)
输入样例：
1
1+2*（1+1）
输出样例：
5.00
提示：
None



题目：Contact(1480)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The cows have developed a new interest in scanning the universe outside their farm with radiotelescopes. Recently, they noticed a very curious microwave pulsing emission sent right from the centre of the galaxy. They wish to know if the emission is transmitted by some extraterrestrial form of intelligent life or if it is nothing but the usual heartbeat of the stars. Help the cows to find the Truth by providing a tool to analyze bit patterns in the files they record. They are seeking bit patterns of length A through B inclusive (1 <= A <= B <= 12) that repeat themselves most often in each day's data file. They are looking for the patterns that repeat themselves most often. An input limit tells how many of the most frequent patterns to output. Pattern occurrences may overlap, and only patterns that occur at least once are taken into account.
题目输入：
Line 1:  Three space-separated integers: A, B, N; (1 <= N < 50)  Lines 2 and beyond:  A sequence of as many as 200,000 characters, all 0 or 1; the characters are presented 80 per line, except potentially the last line.
题目输出：
Lines that list the N highest frequencies (in descending order of frequency) along with the patterns that occur in those frequencies. Order those patterns by shortest-to-longest and increasing binary number for those of the same frequency. If fewer than N highest frequencies are available, print only those that are. Print the frequency alone by itself on a line. Then print the actual patterns space separated, six to a line (unless fewer than six remain).
输入样例：
2 4 10
01010010010001000111101100001010011001111000010010011110010000000


In this example, pattern 100 occurs 12 times, and pattern 1000 occurs 5 times. The most frequent pattern is 00, with 23 occurrences.
输出样例：
23
00
15
01 10
12
100
11
11 000 001
10
010
8
0100
7
0010 1001
6
111 0000
5
011 110 1000
4
0001 0011 1100
提示：
None



题目：RepeatingDecimals(1578)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	The decimal expansion of the fraction 1/33 is   , where the   is used to indicate that the cycle 03 repeats indefinitely with no intervening digits. In fact, the decimal expansion of every rational number (fraction) has a repeating cycle as opposed to decimal expansions of irrational numbers, which have no such repeating cycles.		Examples of decimal expansions of rational numbers and their repeating cycles are shown below. Here, we use parentheses to enclose the repeating cycle rather than place a bar over the cycle.					Write a program that reads numerators and denominators of fractions and determines their repeating cycles.		For the purposes of this problem, define a repeating cycle of a fraction to be the first minimal length string of digits to the right of the decimal that repeats indefinitely with no intervening digits. Thus for example, the repeating cycle of the fraction 1/250 is 0, which begins at position 4 (as opposed to 0 which begins at positions 1 or 2 and as opposed to 00 which begins at positions 1 or 4).	
题目输入：
	Each line of the input file consists of an integer numerator, which is nonnegative, followed by an integer denominator, which is positive. None of the input integers exceeds 3000. End-of-file indicates the end of input.	
题目输出：
	For cach line of input, print the fraction, its decimal expansion through the first occurrence of the cycle to the right of the decimal or 50 decimal places (whichever comes first), and the length of the entire repeating cycle.		In writing the decimal expansion, enclose the repeating cycle in parentheses when possible. If the entire repeating cycle does not occur within the first 50 places (count from the first digit after the '.'), place a left parenthesis where the cycle begins - it will begin within the first 50 places - and place ``...)" after the 50th digit.	
输入样例：
76 25
5 43
1 397
输出样例：
76/25 = 3.04(0)
   1 = number of digits in repeating cycle
5/43 = 0.(116279069767441860465)
   21 = number of digits in repeating cycle
1/397 = 0.(00251889168765743073047858942065491183879093198992...)
   99 = number of digits in repeating cycle
提示：
None



题目：得(1679)
时间限制：1000ms
空间限制：65535KB
题目描述：
		最近有不少学生想给自己起个英文名，于是她们向最受爱戴的徐老师咨询意见（事实上，徐老师一向很用心地关心着学生的学习生活各个方面）。他们打算用一种随机的方式来生成英文名：先由学生每人写下一个字母，组成一个字符串，我们知道一个字符串的子串有很多。例如，“ABC”有6个子串，按从小到大的顺序分别是：“A”、“AB”、“ABC”、“B”、“BC”、“C”。然后每个同学选择一个数K，那么就根据第K个子串的字母来想他的英文名。可是，学生们都难以一口得出第K个子串是什么，你能帮我们解决这个问题吗？
题目输入：
	多组数据，一个case数T。	对于每个case,有两个数据，第一个为学生写下的字母，第二个为选定的K。	（学生人数N范围为1~100000 ，1<=K<=N*(N+1)/2 ）
题目输出：
	第K个子串。
输入样例：
2
ABC 2
BBC 3

输出样例：
Case 1: AB
Case 2: BB

提示：
None



题目：INT_MAX,INT_MIN(1235)
时间限制：1000 ms
空间限制：32768 ms
题目描述：
Huangwei_njust is having an adventure now. Fortunately, he finds a cave that no one has discovered before. He is sure that there must be some jewellery in the cave. So he happily went in. The cave is full of all kinds of traps and mazes and so on. But as you know, Huang is very brilliant and he has learnt all kinds of algorithms engaged with network flow, graphs, and search skills. So, this can’t trap him. But now he is stopped by a thick door. He can’t open it using any methods. He has found that there are a sequence of numbers on the door, and two blanks to fill in. He doesn’t know what to do. 
Then God appears. “This is the last barrier for you and I will tell you what this problem means,” the god said. “You should use these numbers to make a largest number and a smallest one. You have two operations. The first is, you pick any three numbers from the sequence, multiply them, and add the number 1 to the result, and the result will replace the three numbers you choose. The second is, you pick any two numbers, and do as I said as before. When the sequence has only one number, this is the final result. You should find the biggest and the smallest result you could ever make. ” However, Huang is not as excellent at math as he is at other fields. He needs your help. If he succeeds to get the jewellery, he will give some to you as a reward.
题目输入：
There are multiple cases of the input. For each case, the first line contains a number n(3<=n<=1000). Then comes n numbers, which shows the sequence. The input is terminated by n=0. We ensure that all the numbers in the sequence is not smaller than 2 and not greater than 32768.
题目输出：
For each case, output two numbers, which shows the smallest and the largest results. As the result may be very large, print the result module by 9901. So don’t be surprised when you found sometimes the first number of you output is bigger than the second.
输入样例：
3
2 2 2
3
3 2 4
0
输出样例：
9 11
25 29
提示：




题目：Constructthewallmaze(1379)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
In this problem you have to construct a maze using a maze construction kit consisting of: 

a 6 by 6 grid of unit squares 
3 walls of length between 1 and 6 which are placed either horizontally or vertically to separate squares 
one start and one end marker 
A maze may look like this: 
When a maze is finished, a shortest path between the square with the start marker and the square with the end marker is determined. Only moves between adjacent grid squares are allowed; adjacent means that the grid squares share an edge and are not separated by a wall. It is not allowed to leave the grid.
Your task is: given a shortest path of some maze, construct this maze. Obviously, the maze you construct should be valid, i.e., all 3 walls should be used, they should not intersect with each other (although they may touch at some grid corner), and the walls should not stick out of the grid. Moreover, the given path should be valid for this maze, i.e., it should lead from the square with the start marker to the square with the end marker without crossing any wall or going outside of the grid, and there shouldn't exist any shorter valid path.
题目输入：
The input consists of several test cases. Every test case starts with a line containing three positive integers, the length of the three walls of the maze construction kit. The next line consists of 1 to 25 characters from the set {'N', 'E', 'S', 'W'} and describes a shortest path from the start to the end marker in the maze to be constructed. Each character specifies the direction of the next move (see picture). You may assume that each test case has at least one solution. 

The last test case is followed by a line containing three zeros.

题目输出：
For each test case produce five lines of output: First the column and row number of the square containing the start marker, then the column and row number of the square containing the end marker, then the location of the three walls (in the same order as the given lengths in the input). The location of a wall should be specified by either the position of its left end point followed by the position of its right end point (in case of a horizontal wall) or the position of its upper end point followed by the position of its lower end point (in case of a vertical wall). The position of a wall end point should be given as the distance from the left side of the grid followed by the distance from the upper side of the grid. 

There can be several valid solutions for a given test case (for example the test case in the sample input). Your program may print any of those solutions. Note that the sample output specifies the maze from the picture above. 

输入样例：
1 1 2
NEEESWW
0 0 0

输出样例：
1 6
2 6
0 0 1 0
1 5 1 6
1 5 3 5

提示：
You may use your solution to problem B to verify the output of your program (it should not find a shorter path from the start marker to the end marker than the path given in the input).



题目：签到题(1784)
时间限制：1000ms
空间限制：65535kb
题目描述：
	给一个有向无环图，求从1号点走到N号点有多少种不同的路径。
题目输入：
	多组数据，每组第一行是N（2<=N<=100）和M（N-1<=M<=10000），表示顶点数和边数，顶点的编号从1到N。之后M行每行有两个数字a和b，表示从顶点a到顶点b有一条边。以EOF结尾。
题目输出：
	对于每组输入数据，输出一行，包含一个整数，表示从1号点到N号点有多少条不同的路径。
输入样例：
2 1
1 2
4 4
1 2
2 4
1 3
3 4

输出样例：
1
2

提示：




题目：BooleanLogic(1133)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	Propositions are logical formulas consisting of proposition symbols and connecting operators. They are recursively defined by the following rules:	 			1、All proposition symbols (in this problem, lower-case alphabetic characters, e.g., a and z) are propositions.				2、If P is a proposition, (!P) is a proposition, and P is a direct subformula of it.				3、If P and Q are propositions, (P&Q), (P|Q), (P-->Q), and (P<->Q) are propositions, and P and Q are direct subformulas of them.				4、Nothing else is a proposition.		 	The operations !, &, |, -->, and <-> denote logical negation, conjunction, disjunction, implication, and equivalence, respectively. A proposition P is a subformula of a proposition R if P=R or P is a direct subformula of a proposition Q and Q is a subformula of R.	 		 	This way, a value for P can be calculated. This value depends on the choice of the assignment of boolean values to the proposition symbols. If P contains n different proposition symbols, there are 2n different assignments. To evaluate all possible assignments we may use truth tables.	 	A truth table contains one line per assignment (i.e., 2n lines in total). Every line contains the values of all subformulas under the chosen assignment. The value of a subformula is aligned with the proposition symbol, if the subformula is a proposition symbol, and with the center of the operator otherwise.	 
题目输入：
The input contains several test cases, each on a separate line. Every test case denotes a proposition and may contain arbitrary amounts of spaces in between. The input file terminates immediately after the newline symbol following the last test case.
题目输出：
For each test case generate a truth table for the denoted proposition. Start the truth table by repeating the input line. Evaluate the proposition (and its subformulas) for all assignments to its variables, and output one line for each assignment. The line must have the same length as the corresponding input line and must consist only of spaces and the characters 0 and 1. Output an empty line after each test case. Let s1,...,sn be the proposition symbols in the denoted proposition sorted in alphabetic order. Then, all assignments of 0 to s1 must precede the assignments of 1 to s1. Within each of these blocks of assignments, all assignments of 0 to s2 must precede the assignments of 1 to s2, and so on.
输入样例：
((b --> a)  ((! a) --> (! b)))
  ((y &  a)   -  ->(c |c))

输出样例：
((b --> a)  ((! a) --> (! b)))
  0  1  0   1    1 0   1   1 0   
  1  0  0   1    1 0   0   0 1   
  0  1  1   1    0 1   1   1 0   
  1  1  1   1    0 1   1   0 1   

  ((y &  a)   -  ->(c |c))
    0 0  0       1  0 00  
    1 0  0       1  0 00  
    0 0  0       1  1 11  
    1 0  0       1  1 11  
    0 0  1       1  0 00  
    1 1  1       0  0 00  
    0 0  1       1  1 11  
    1 1  1       1  1 11 
提示：
None



题目：迷宫(1032)
时间限制：1000 ms
空间限制：65535 kb
题目描述：
设计一个程序，求出走出迷宫的所需要的最少的步数(可以走八个方向)。其中入口用s表示，出口用e表示。墙用1表示，空格用0表示。输入：输入测试组数t<10;
题目输入：
输入测试组数t<10;输入迷宫大小m行，n列（m，n<100）输入迷宫形状，用s表示入口，e表示出口，一行一行的输
题目输出：
一个数字x，表示最少要x步到达终点
输入样例：
1
2 2
s1
0e
输出样例：
1
提示：
None



题目：Stamps(1481)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
Given a set of N stamp values (e.g., {1 cent, 3 cents}) and an upper limit K to the number of stamps that can fit on an envelope, calculate the largest unbroken list of postages from 1 cent to M cents that can be created. For example, consider stamps whose values are limited to 1 cent and 3 cents; you can use at most 5 stamps. It's easy to see how to assemble postage of 1 through 5 cents (just use that many 1 cent stamps), and successive values aren't much harder: 6 = 3 + 3 7 = 3 + 3 + 1 8 = 3 + 3 + 1 + 1 9 = 3 + 3 + 3 10 = 3 + 3 + 3 + 1 11 = 3 + 3 + 3 + 1 + 1 12 = 3 + 3 + 3 + 3 13 = 3 + 3 + 3 + 3 + 1. However, there is no way to make 14 cents of postage with 5 or fewer stamps of value 1 and 3 cents. Thus, for this set of two stamp values and a limit of K=5, the answer is M=13. The most difficult test case for this problem has a time limit of 3 seconds.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  Two integers K and N. K (1 <= K <= 200) is the total number of stamps that can be used. N (1 <= N <= 50) is the number of stamp values.  Lines 2..end: N integers, 15 per line, listing all of the N stamp values, each of which will be at most 10000.
题目输出：
Line 1: One integer, the number of contiguous postage values starting at 1 cent that can be formed using no more than K stamps from the set.
输入样例：
5 2
1 3
输出样例：
13
提示：




题目：RunningLightsVisibilityCalculator(1579)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	Ships underway on the high seas at night are required to display navigation lights to identify their location and direction of movement to other ships. Most ships we required to display a set of four running lights: one at the stern (rear), one in the middle on the mast, and two at the bow (front).				In naval practice, the course of a ship is the direction the ship is traveling as measured clockwise from true north. For example, a ship that is traveling due east is on a 90   course; one traveling on a 315  course is traveling due west-northwest. The relative bearing from ship A to ship B is the measure of the angle that the course of ship A makes with the vector drawn from A to B, where the initial side of that angle is incident with the course vector and the terminal side is incident with the vector from A to B. Thee measurement is taken clockwise.		If we assume that the bow of a ship is pointing to 0.0   or 360.0   , then the running lights have ranges as shown in the figure. Here, the stern (rear) of the ship is at 180.0   . The masthead light shines all directions (0.0   - 360.0   ). The stern light shines strictly between 110.0   and 250.0   (the angle at which the stern light is beamed relative to the ship satisfies the inequalities   ). The red running light shines strictly between 245.0   and 2.5   ; the green running light shines strictly between 357.5   and 115.0   . (Note the overlap in the visible sectors between the red and green running lights and stern light. If both red and green lights are visible, the masthead light is positioned between them. Also, if the masthead light is exactly above the stern light, assume the stern is more on the left then. ) In adition, the nominal maximum light visibility range for all lights is 10 nautical miles (nm). Assume that ship is infinitely small compared to nautical mile.		Write a computer program that will repeatedly read in sets of data describing the location, course and speed of your own ship and other ships in the vicinity. Based on this information, the program will first calculate the relative bearings from other ships to your ship and display the expected configurations of visible lights from left to right as viewed from your own ship. Ships at least 10 nm away will not be visible.		The program then recalculates the relative bearings after a 3 minute time delay to determine which ships are on a collision course with your own. If another ship is initially visible and if at the end of the 3 minute delay the relative bearing from that ship to your own remains almost the same (with 2  delta at most) while the distance between the ships decreases, then the program must issue a collision warning. Assume that there will be no collisions of any type (ship-to-ship or ship-to-land) in the 3 minute time period.	
题目输入：
	The input file consists of several data scenarios. Each scenario is as follows.			Scenario ID (string -> max 50 characters)	Number of other ships (integer -> less than 4000)		Information on your own ship on two lines:	name of your ship (string -> max 25 characters)	x-coordinate y-coordinate course speed (reals)			Other ship information on two lines per ship:	name of other ship (string -> max 25 characters)	x-coordinate y-coordinate course speed (reals)				All coordinates are on a cartesian grid with unit measurement of 1 nautical mile. Courses are measured from true north, and each course satisfies  . Speeds are in knots (1 knot = 1 nm/hr). The end of input is indicated by end-of-file.	
题目输出：
	Beware of the floating point inaccuracies. Use doubles to hold the floating point values, not the float type. Use predeclared constant PI for converting angles from degrees to radians and back. Use degrees only for input and output, compute and store the angle data directly in radians. Use function atan2() for angle extraction. Don't apply more operators on real value than absolutely neccesary to compute the result.		Output consists of a single table per data set. There's first header, with string "Scenario: " followed by the name of current scenario. Then follows empty line and column headings (the column widths are 26, 8, 9 and 22 characters, see example). 65 dashes (-) divides headings from the table. A table shows the ID for each other ship along with its initially calculated relative bearing to your own ship, distance from your own ship, and its light configurations (from left to right) visible from your ship. The light names are "Masthead", "Stern", "Green" and "Red". Write "Lights not visible" if the ship is too far. Collision warnings, if any, should appear at the bottom of the table. Each warning should include string "** Collision warning --> ", the name of the other ship and its distance from your own ship at the end of the 3 minute interval. (Do not display the relative bearings, distances, or running lights configurations for the end of that warning interval.) The warnings should be ordered by the index of the other ship in input set.		All real output should be written with two digits to the right of the decimal. Separate output for different scenarios with a line of 65 asterisks.	
输入样例：
Sample Test Data Set
4
Ownship
0.0 0.0 90.0 10.0
Windswept
10.0 10.0 135.0 8.0
Footloose
-5.0 6.0 275.0 6.0
Crasher
0.0 9.0 135 14.14
Aquavit
-2.0 -2.0 294.0 15.0
输出样例：
Scenario: Sample Test Data Set

Boat ID                   Bearing Distance Lights (left to right)
-----------------------------------------------------------------
Windswept                 90.00   14.14    Lights not visible
Footloose                 225.19  7.81     Masthead Stern
Crasher                   45.00   9.00     Masthead Green
Aquavit                   111.00  2.83     Stern Masthead Green
** Collision warning --> Crasher 8.50
*****************************************************************
提示：
None



题目：你(1680)
时间限制：1000ms
空间限制：65535KB
题目描述：
		徐老师在准备公务员考试的时候，遇到一个排列组合问题：有m个盒子，n个球(球与球之间是完全相同的)，要求每个盒子里至少放k个球，共有多少种不同的方法？？？
题目输入：
	Case数T。	对于每组case,输入三个整数m(0<=m<=100),n(0<=n<=1000),k(0<=k<=20)
题目输出：
	共有多少种不同的方法，由于结果可能超出整数int范围，输出对5201314取余后的值。
输入样例：
1
2 3 1

输出样例：
2

提示：
None



题目：NewProblem(1380)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Consider n points on a unit circle with numbers k = 0, 1, ..., n-1. Initially point k makes an angle of 360 · k / n degrees to the x-axis, measured in counter-clockwise direction. We are going to perform two different kind of operations on that set of points:

rotation by 360 / n degrees in clockwise direction 
reflection with respect to the x-axis 
The following picture shows an example of these operations:
 
Given a sequence of operations, we are interested in the shortest sequence of operations which gives the same result, i.e., the position of every single point is the same after performing either of those sequences of operations. 
The sequence is given as a string consisting of the characters 'r' and 'm' which represent clockwise rotation and reflection respectively ("to the right" and "mirror"). Multiple consecutive occurrences of the same character are collected into the representation <character><number>, and for convenience this will also be done for single occurrences. So "rrmrrrrrrrrrrrr" will be abbreviated to "r2 m1 r12". The representations of different operations are always separated by a single space.
题目输入：
The input file consists of several test cases. Each test case starts with a line containing n (3 ≤ n ≤ 108), the number of points. The second line of each test case consists of an abbreviated sequence of operations as described above. All numbers will be positive and less than 108. There will be no empty line in the input file, and no line will contain more than 100000 characters. The last test case is followed by a line containing 0.
题目：Jumpoutofthetrap(1236)
题目输出：
For each test case print one line containing the abbreviated format of the sequence with the minimum number of operations which results in the same configuration of points as the input sequence. In case of multiple optimal solutions, print any solution.
时间限制：1000 ms
输入样例：
4
r2
100
m1 r100 m1
54
r218 m3 r1
0

空间限制：65536 ms
输出样例：
r2

r1 m1

题目描述：
In a stroke of luck almost beyond imagination, Brother Gao has developed the first time machine in the world! As he was so interested in western history, he was desperate to traverse to the past. After his traversing, he, using his technique from the “future”, soon became a master of a big kingdom. And then, he commanded people to construct a castle for himself. 
After the castle was completed, Gao was a little bit disappointed because each room of the castle is too small for him. He was ambitious so that he wished to have his own room larger. But he was also merciful that 提示：
Notehe didn’t want his people t to reconstruct all. So, he commands that people should break a single wall to make two rooms connected. An added condition is that after the wall was moved, the largest possible new roomh should be made. As the castlea t tis so bhe second lineig a of the snd people at that time is so short ample output is a blank ofline



 ways of measuring area, the people were in the trap. However, they managed to send one representative to you and ask for your help via the time machine. Can you save them out of the trap? 
Here is an example:
        1     2      3      4      5      6      7   ############################# 1 #      |      #       |       #      |        |      #   #####-----#####-----#-----#####-----#    2 #     #      |       #      #      #       #     #   #-----#####-----#####-----#####-----# 3 #     |       |       #      #       #      #     #      #-----#########-----#####-----#-----# 4 # -> #     |       |        |        |       #       #      ############################# 
# = Wall     -,|  = No wall-> = Points to the wall to remove to make the largest possible new room
By way of example, this castle sits on a 7 x 4 base. A "room" includes any set of connected "squares" in the floor plan. This floor plan contains five rooms (whose sizes are 9, 7, 3, 1, and 8 in no particular order). Removing the wall marked by the arrow merges a pair of rooms to make the largest possible room that can be made by removing a single wall. We ensure that the castle always has at least two rooms and always has a wall that can be removed. 
题目输入：
The map is stored in the form of numbers, one number for each module, M numbers on each of N lines to describe the floorplan. The input order corresponds to the numbering in the example diagram above.
Each module number tells how many of the four walls exist and is the sum of up to four integers: 

　　1: wall to the west

　　2: wall to the north

　　4: wall to the east 

　　8: wall to the south

Inner walls are defined twice; a wall to the south in module 1,1 is also indicated as a wall to the north in module 2,1. 

First comes a single integer t(t<=10), which shows that there are t cases of the input. Then each case include several lines: 

Line 1:  Two space-separated integers: M and N (M,N<=50)

Line 2..M+1:  M x N integers, N per line.  
题目输出：
The output should contain two lines: 

Line 1: The number of rooms the castle has; the size of the origin largest room; the size of the largest room creatable by removing one wall

Line 2: The single wall to remove to make the largest room possible

Choose the optimal wall to remove from the set of optimal walls by choosing the module farthest to the west (and then, if still tied, farthest to the south). If still tied, choose 'N' before 'E'. Name that wall by naming the module that borders it on either the west or south, along with a direction of N or E giving the location of the wall with respect to the module.

Print a blank line between each case, after the last case included.
输入样例：
1
7 4
11 6 11 6 3 10 6
7 9 6 13 5 15 5
1 10 12 7 13 7 5
13 11 10 8 10 12 13
输出样例：
5 9 16
4 1 E
提示：




题目：GPA(1785)
时间限制：1000MS
空间限制：65535KB
题目描述：
	In college, a student may take several courses. for each course i, he earns a certain credit (Ci), and a mark ranging from A to F, which is comparable to a score (Si), according to the following conversion table:		The GPA is the weighted average score of all courses one student may take, if we treat the credit as the weight. In other words,		An additional treatment is taken for special cases. Some courses are based on ``Pass/Not pass'' policy, where students earn a mark ``P'' for ``Pass'' and a mark ``N'' for ``Not pass''. Such courses are not supposed to be considered in computation. These special courses must be ignored for computing the correct GPA.	Specially, if a student's credit in GPA computation is 0,his/her GPA will be ``0.00''.
题目输入：
	There are several test cases, please process till EOF.	Each test case starts with a line containing one integer N (1 ≤ N ≤ 1000), the number of courses.	Then follows N lines, each consisting the credit and the mark of one course. Credit is a positive integer and less than 10.
题目输出：
	For each test case, print the GPA (rounded to two decimal places) as the answer.
输入样例：
5
2 B
3 D-
2 P
1 F
3 A
2
2 P
2 N
6
4 A
3 A
3 A
4 A
3 A
3 A
输出样例：
2.33
0.00
4.00
提示：

	For the first test case:


	 


	For the second test case: because credit in GPA computation is 0(P/N in additional treatment), so his/her GPA is ``0.00''.




题目：Wormholes(1134)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A friend  of yours,  an  inventor,  has  built  a spaceship  recently  and  wants  to  explore  space with  it. During  his first voyages, he discovered  that the  universe  is full of wormholes  created  by some alien race.  These wormholes allow one to travel  to places far, far away, but  moreover,  they  can also send you to times long ago or in the distant future.Having mapped  these wormholes and their  respective  end points, you and your friend boldly decide to board  his spaceship and go to some distant place you’d like to visit.  Of course, you want to arrive at your destination as early as possible.  The question  is: what  is this earliest  arrival  time?
题目输入：
The  first line of input  contains  an integer  c (1 ≤ c ≤ 200), the  number  of test  cases.  Each  test  case starts with a line containing  two coordinate  triples  x0 , y0 , z0  and x1 , y1 , z1 , the space coordinates of your departure point and destination. The next line contains  an integer  n (0 ≤ n ≤ 50), the number of wormholes.  Then  follow n lines, one for each wormhole, with two coordinate  triples  xs , ys , zs  and xe , ye , ze , the space coordinates  of the wormhole entry  and exit points,  respectively,  followed by two integers  t, d (−1 000 000 ≤ t, d ≤ 1 000 000), the  creation  time  t of the  wormhole and  the  time  shift d when traveling  through the wormhole.All coordinates  are integers  with absolute  values smaller than  or equal to 10 000 and  no two points are the same.Note that, initially,  the time is zero, and that tunneling through a wormhole happens  instantly. For simplicity,  the  distance  between  two  points  is defined as their  Euclidean  distance  (the  square  root of the sum of the squares of coordinate  differences) rounded  up to the nearest  integer.  Your friend’s spaceship  travels  at speed 1.
题目输出：
For each test  case, print a single line containing  an integer:  the earliest  time you can arrive  at your destination.
输入样例：
2
0 0 0 100 0 0
2
1 1 0 1 2 0 -100 -2
0 1 0 100 1 0 -150 10
0 0 0 10 0 0
1
5 0 0 -5 0 0 0 0
输出样例：
-89
10

提示：
None



题目：中缀表达式(1033)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Windows中自带了计算器程序，给我们带来了很大的方便。
在计算机的处理过中，以及我们平时所使用的计算器，大多是堆栈计算器，而这种计算器实现的最主要过程就是将中缀表达式转化为后缀表达式
例如：中缀表达式a + b * c - d 转化为后缀表达式即为a b c * + d -
作为计算机院的学生，我们要将自己当作计算机使用，所以你的任务就是，给出任意一个中缀表达式，输出它的后缀表达式的形式。
假设出入的表达式都是有意义的，并且是正确的，如：不会出现括号不匹配的问题等。
题目输入：
输入包含多组数据，以EOF结束，
每组数据都是一个表达式。用字母代代替数字，字母间不带空格。
题目输出：
输出对应的后缀表达式。
输入样例：
a+b*c-d
a*(b+c*d)-e*f
输出样例：
abc*+d-
abcd*+*ef*-
提示：




题目：心(1681)
时间限制：1000ms
空间限制：131070KB
题目描述：
		风清风冽风卷愁，云卷云舒云遍幕。 	花谢花开花漫天，思起思落思无眠。	                              ------------据说出题人的ID为WAVwind	每晚夜幕降临，微风拨动WAVwind脆弱的心弦之时，风神wind对花神xqq的思念便如丝丝绵长的云烟，飘荡穹宇……	事实上，这时候，他的每个神经元都在某一个时刻开始思念她，并持续一定的时间。现在她想知道在一个时间段内，他共有多少个不同的神经元思念过她。
题目输入：
	多组case。	对于每组case，先输入两个整数N和M。N表示风神N个神经元的信息。M表示她想询问的M个时间段。（0<N<=100000,0<M<10000）接下来N行，每行两个整数a和b，表示风神的一个神经元在a时刻开始了思念，这种感觉，望穿秋水、魂牵梦萦、朝思暮想。b代表持续的时间。（a+b为int范围内整数）。然后是M行，表示她想询问的区间，数据格式和范围同上。(N=M=0表示输入结束)
题目输出：
	每次询问输出对应的神经元个数。
输入样例：
3 2
2 5               
0 10              
5 8               
0 6
8 2
1 2
0 10       
9 1
10 1
0 0

输出样例：
3
2
1
0

提示：
None



题目：Factorials(1482)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The factorial of an integer N, written N!, is the product of all the integers from 1 through N inclusive. The factorial quickly becomes very large: 13! is too large to store in a 32-bit integer on most computers, and 70! is too large for most floating-point variables. Your task is to find the rightmost non-zero digit of n!. For example, 5! = 1 * 2 * 3 * 4 * 5 = 120, so the rightmost non-zero digit of 5! is 2. Likewise, 7! = 1 * 2 * 3 * 4 * 5 * 6 * 7 = 5040, so the rightmost non-zero digit of 7! is 4.
题目输入：
There are several test cases, end by EOF, for each test case:A single positive integer N no larger than 4,220.
题目输出：
A single line containing but a single digit: the right most non-zero digit of N! .
输入样例：
7
输出样例：
4
提示：




题目：RobotCrash(1580)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	The DoD company has contractod to determine under what conditions a pair of scanner robots can collide. The robots are fired simultaneously from ``guns" that are mounted near opposite ends of a horizontal strip. They travel in straight lines until they hit a wall of the strip or until they are in the same spot at the approximately the same time.				Whenever a robot hits a wall, it bounces off without loss of speed and in a straight line so that the angle of incidence equals the angle of reflection.				If the robots are in the same spot at approximately the same time, then they ``collide."		Write a program to determine whether robots collide and if so where. To simplify the computer model of the physical problem, assume the following.		1)	The horizontal strip is 2-dimensional, and it runs left-to-right. Its walls are straight lines.	2)	Each robot is a point mass. That is, the circumference of each robot is 0.	3)	A robot maintains the speed with which it was originally fired until it collides with the other robot or until it passes the gun from which the other robot was fired.	4)	There are 2 guns, one mounted to the left of the other on a horizontal strip. The initial angle of the left gun is between -85   and 85  . The initial angle of the right gun is between 95  and 180  or -95  and -180  . (All angles are measured counterclockwise from the positive x-axis.)	5)	Robots collide when they pass through the same place within 0.5 second of each other.	6)	The horizontal strip is 10 units high. For any point (x,y) in the strip,   .	7)	Robots speeds will be positive.	
题目输入：
	Input for your program is a text file which contains data for several different pairs of robots. The lines of the text file come in pairs. The first line of a pair gives initial firing information about the robot fired from the leftmost gun. The second line of the pair gives initial firing information about the robot fired from the rightmost gun. Each line contains 4 data items as follows:		x-coordinate y-coordinate angle speed		(all values are real numbers, angle is in degrees)		The end of input is indicated by end-of-file. Assume that the input is error-free.	
题目输出：
	To help maintain floating point accuracy when converting degrees to radians, use the predeclared constant pi.		For each robot problem, output from your program should consist of the number of the problem (ex: Robot problem #1, Robot problem #2), colon and a statement indicating whether or not the robots do collide. If they do collide, your prograrn should also print the coordinates of the point of collision. If the robots collide multiple times, write the coordinates of collision point with shortest passing interval. If there're many of such points, write the one with lowest x coordinate. All real output should be printed with 2 digits to the right of the decimal.	
输入样例：
0  4  0  3.3
40  5  125  5
1  6  -5  10
5  2  95  20
2  5  45  5
42 5  -135  5
0 6 20 3
0 5 180 4
输出样例：
Robot Problem #1: Robots do not collide.
Robot Problem #2: Robots collide at (4.68,5.68).
Robot Problem #3: Robots collide at (22.00,5.00).
Robot Problem #4: Robots do not collide.
提示：
None



题目：砝码称重(1237)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
给你一些砝码，砝码的重量为1,3,9,27……（3^m），每个砝码都有无数多个。然后给你一架天平，一个物品，问你至少需要使用多少个砝码能称出物品的重量。
题目输入：
多组测试样例，每组测试样例输入一个数n（0<n<2^31）表示物品的重量。
题目输出：
对于每组测试样例输出至少需要使用砝码的数量。
输入样例：
4
7
9
输出样例：
2
3
1
提示：
物品放一边，砝码放另一边。



题目：PoorWarehouseKeeper(1786)
时间限制：1000MS
空间限制：65535KB
题目描述：
	Jenny is a warehouse keeper. He writes down the entry records everyday. The record is shown on a screen, as follow:		There are only two buttons on the screen. Pressing the button in the first line once increases the number on the first line by 1. The cost per unit remains untouched.	For the screen above, after the button in the first line is pressed, the screen will be:		The exact total price is 7.5, but on the screen, only the integral part 7 is shown.		Pressing the button in the second line once increases the number on the second line by 1. The number in the first line remains untouched.	For the screen above, after the button in the second line is pressed, the screen will be:		Remember the exact total price is 8.5, but on the screen, only the integral part 8 is shown.		A new record will be like the following:				At that moment, the total price is exact 1.0.		Jenny expects a final screen in form of:				Where x and y are previously given.		What's the minimal number of pressing of buttons Jenny needs to achieve his goal?
题目输入：
	There are several (about 50,000) test cases, please process till EOF.	Each test case contains one line with two integers x(1 ≤ x ≤ 10) and y(1 ≤ y ≤ 109 )  separated by a single space - the expected number shown on the screen in the end.
题目输出：
	For each test case, print the minimal number of pressing of the buttons, or ``-1''(without quotes) if there's no way to achieve his goal.
输入样例：
1 1
3 8
9 31
输出样例：
0
5
11
提示：

	For the second test case, one way to achieve is:


	(1, 1) → (1, 2) → (2, 4) → (2, 5) → (3, 7.5) → (3, 8.5)


	




题目：鱼头要补课(1135)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
fishhead相当的无聊，相当的寂寞，相当的无奈，一时心血来潮，想给学生补课。
题目输入：
第一行有一个数字n，表示有n个学生，编号从1到n。(1 <= n <= 10000)。 
接下来一行有n个数，分别是编号从1到n的学生的初始能力水平xi，(1 <= xi <= 1000)。 

接下来有一行有一个数m表示老师给学生课外辅导了m天(1 <= m <= 100000)。
接下来m行，每行两个数(ai bi)，表示老师在第i天给编号为ai同学补课，编号为ai的同学能力提高了bi(0 <= ai <= n,1 <= bi <= 1000)。如果ai为0，则表示老师今天给能力最差的学生辅导。如果最低分同时有多个学生，就给编号小的学生补课。

题目输出：
输出一行，经过m天后，全班的最低分学生的编号（多个则选择编号最小的）和分数。
输入样例：
4
1 2 3 4 
3
2 2
0 3
2 1

输出样例：
3 3
提示：




题目：集训队红人(1034)
时间限制：50000 ms
空间限制：65535 ms
题目描述：
无聊的而自恋的zfacmilan想知道自己在集训队队员心里的关注程度，又不好意思每个人去问，只好想出一种很邪恶的方法去从侧面了解自己的受关注程度：他找一个黑客朋友要了一个可以记录所有键盘输入后台程序并利用自己机房管理员的邪恶身份植入了机房每台机器中（连笔记本他都不放过，当你上FTP下载PC^2的时候就已经中了这个木马了噢~），因此他每天都能获得队里所有人的键盘输入，他想通过所有的文本里面他的名字出现的频率来知道大家平时讨论他的次数，从而确定自己和队里其他人相比是不是更受欢迎。
现在一个麻烦的问题来了，集训队里面所有人每天的键盘输入字符数T是相当大的，zfacmilan根本看不过来这么长的文本，他请你帮忙写一个程序，来找出那个出现最多次的名字，以及出现的次数，并找出自己名字出现的次数。
题目输入：
多case，文件尾结束。
每个case第一行输入整个文本，总长度<=1000000。
第二行输入集训队中zfacmilan感兴趣的人数n（1
            
题目输出：
每个case输出2行。
第一行输出出现次数最多的名字，以及出现的次数，空格隔开。、
第二行输出”zfacmilan”，和他出现的次数，空格隔开。
输入样例：
Who is fishhead’s girlfriend? I don’t know, but I am curious about it. Where is zfacmilan come from? Maybe Shanxi,who cares! I love onle. I love onle. I love onle. I love onle. I love onle. I love onle. I love onle. I love onle.
3
zfacmilan
fishhead
onle
输出样例：
onle 8
zfacmilan 1
提示：
如果单词被分开将不被统计在内，例如”zf acmilan is a good team” 这段文本中不算出现过zfacmilan，因此不要随便在读入过程中去掉空格和制表符。
如果zfacmilan出现的次数最多的话，输出2次”zfacmilan 次数”。
如果有两个或两个以上单词出现次数都是最多的，则输出文本中最先达到这个次数的单词。
例如”onle onle fishhead fishhead zfacmilan” onle先达到2次，
则输出
onle 2
zfacmilan 1



题目：Economicphonecalls(1381)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The phone you bought a long time ago has a built-in memory that keeps track of all the calls you receive. It logs the date (month and day) and the time (hour and minute) of each call along with the caller's number. Only a limited number of calls can be logged (memory was still expensive then). 
You discover that the limit is almost reached and therefore plan to delete some entries from the log. In choosing the entries to delete you have to consider two restrictions: 

There are some (important) entries you want to keep. 
You want to be able to recover the year (which the phone does not log) of each call you keep. The recovery procedure is described below. 
Calculate the minimal number of entries that must be kept to satisfy these requirements. 
Recovery of years
Given a list of timestamps (consisting of month, day, hour, and minute) of calls, you find out the year of each call by the following procedure: 

The last call in the list occurred in the current year. 
You compare its timestamp t to the timestamp t' of the previous call. If t'<t, you assume that both calls occurred in the same year. If t'≥t, you assume that the previous call occured the year before. 
You iterate backwards through the list and reason as in 2. at each step. 
Note that this procedure is not correct in general, but you may assume that it is for the input you get, and you have to ensure that it gives the same result for the shortened log.
题目输入：
The input consists of several test cases. Every test case starts with the number of entries n in the log, where 1≤n≤1000. Each of the next n lines contains an entry. 

Every entry has the format mm:dd:HH:MM number ±, describing the month mm, day dd, hour HH, minute MM, and number (having 1-16 digits) of each call, followed by + marking a call you definitively want to keep and by - marking the other calls. The entries come directly from the log of the phone, that is, they are sorted by time of reception of the corresponding call (the last entry is the most recent). 

You may assume that the recovery procedure described above yields the correct year of each call.

The last test case is followed by a 0.

题目输出：
For each test case, output the minimal number of entries that must be kept to satisfy the requirements stated above. In particular, the recovery procedure described above must yield for each remaining entry the same year as derived from the corresponding input.
输入样例：
7
12:31:23:59 0123456789012345 +
07:21:19:00 1337 -
01:01:00:00 0987654321 -
07:21:14:00 1337 -
11:11:11:11 11111111111 +
01:01:00:00 0123456789 +
01:01:00:00 0987654321 -
0

输出样例：
6

提示：
Due to an error in the phone's software no calls have been logged on February 29.



题目：Stringsobits(1483)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Consider an ordered set S of strings of N (1 <= N <= 31) bits. Bits, of course, are either 0 or 1. This set of strings is interesting because it is ordered and contains all possible strings of length N that have L (1 <= L <= N) or fewer bits that are `1'. Your task is to read a number I (1 <= I <= sizeof(S)) from the input and print the Ith element of the ordered set for N bits with no more than L bits that are `1'.
题目输入：
There are several test cases, end by EOF, for each test case:A single line with three space separated integers: N, L, and I.
题目输出：
A single line containing the integer that represents the Ith element from the order set, as described.
输入样例：
5 3 19
输出样例：
10011
提示：




题目：白(1682)
时间限制：3000ms
空间限制：65535KB
题目描述：
		徐老师给她可爱的小侄子买了个玩具O(∩_∩)O~。这是一个矩形的塑料模具，从顶部看是一块块1*1的小方格，但是每个格子的高度不一样（底部是平的）。小东西喜欢拿它来装水玩，某天一个想法从徐老师脑海中划过，这个模具最多能装多少水呢？于是乎，聪明的小侄子很好地解答了这个问题，他将模具装最多的水，然后倒入一个容量瓶里看看体积。财神知道，作为ACMer的你只需一个程序就能搞定这个问题，而且问题的规模可能根本没有一个容量瓶适合。
题目输入：
	输入第一行表示case数T。对于每组数据，先输入两个整数n和m(0<n,m<500)，表示这个矩形模具的大小是n行m列。接着是n行m列个整数，表示每个格子的高度h(0<h<1000)。
题目输出：
	一个整数，表示这个模具最多装水的体积。
输入样例：
1
4 4
1 1 1 1
1 0 0 1
1 0 0 1
1 1 1 1

输出样例：
4
提示：
None



题目：GettingThere(1581)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	A frustrating part of arranging your own air travel trip is selecting from among many possible flights that sequence of flights which will take you from your origin to your destination in the least possible time or for the least possible cost.		It should be clear to any frequent air passenger that in order to reach one city from another, the cost of the shorter flight may be more than the cost of longer flights. In other words, it may pay you well to cool your heels in an airport waiting for a connecting flight rather than take a more direct flight or one in which the connecting time is shorter. For example, consider the following flight schedule.		Center City     Homeville       5:2OA  6:55A  12.50	Center City     Greenville      5:45A  9:l5A  35.00	Homeville       Greenville      7:45A  9:35A  20.00	In order to travel from Center City to Greenville, you have two choices. You can travel from Center City to Homeville, then from Homeville to Greenville, or you can travel directly from Center City to Greenville. The first route costs $32.50 and has travel time 4:15; the direct route costs $35.00 and has travel time 3:30. If minimizing cost is your objective, then you would choose the first route. If you want to minimize time, you would select the second route.		You are to write a program to optimize route selection given the criteria of least cost or least time. Your program will read a list of flights and several trip rcquests and will select from the list of flights the best sequence to satisfy each trip request. For each request, if more than one route should satisfy the request, then your program should select the route that also satisfies the other objective. For example, if cost is to be minimizad and if two routes both yield the minimum cost, then select the route which yields the shortest travel time. If two routes yield identical costs and travel times, then select either route.	
题目输入：
	The input consists of several blocks. First line contains number of these blocks. Every block is broken into two segments, the first describing the list of flights and the second containing the trip requests. The end of each segment is indicated by the line consisting of the single character `#'.		The flight segment of the file describes individual flights, one per line. Each line contains the origin city (columns 1 through 19), the destination city (columns 21 through 39), the departure time (columns 41 through 46). the arrival time (columns 48 through 53), and the cost (columns 55 through 60). City names are left-justified in their respective fields, and may contain upper and lower case characters and spaces. Times are in the form HH:MMX, where HH is the hour (a leading zero may be replaced by a blank), MM is the minutes (exactly two digits will appear), and X is A (for AM), P (for PM), or M or N (this can be used only after 12:00 to distinguish midnight from noon). The cost of the ticket is in dollars and cents, and includes a decimal point and two fractional digits. No tickets are free or cost more than $999.99. No individual flight represented by a line in the schedule takes more than 24 hours. There will be at most 20 flights on the schedule.		The trip request segment follows the list of flights. Each request appears on a line by itself, and specifies the origin city (columns 1 to 19), the destination city (columns 21 to 39), and whether to optimize cost or travel time. If it is desired to optimize travel time, the word TIME is in columns 41 to 44. If cost is to be optimized, then the word COST is in columns 41 to 44. There may be trailing blanks in any line in the flight schedule or the trip requests.	
题目输出：
	For each travel request, display the request and the optimal route in the form shown below. Notice that trailing spaces are removed from city names. Time is output in the form <hh>:<mm>, where <hh> goes from 0 to 23 and <mm> goes from 0 to 59. If the trip takes more than one day, the time output starts with the number of days and string "day" appended (or "days" if the flight takes more than 48 hours). There are no leading zeroes nor blanks allowed.		All optimum routes will require less than 10 days and less than $1,000.00. Place exactly one blank line between the outputs for successive trips.	
输入样例：
1
Center City      Homeville        5:2OA 6:55A     12.50
Center City      Greenville       5:45A 9:l5A     35.00
Homeville        Greenville       7:45A 9:35A     20.00
Archer City      Homeville        5:OOA 6:OOP    612.50
#
Center City      Greenville       COST
Archer City      Greenville       TIME
#
输出样例：
Center City->Greenville,4:15,32.50
Center City->Homeville,5:20-6:55,12.50
Homeville->Greenville,7:45-9:35,20.00

Archer City->Greenville,1 day 4:35,632.50
Archer City->Homeville,5:00-18:00,612.50
Homeville->Greenville,7:45-9:35,20.00
提示：
None



题目：AnInterestingSequence(1035)
时间限制：2000 ms
空间限制：65536 ms
题目描述：
YiYi is a smart boy, he is fascinated in solving eccentric problems. One day when he was reading a book, he came across a very interesting problem. After a few time’s thinking, he finally get the solution. YiYi considers this solution very heuristic, now he decides to show this problem to you so that you can also enjoy the happiness of solving this interesting problem. Here is the description of the problem:
Suppose at first you have a sequence, S1, consists of two numbers: 1, 1. According to some rule you can get the sequence Sn from the sequence Sn-1.Once you get Sn-1, you will be asked to insert one n between a and b if a and b are two adjacent numbers in Sn-1 and a + b = n. After you have inserted all possible n you finally get Sn. You can also get the sequence Sn+1 using the same method and so on.  
For example,S1 = 1,1.Since 1 + 1 = 2, we will insert 2 between two 1s and then we get S2, S2 = 1,2,1. Now we will insert two 3s in the sequence to get S3, as you can see, S3 = 1,3,2,3,1. In the same way, we know S4 = 1,4,3,2,3,4,1, S5 = 1,5,4,3,5,2,5,3,4,5,1 and so on. 
Here the question comes: give you n, you will be asked to output the number of n in Sn. For example if n = 5, you will output 4 since there are 4 5s in S5.
题目输入：
The first line of the input contains a number k, the number of test cases to solve (1 ≤ k ≤ 200). Each test case consists of a single integer 2 ≤ n ≤ 1010 on a separate line.
题目输出：
For each test case, you are asked to output the number of n in Sn on a line.
输入样例：
3
2
4
5

输出样例：
1
2
4

提示：




题目：休息站(1238)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
在一个遥远的地方有一个百岛国，这里有n个岛，每个岛编号为1..n，岛之间都有双向的路径连着，岛之间的距离小于1000。今年千岛国的国王要从s岛到t岛处理事情，因为事情紧急，国王一定会走从s到t的最短的路，国王可能经过的岛都要建一个休息处，问要建的休息处的数量。
题目输入：
多组测试数据，对于每组测试数据第一行输入n（0<n<200），m（0<m<n*n/2）,接下来输入一个n*n的矩阵，表示各个岛之间的距离,接下来m行，每行输入两个数，s（1<=s<=n），t（1<=t<=n）。
题目输出：
对于每组测试样例的s和t输出要建的休息站的数量。
输入样例：
5 2
0 2 4 10 10
2 0 1 3 10
4 1 0 2 10
10 3 2 0 2
10 10 10 2 0
1 5
2 4
输出样例：
5
3
提示：




题目：CampusDesign(1787)
时间限制：6000MS
空间限制：65535KB
题目描述：
	Nanjing University of Science and Technology is celebrating its 60th anniversary. In order to make room for student activities, to make the university a more pleasant place for learning, and to beautify the campus, the college administrator decided to start construction on an open space.	The designers measured the open space and came to a conclusion that the open space is a rectangle with a length of n meters and a width of m meters. Then they split the open space into n × m squares. To make it more beautiful, the designer decides to cover the open space with 1 × 1 bricks and 1 × 2 bricks, according to the following rules:	1. All the bricks can be placed horizontally or vertically	2. The vertexes of the bricks should be placed on integer lattice points	3. The number of 1 × 1 bricks shouldn’t be less than C or more than D. The number of	    1 × 2 bricks is unlimited.	4. Some squares have a flowerbed on it, so it should not be covered by any brick. (We use 0 to represent a square with     flowerbed and 1 to represent other squares)	Now the designers want to know how many ways are there to cover the open space, meeting the above requirements.	
题目输入：
	There are several test cases, please process till EOF.	Each test case starts with a line containing four integers N (1 ≤ N ≤ 100), M (1 ≤ M ≤ 10), C, D(1 ≤ C ≤ D ≤ 20). Then following N lines, each being a string with the length of M . The string consists of ‘0’ and ‘1’ only, where ‘0’ means the square should not be covered by any brick, and ‘1’ otherwise.	
题目输出：
	Please print one line per test case. Each line should contain an integers representing the answer to the problem (mod 109 + 7).	
输入样例：
1 1 0 0
1
1 1 1 2
0
1 1 1 2
1
1 2 1 2
11
1 2 0 2
01
1 2 0 2
11
2 2 0 0
10
10
2 2 0 0
01
10
2 2 0 0
11
11
4 5 3 5
11111
11011
10101
11111
输出样例：
0
0
1
1
1
2
1
0
2
954
提示：
None



题目：SpinningWheels(1484)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Each of five opaque spinning wheels has one or more wedges cut out of its edges. These wedges must be aligned quickly and correctly. Each wheel also has an alignment mark (at 0 degrees) so that the wheels can all be started in a known position. Wheels rotate in the `plus degrees' direction, so that shortly after they start, they pass through 1 degree, 2 degrees, etc. (though probably not at the same time). This is an integer problem. Wheels are never actually at 1.5 degrees or 23.51234123 degrees. For example, the wheels are considered to move instantaneously from 20 to 25 degrees during a single second or even from 30 to 40 degrees if the wheel is spinning quickly. All angles in this problem are presumed to be integers in the range 0 <= angle <= 359. The angle of 0 degrees follows the angle of 359 degrees. Each wheel rotates at a certain integer number of degrees per second, 1 <= speed <= 180. Wedges for each wheel are specified by an integer start angle and integer angle size (or `extent'), both specified in degrees. Wedges in the test data will be separated by at least one degree. The 'extent' also includes the original "degree" of the wedge, so '0 180' means degrees 0..180 inclusive -- one more than most would imagine. At the start, which is time 0, all the wheels' alignment marks line up. Your program must determine the earliest time (integer seconds) at or after the start that some wedge on each wheel will align with the wedges on the other wheel so that a light beam can pass through openings on all five wedges. The wedges can align at any part of the rotation.
题目输入：
There are several test cases, end by EOF, for each test case:Each of five input lines describes a wheel. The first integer on an input line is the wheel's rotation speed. The next integer is the number of wedges, 1 <= W <= 5. The next W pairs of integers tell each wedge's start angle and extent.
题目输出：
A single line with a single integer that is the first time the wedges align so a light beam can pass through them. Print `none' (lower case, no quotes) if the wedges will never align properly.
输入样例：
30 1 0 120
50 1 150 90
60 1 60 90
70 1 180 180
90 1 180 60
输出样例：
9
提示：




题目：首(1683)
时间限制：1000ms
空间限制：65535KB
题目描述：
		徐老师下课看着同学们做老鹰抓小鸡的游戏，发现一个有趣的现象：对于一定的队形，下一个变换到的队形也是固定的几个（比如杨洁同学就喜欢紧跟翟尚进同学后面\(^o^)/~）。例如，队伍中5个人，从鸡妈妈往后面编号分别为01234，徐老师观察到下一个队形不是12430就是04123（或许1号是翟尚进，2号是杨洁小朋友O(∩_∩)O~）。
题目输入：
	对于每组数据，一个整数N(N<10)表示队伍中的总人数。然后是一个整数M(M<500000)，表示M种可能的队形变换。接下来M行，每行为两个编号序列a和b，表示从a可以变换到b（a和b分别为从0~N-1的一个排列）。
题目输出：
	从输入中出现的编号最小的一个序列变换到输入中出现的编号最大的一个序列，最少要经过多少步变换，数据保证有解。（序列大小的定义你们懂的，理解为字典序或者数字大小均可）。
输入样例：
3  4
012  021
012  120
021  120
120  210

输出样例：
2
提示：
None



题目：定时炸弹(1136)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
看哥下面p的图片：




在一个迷宫中，那个机器人想要到走到出口处。
但是这个迷宫将在6秒钟后爆炸。
每走一步耗费1秒钟。显然我所画的图，必死。
但是，在迷宫中有时间回轮基地。一走到，爆炸时间重新定为6秒。
规定：走到出口时，或走到时间回转基地是爆炸时间必须大于0。
现在为机器人写一段ai程序：
根据地图，若能走出迷宫则输出最短路径（移动一个网格，算一个单位），若不能，则输出.网格范围小于10*10



题目输入：
第一行一个整数t，代表下面有多少个案例。
每一个案例：第一行n,m代表迷宫的行数和列数。以下n行描述迷宫。
2代表你当前的位置；
3代表你要到达的目的地；
1代表可行走的网格；
0代表不可行的网格（墙）；
4代表时间回转基地。
第一行一个整数t，代表下面有多少个案例。
每一个案例：第一行n,m代表迷宫的行数和列数。以下n行描述迷宫。
2代表你当前的位置；
3代表你要到达的目的地；
1代表可行走的网格；
0代表不可行的网格（墙）；
4代表时间回转基地。
第一行一个整数t，代表下面有多少个案例。
每一个案例：第一行n,m代表迷宫的行数和列数。以下n行描述迷宫。
2代表你当前的位置；
3代表你要到达的目的地；
1代表可行走的网格；
0代表不可行的网格（墙）；
4代表时间回转基地。

题目输出：
最短路径长，没有则输出-1。
输入样例：
3
3 3
2 1 1
1 1 0
1 1 3
4 8
2 1 1 0 1 1 1 0
1 0 4 1 1 0 4 1
1 0 0 0 0 0 0 1
1 1 1 4 1 1 1 3
5 8
1 2 1 1 1 1 1 4 
1 0 0 0 1 0 0 1 
1 4 1 0 1 1 0 1 
1 0 0 0 0 3 0 1 
1 1 4 1 1 1 1 1

输出样例：
4
-1
13

提示：




题目：FlaviusJosephusReloaded(1382)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
Flavius Josephus once was trapped in a cave together with his comrade soldiers surrounded by Romans. All of Josephus' fellow soldiers preferred not to surrender but to commit suicide. So they all formed a circle and agreed on a number k. Every k-th person in the circle would then commit suicide. However, Josephus had different priorities and didn't want to die just yet. According to the legend he managed to find the safe spot in the circle where he would be the last one to commit suicide. He surrendered to the Romans and became a citizen of Rome a few years later. 
It is a lesser known fact that the souls of Josephus and his comrades were all born again in modern times. Obviously Josephus and his reborn fellow soldiers wanted to avoid a similar fiasco in the future. Thus they asked a consulting company to work out a better decision scheme. The company came up with the following scheme: 

For the sake of tradition all soldiers should stand in a circle. This way a number between 0 and N-1 is assigned to each soldier, where N is the number of soldiers. 
As changing numbers in the old scheme turned out to be horribly inefficient, the number assigned to a soldier will not change throughout the game. 
The consulting company will provide two numbers a and b which will be used to calculate the number of the next soldier as follows: Let x be the number of the current soldier, then the number of the next soldier is the remainder of a·x2 + b mod N. 
We start with the soldier with number 0 and each soldier calculates the number of the next soldier according to the formula above. 
As everyone deserves a second chance a soldier will commit suicide once his number is calculated for the second time. 
In the event that the number of a soldier is calculated for the third time the game will end and all remaining soldiers will surrender. 
You are to write a program that given the number of soldiers N and the constants a and b determines the number of survivors.
题目输入：
The input file consists of several test cases. Each test case consists of a single line containing the three integers N (2 ≤ N ≤ 109), a and b (0 ≤ a,b < N) separated by white space. You may safely assume that the first soldier dies after no more than one million (106) steps. The input is terminated by a single number 0 which should not be processed.
题目输出：
For each test case output a single line containing the number of soldiers that survive.
输入样例：
2 1 1
5 1 1
10 3 7
101 9 2
698253463 1 181945480
1000000000 999999999 999999999
0

输出样例：
0
2
4
96
698177783
999999994

提示：




题目：MealsonWheelsRoutingSystem(1582)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	The Meals on Wheels program has the responsability for providing hot meals to homebound senior citizens within the city. Volunteer drivers deliver the meals in a timely manner to ensure that they are still hot on arrival. The list of customers for meals and the number of available drivers varies on a daily basis. For each day, management tries to assign drivers routes so that allocation of customers is as even as possible among the routes.		An algorithm for developing the daily routes involves sorting the addresses of the meal customers based on the directions of their locations relative to the Meals on Wheels headquarters and dividing this sorted list among the available drivers. The Meals on Wheels headquarters is considered to be located at the origin on a cartesian grid of square city blocks. Each customer's address has been converted into the number of city blocks in the x and y directions from the Meals on Wheels facility. For example, a customer living at location (3,-2) would be living 3 blocks east and 2 blocks south of the Meals on Wheels headquarters.		Write a computer program to determine routing for several different days. For each day, your program will read in the number of drivers (routes) and number of customers followed by sets of names and locations for the customers. Allocate customers to routes using the following strategy.		Find the polar coordinate of each customer's location. Consider 0   to be due east and 90   to be due north.	Sort the sets of polar coordinates by angle and then divide the customers as equally as possible among the available routes starting at the angle of smallest measure.	Assign the customers to the routes with increasing polar angle.	Routes with customers at high degree angles should not have more customers than those for customers of lower degree angles.	If two customers are at the same angle, then assign the customer nearer to the Meals on Wheels headquarters before you assign the one further away.	If the above written rules doesn't help to break the tie, assign the customer first in input set before the customer later in input.	The difference in the number of customers assigned to any two routes may not exceed one.	Your program will determine not only the route for each driver but also the total length of each route. Tbe length of any route includes the sum of the distances from the Meals on Wheels headquarters to the first customer, plus the distances between subsequent customers (in the order they were assigned to the route) , plus the distance back to the headquarters from the last customer on the route. Note that a block may not be traversed diagonally, and all city blocks are squares.	
题目输入：
	Input consists of multiple data sets in which the first line is a data set ID and the second line contains the number of routes followed by the number of customers. The remaining lines of the data set are arranged in pairs, one pair per customer. The first line of each pair is the customer's name and the second line contains the x and y coordinates of where that customer lives. So each data set is arranged in the following manner.			Line 1: data set ID (string -> maximum length 50 charactars)	Line 2: n m (number of routes, number of customers -> positive integers)	The next 2m lines come in pairs:	Line 3: customer name (string -> maximum length 25 characters)	Line 4: x-coordinate y-coordinate (x and y coordinates for the preceding customer -> integers)	Assume the input is correct and the number of routes does not exceed the number of customers. Number of customers doesn't exceed 4000. Assume also that any result will fit into basic integer type (int for C language). The end of input is indicated by end-of-file.	
题目输出：
	For each data set your output should include the data set ID. On next line there should be text "Number of Customers: ", followed by the number of customers, then " Number of Routes: " and the number of routes. Then you should write series of blocks for each route. The single block should contain number of the route, sequence of customers (in order they were assigned to the route) and total length of the route. See the example for exact format of the route description. Route blocks are delimited by an empty line. Then you should output total length of all routes in this data set. Print a row of 40 asterisks between output for successive data sets.	
输入样例：
Sample Route List
4 10
able
1 2
baker
-3 6
charlie
-4 -5
donald
4 -7
eloise
3 4
frank
2 2
gertrude
5 9
horace
-2 -5
inez
5 -3
james
0 1
输出样例：
Sample Route List
Number of Customers: 10 Number of Routes: 4

Route ==> 1
Customer: frank
Customer: eloise
Customer: gertrude
Route Length ==> 28

Route ==> 2
Customer: able
Customer: james
Customer: baker
Route Length ==> 22

Route ==> 3
Customer: charlie
Customer: horace
Route Length ==> 18

Route ==> 4
Customer: donald
Customer: inez
Route Length ==> 24

Total Route Length ==> 92
****************************************
提示：
None



题目：Shoot(1788)
时间限制：5000MS
空间限制：65535KB
题目描述：
	At the year of 8192, the war between Evil Army and Galaxy Army broken out. Unfortunately,Evil Army had conquered half the galaxy in just one year. To prevent the situation of the war from getting worse, Levi, the general of Galaxy Elite Army, was ordered by his superior to attack the  enemy’s power bases.	Levi was born with the remarkable ability of counter-surveillance, it was just a piece of cake for him to reach Evil Army’s power bases. Each power base can be represented as a triangle in 3D-Cartesian coordinate system. The only weapon Levi had was a laser cannon which can shoot in both two directions simultaneously. To avoid being caught by enemy, Levi can only place the laser cannon somewhere on a segment from S to T. Unfortunately, there was something wrong with the laser cannon, Levi can’t adjust its shooting angle, so the shooting direction was fixed.	Since Levi didn’t have any time to find the best place to shoot the laser, he decided to select a point on the segment randomly to place the cannon. If the laser touched the base(even the boundary), the base will be destroyed. Your task is to calculate the expected number of the destroyed bases in just one shoot.	It is recommended to see the sample input to understand the problem statement more clearly.
题目输入：
		There are several test cases, please process till EOF.	For each test case, the first line is an integer N (1<=N <=100000), the number of enemy’s power bases. Each of the next three lines contains 3 integers, x, y, z, denoting the coordinates of S, T, and the fixed shooting direction. The last N lines contains 9 integers, x1, y1, z1, x2, y2, z2, x3, y3, z3, denoting the coordinates of the three vertices of enemy’s power base. It is guaranteed that all the triangles will not degenerate.	And the absolute value of all numbers except N will not exceed 1000.	
题目输出：
	For each test case, print the expected number of destroyed power bases.	Any answer within an absolute error less than or equal to 10^6 would be accepted.
输入样例：
20
0 0 0
2 0 0
0 0 1
-1 0 1 1 0 1 -1 0 2
1 1 -1 1 -1 -1 2 0 -1
输出样例：
1.00000000
提示：
None



题目：大逃亡(1239)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
一群犯人在1号点，他们要逃出监狱N（到1<N<200号点），每到一个关卡，他们会被抓住一些人，路上也会有一些人因为害怕而放弃逃亡。这一群人中最多会有几人能胜利大逃亡呢？(1和N也是一个关卡)
题目输入：
第一行n，N，M，分别表示有n个犯人在关卡1，N个关卡，M条路连接关卡，这些路是有向的。
第二行有N个数，表示通过i号关卡会被抓的人数。
余下M行有a，b，c三个数，表示连接关卡a，b，有一条路，会使c<100个人害怕得逃跑。
（多组case 以n为0结尾,会有重边）
题目输出：
一个整数，最多能逃跑的人数，如果不能输出0.
输入样例：
8 2 1
1 2
1 2 1
0
输出样例：
4
提示：




题目：FeedRatios(1485)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer John feeds his cows only the finest mixture of cow food, which has three components: Barley, Oats, and Wheat. While he knows the precise mixture of these easily mixable grains, he can not buy that mixture! He buys three other mixtures of the three grains and then combines them to form the perfect mixture. Given a set of integer ratios barley:oats:wheat, find a way to combine them IN INTEGER MULTIPLES to form a mix with some goal ratio x:y:z. For example, given the goal 3:4:5 and the ratios of three mixtures:         1:2:3        3:7:1        2:1:2your program should find some minimum number of integer units (the `mixture') of the first, second, and third mixture that should be mixed together to achieve the goal ratio or print `NONE'. `Minimum number' means the sum of the three non-negative mixture integers is minimized. For this example, you can combine eight units of mixture 1, one unit of mixture 2, and five units of mixture 3 to get seven units of the goal ratio:     8*(1:2:3) + 1*(3:7:1) + 5*(2:1:2) = (21:28:35) = 7*(3:4:5)Integers in the goal ratio and mixture ratios are all non-negative and smaller than 100 in magnitude. The number of units of each type of feed in the mixture must be less than 100. The mixture ratios are not linear combinations of each other.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  Three space separated integers that represent the goal ratios Line 2..4:  Each contain three space separated integers that represent the ratios of the three mixtures purchased.
题目输出：
The output file should contain one line containing four integers or the word `NONE'. The first three integers should represent the number of units of each mixture to use to obtain the goal ratio. The fourth number should be the multiple of the goal ratio obtained by mixing the initial feed using the first three integers as mixing ratios.
输入样例：
3 4 5
1 2 3
3 7 1
2 1 2
输出样例：
8 1 5 7
提示：




题目：TwinkleTwinkleLittleStar(1036)
时间限制：3000 ms
空间限制：65536 ms
题目描述：
Twinkle, twinkle, little star, how I wonder what you are.
Up above the world so high, like a diamond in the sky.
Twinkle, twinkle, little star, how I wonder what you are.
When the blazing sun is gone, when he nothing shines upon.
The you show your little light, Twinkle, twinkle, little star
Twinkle, twinkle, little star, How I wonder what you are.
Twinkle, twinkle, little star, how I wonder what you are.
----
Well, this song may take us back to our childhood. When we were young, we often looked up at the stars. How amazing they were! But, unfortunately, as we are becoming older and older, what used to be interesting can not interest us now. So what we can do is to find something more interesting!
Here is one, maybe. Assume that all the stars are so far from us that we can treat them as points in a plane. You are given N stars in the plane, and a number K (0≤K≤N). What you need to do is to find the minimum square covering at least K stars, whose edges are all parallel to the axis. The stars which are on the edges of the square are also covered.
题目输入：
The input will consist of multiple cases. Your program should process to the end of the input file.In the first line of one case, there are two integer N and K, 0
            
题目输出：
The output will consist of one line for each case, in the format of “Case X: Y”, while X is the case number counting from 1, and Y is the edge length of the minimum square. X and Y are all integers.

输入样例：
4 4
0 0
0 1
1 0
2 2
4 2
0 0
1 1
2 2
3 3
输出样例：
Case 1: 2
Case 2: 1
提示：




题目：不(1684)
时间限制：5000ms
空间限制：65535KB
题目描述：
		别出心裁的徐老师今天上课又要和学生们做游戏了O(∩_∩)O~，这次她准备练练学生们的记忆力。	游戏是这样的：她给每人发一张写着一个整数的卡片，卡片上的数都不一样，起初学生们都站在教室外。徐老师开始报数，拿着对应卡片的学生就进入教室，当然游戏没这么简单。报数过程中，徐老师会对所有学生进行一些询问，学生们进行抢答，答对一次加一点积分，游戏结束后积分最高者会得到徐老师奖励的小红花一朵哦 ^_^	询问的形式是这样的：	1.       给出一个数存在的X,询问目前教室里卡片上所有数中第X小的数是多少	2.       给出一个数X,询问目前教室里卡片上所有数中与X最接近的数是多少(相等返回较小的一个~)	3.       给出一个已经在教室里的卡片上的数，询问将目前教室里的数从小到大排列，这个数的排名是多少（排名从1开始）
题目输入：
	多组输入数据。	每组第一个数M，表示进行M次询问和报数。(M<=1000000)	接着M行，每行是一个字符串加一个数字（X<2^31）的形式。字符串如果是“I”，表示将拿着X对应卡片的同学进入教室;字符串若是“LOVE”，表示询问操作1;字符串若是“U”，表示询问操作2;字符串若是“FOREVER”,表示询问操作3.
题目输出：
	对于对应的询问操作，输出相应的结果。
输入样例：
5
I  5
I  10
LOVE 2
U 7
FOREVER 5

输出样例：
10
5
1

提示：
None



题目：WinetradinginGergovia(1383)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
As you may know from the comic "Asterix and the Chieftain's Shield", Gergovia consists of one street, and every inhabitant of the city is a wine salesman. You wonder how this economy works? Simple enough: everyone buys wine from other inhabitants of the city. Every day each inhabitant decides how much wine he wants to buy or sell. Interestingly, demand and supply is always the same, so that each inhabitant gets what he wants.
There is one problem, however: Transporting wine from one house to another results in work. Since all wines are equally good, the inhabitants of Gergovia don't care which persons they are doing trade with, they are only interested in selling or buying a specific amount of wine. They are clever enough to figure out a way of trading so that the overall amount of work needed for transports is minimized.
In this problem you are asked to reconstruct the trading during one day in Gergovia. For simplicity we will assume that the houses are built along a straight line with equal distance between adjacent houses. Transporting one bottle of wine from one house to an adjacent house results in one unit of work.
题目输入：
The input consists of several test cases.
Each test case starts with the number of inhabitants n (2 ≤ n ≤ 100000). The following line contains n integers ai (-1000 ≤ ai ≤ 1000). If ai ≥ 0, it means that the inhabitant living in the ith house wants to buy ai bottles of wine, otherwise if ai < 0, he wants to sell -ai bottles of wine. You may assume that the numbers ai sum up to 0.
The last test case is followed by a line containing 0.
题目输出：
For each test case print the minimum amount of work units needed so that every inhabitant has his demand fulfilled. You may assume that this number fits into a signed 64-bit integer (in C/C++ you can use the data type "long long", in JAVA the data type "long").
输入样例：
5
5 -4 1 -3 1
6
-1000 -1000 -1000 1000 1000 1000
0

输出样例：
9
9000

提示：




题目：解方程(1137)
时间限制：1000 ms
空间限制：65535 ms
题目描述：

一天，一位mm做一道数学题，苦思不得其解。
第二天，mm又做这道数学题，还是无法攻破。
第三天，mm又做同一道数学题，发现这题真不是人做的。
到底这是这是一道什么数学题，请看下行叙述：
解方程：
sin(x)/x=0.5；   (3.14/2<=x<=3.14)
解要精确到10^-8


题目输入：
NOTHING
题目输出：
输出一行，x，精确到小数点后8位。
输入样例：
NOTHIING
输出样例：
不告诉你~~~~~~~自己猜~~~~~~
提示：




题目：PGATourPrizeMoney(1583)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	A PGA (Professional Golf Association) Tour event is a golf tournament in which prize money is awarded to the best players. The tournament is broken into four rounds of 18 holes apiece. All players are eligible to play the first two rounds. Only those with the best scores from those 36 holes ``make the first cut" to play the final two rounds and qualify for prize money. Players with the best 72-hole aggregate scores (the lowest scores) earn prize money.		You must write a program to determine how the total prize money (called the tournament ``purse") is to be allocated for a tournament. Specifications are as follows.		1)	All players will play at least two 18-hole rounds (36 holes in all) unless they are disqualified for some reason.	2)	Any player who is disqualified stops playing at the time of the disqualification. Players who are disqualified during the first two rounds are ineligible to make the cut. Players who are disqualified during either of the last two rounds are ineligible to win prize money.	3)	At the end of the first two rounds, the field of players is cut to the 70 players with the lowest 36-hole scores plus ties. So if 10 players are tied for 70th place, then 79 players make the 36-hole cut. Players who do not make the 36-hole cut are eliminated from the playing field and do not win any prize money.	4)	The players who do make the 36-hole cut play an additional 36 holes (two 18-hole rounds) and are paid a percentage of the total prize money depending on their 72-hole aggregate score. The lower the score, the more prize money a player wins.	5)	Players are paid percentages of the the tournament purse according to their final standings. For example, if the tournament purse were $1,000,000 and the winner's share were 18%, the winner would earn $180,000.	6)	There will be only one winner of this tournament. (In an actual golf tournament, when there is a tie for the low 72-hole score, there is be a play-off among the tied players. We will ignore that situation.)	7)	There may be a tie for any or all of the positions between 2 and 70. If there is a tie among n players for position k, the money designated for positions k through n + k - 1 is pooled and allocated equally among the tied players. For example, using the sample data given later, if there were a tie for second place between two golfers, they would each win $88,000 [(10.8% + 6.8%)/2 = 8.8% * $1,000,000]. If there were a three-way tie, all three golfers would get $74,666.66 [(10.8% + 6.8% + 4.8%)/3 = 7.4666% * $1,000,000]. The extra penny is ignored.	8)	If disqualification reduces the field to less than 70 players, the money for the last and any other places not covered is not allocated. For example, if exactly 70 players make the cut but three of them are disqualified, then the tournament simply pays 67 places.	9)	Amateur golfers may play in professional tournaments but can win no money. Any prize money ``won" by an amateur is allocated to the next lower position. For example, if an amateur has placed third in a tournament, then third place money goes to the fourth place finisher, and fourth place money goes to the fifth place finisher, etc.	10)	Only the low 70 non-amateur places and ties earn prize money. For example, if 75 players make the 36-hole cut, it is possible for 5 of them not to earn prize money, assuming none of the players making the cut are amateurs.	
题目输入：
	The input contains multiple tournaments. There's line with number of players attending the tournament (always less than 145) and then follow two segments of data of the tournament. Zero players denotes end of input file. The amount of the tournament purse and the percentages for all the 70 places are stored in the first segment of the input file. This segment contains exactly 71 lines, which are formatted as follows.			Line 1: 	 Total value of the purse	Line 2: 	 Percentage of the purse designated for first place	Line 3: 	 Percentage of the purse designated for second place	...	Line71: 	 Percentage of the purse designated for 70th place	The purse is given to two decimal places. All percentages are given to four decimal places. Assume the percentages are correct and sum to 100%. No tournament has purse bigger than $40 millions. A partial sample of the first segment of the input file is shown below.		1000000.00	18.0000	10.8000	6.8000	4.8000	...	0.2020	0.2000	The second segment contains the players' names and their respective scores for the four rounds. The format of each line is as follows.			Characters 1-20:  Player name	Character  21:    Single space      	Characters 22-24: Round 1 score (first 18 holes)	Character  25:    Single space	Characters 26-28: Round 2 score (second 18 holes)	Character  29:    Single space	Characters 30-32: Round 3 score (third 18 holes)	Character  33:    Single space	Characters 34-36: Round 4 score (fourth 18 holes)	Any player who has an asterisk `*' as the last non-space character in name column is an amateur. All players who are not disqualified will have four 18-hole scores listed. (Even though in an actual tournament, players who do not make the cut do not get to play the last two rounds of the tournament, for the purposes of this program all players who are not disqualified will have four 18-hole scores listed.) A player who is disqualified during a round will have a score on that round shown as `DQ'. That player will have no additional scores for the tournament. Assume that at least 70 players will make the 36-hole cut.		Sample lines from the second segment of the input file are as follows.		WALLY WEDGE          70  70  70  70	SANDY LIE            80  DQ	SID SHANKER*         100 99  62  61	JIMMY ABLE           69  73  80  DQ	
题目输出：
	Output from this program consists of names of all players who made the 36-hole cut, their finish positions (with the letter ``T" after the numeric value representing the finish position if there is a tie for that position , write the players with tie in the order they were in input set ), scores for each round, total scores, and the amounts of money won. Disqualified players are listed at the bottom with scores of DQ placed in the ``TOTAL" column; those disqualified should be written in the order they appeared in input set. No player who failed to make the 36-hole cut is listed in the output. Each column of output should be formatted and labelled appropriately. The dollar amounts should be correct to two decimal places. Note that Money Won column is right aligned, and that amateure golfers as well as disqualified ones have that column filled with spaces until the right edge of table. At the end of table write empty line to separate distinct tournaments. Sample output is shown below: Note: The ruler is written here only for your convenience, don't write it in output of your program.		1         2         3         4         5         6	12345678901234567890123456789012345678901234567890123456789012345	Player Name          Place RD1  RD2  RD3  RD4  TOTAL    Money Won	-----------------------------------------------------------------	WALLY WEDGE          1     70   70   70   70   280      180000.00	TOMMY TWO IRON       2T    71   72   72   72   287       88000.00	HENRY HACKER         2T    77   70   70   70   287       88000.00	NORMAN NIBLICK*      4T    72   72   72   72   288              	BEN BIRDIE           4T    70   74   72   72   288       48000.00	...	LEE THREE WINES      70    99   99   99   99   396        2000.00	JIMMY ABLE                 69   73   80        DQ                	EDDIE EAGLE                71   71             DQ                	
输入样例：
no input
输出样例：
no output
提示：
None



题目：CircularLamps(1789)
时间限制：1000
空间限制：65535
题目描述：
The circular roundabout of 2nd road is an important traﬃc junction in Nanjing University of Science and Technology. To celebrate the 60th anniversary, the school oﬃcer decides to build some lamps with digital shape surrounding the circular roundabout. There are 2N lamps to build. Lamps have the shape of digits, ranging from 1 to 2N. Specially, lamps will be built as a whole which can’t be split into single numbers. For example, lamp 19 can’t be split into lamp 1 and lamp 9. Since the roundabout is circular, the last lamp is next to the ﬁrst lamp. Unfortunately, due to the carelessness of the construction team, some lamps are placed in the wrong position. Since the construction team is now absent after ﬁnishing their work, we could only correct the order of lamps by ourselves. After rearrangement, the lamp with the shape i (1 ≤ i ≤ 2N) is expected to be placed on the i-th position. In other words, the ﬁnal permutation should be 1,2,...,2N. Because of the large volume of the lamps, we have only two ways to adjust the order
	1) Reverse the consecutive 4 lamps starting from the position x, denotes as (1 x). For example: (1 4): 1 2 3 [4 5 6 7] 8 → 1 2 3 [7 6 5 4] 8 or (1 6): 1] 2 3 4 5 [6 7 8 → 6] 2 3 4 5 [1 8 7 where ‘[’ stands for the start position, and ‘]’ stands for the end position respectively.
	2) Shift all lamps to the left by x positions, denotes as (2 x). For example: (2 4): 1 2 3 4 5 6 7 8 → 5 6 7 8 1 2 3 4 or (2 7): 1 2 3 4 5 6 7 8 → 8 1 2 3 4 5 6 7
	The data guarantees the existence of a valid adjustment sequence. Also the case where all lamps are already placed correctly will not exist in the input. Your task is to generate a valid adjustment sequence that all lamps are put on the correct position.
题目输入：
There are several test cases, please process till EOF. Each test case starts with a line containing one integers N(2 ≤ N ≤ 30). The next line contains 2N diﬀerent integers, the i-th number Ai denotes that the shape of the i-th lamp is Ai(1 ≤ Ai ≤ 2N).
题目输出：
For each test case, the ﬁrst line of the output should contain a single integer S ≤ 400000, denoting the number of swap operations you need to perform. Each of the following S lines should consist of two integers. The ﬁrst one may be 1 or 2, indicating the type of swap operations. For the ﬁrst type, the second number is the start position of the operation, and for the second type, the second number is the positions you need to shift. In both cases, the second number should be ranged between 1 and 2N. If there are multiple possible solutions satisfying the conditions above, any one will be accepted. Please don’t print extra empty lines, spaces and other irrelevant characters.
输入样例：
4
6 5 4 3 2 1 8 7
4
4 5 1 2 3 6 7 8
4
7 8 4 3 2 1 5 6

输出样例：
2
1 2
1 6
2 
1 2
1 1
2 
1 3
2 2
提示：
None



题目：老高老高的树(1240)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
给你一颗二叉树，给出它先序遍历的序列，再给出它中序遍历的序列，大家一定已经会求树的前序遍历。现在，我们要求大家输出树高和叶子数。
题目输入：
两个字符串，字符串长度不超过26。第一个为先序遍历的序列，第二个为中序遍历的序列。
题目输出：
两个整数，表示树高和叶子数。
输入样例：
DBACEGF ABCDEFG
BCAD CBAD
输出样例：
4 3
3 2
提示：




题目：MagicSquares(1486)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Following the success of the magic cube, Mr. Rubik invented its planar version, called magic squares. This is a sheet composed of 8 equal-sized squares: 1 2 3 4 8 7 6 5 In this task we consider the version where each square has a different color. Colors are denoted by the first 8 positive integers. A sheet configuration is given by the sequence of colors obtained by reading the colors of the squares starting at the upper left corner and going in clockwise direction. For instance, the configuration of Figure 3 is given by the sequence (1,2,3,4,5,6,7,8). This configuration is the initial configuration. Three basic transformations, identified by the letters `A', `B' and `C', can be applied to a sheet: 'A': exchange the top and bottom row, 'B': single right circular shifting of the rectangle, 'C': single clockwise rotation of the middle four squares. Below is a demonstration of applying the transformations to the initial squares given above: A:  8 7 6 5     1 2 3 4 B:  4 1 2 3     5 8 7 6 C:  1 7 2 4     8 6 3 5  All possible configurations are available using the three basic transformations. You are to write a program that computes a minimal sequence of basic transformations that transforms the initial configuration above to a specific target configuration.
题目输入：
There are several test cases, end by EOF, for each test case:A single line with eight space-separated integers (a permutation of (1..8)) that are the target configuration.
题目输出：
Line 1:  A single integer that is the length of the shortest transformation sequence. Line 2:  The lexically earliest string of transformations expressed as a string of characters, 60 per line except possibly the last line.
输入样例：
2 6 8 4 5 7 3 1
输出样例：
7
BCABCCB
提示：




题目：离(1685)
时间限制：1000ms
空间限制：65535KB
题目描述：
		期末考试结束后，学生们都很疯狂，纪律也难控制。徐老师到班上发完成绩单，可是同学们都坐的很不规则。统计成绩成了一件麻烦的事，好在不论同学们怎么坐，都可以假想成一个树形结构，将第一个离老师最近的同学视为根结点。现在，徐老师想要知道，如果以一个同学为根节点的子树中，成绩最高的三个同学的分数是多少？（包括此根结点同学）
题目输入：
	多组数据。	一个整数N（0<N<=10000）表示学生数（将学生编号为0~N-1，根节点为编号0）接下来一个整数表示编号为0学生的分数val(0<=val<=1000000)。下面是N-1行数据，每行两个数，分别表示编号1~N-1结点的父亲结点编号和这个同学的成绩。下一行是一个整数M，表示徐老师询问的次数。接着M行每行一个整数，表示询问中的根结点编号。
题目输出：
	对于每次询问，输出以这个编号为根的子树中成绩最高的三位同学的分数。如果子树结点<3，输出-1
输入样例：
5
1
0 10
0 5
2 7
2 8
5
0
1
2
3
4

输出样例：
10 8 7
-1
8 7 5
-1
-1

提示：
None



题目：Colorthenecklace(1037)
时间限制：20000 ms
空间限制：65536 ms
题目描述：
As we all know, girls love necklaces, especially nice necklaces. Recently, huicpc229 has fallen in love with a girl; he wants to bring her a necklace as a gift. Now he has n colors, and the necklace is circular and it has n beads, huicpc229 can use his colors to color the necklace. he wants to know how many different kinds of necklaces he can make，he may not use all the n colors. In this problem, the necklace is same when you rotate it around the center of the necklace or turn it over.
题目输入：
First line is the testcase T.
Following T lines, each line is an integer n ( 1≤n ≤ 109 )
题目输出：
Output the answer mod 20090531
输入样例：
4
1
2
3
4

输出样例：
1
3
10
55

提示：




题目：Homogeneoussquares(1384)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
Assume you have a square of size n that is divided into n×n positions just as a checkerboard. Two positions (x1,y1) and (x2,y2), where 1 ≤ x1,y1,x2,y2 ≤ n, are called "independent" if they occupy different rows and different columns, that is, x1≠x2 and y1≠y2. More generally, n positions are called independent if they are pairwise independent. It follows that there are n! different ways to choose n independent positions. 
Assume further that a number is written in each position of such an n×n square. This square is called "homogeneous" if the sum of the numbers written in n independent positions is the same, no matter how the positions are chosen. Write a program to determine if a given square is homogeneous!
题目输入：
The input contains several test cases. 
The first line of each test case contains an integer n (1 ≤ n ≤ 1000). Each of the next n lines contains n numbers, separated by exactly one space character. Each number is an integer from the interval [-1000000,1000000]. 
The last test case is followed by a zero.
题目输出：
For each test case output whether the specified square is homogeneous or not. Adhere to the format shown in the sample output.
输入样例：
2
1 2
3 4
3
1 3 4
8 6 -2
-3 4 0
0

输出样例：
homogeneous
not homogeneous

提示：




题目：魔兽对战作弊器(1138)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
WAVwind混迹魔坛多年，最近他发现了一种好玩的作弊器。对于兵营里待出的兵，如果两个兵是连着的，那么他们就会瞬间被造出来。例如：兵营里有[小狗][蜘蛛][蜘蛛][小狗],那么两条蜘蛛瞬间被造了出来，然后小狗也是连着的，也会瞬间被造出来，所以，这个兵营里的所有兵就会被瞬间造出来。WAVwind想要充分发挥这个作弊器的能力，可是他不知道怎么做。所以请你来帮忙。对于给定的兵种序列，你要告诉他是不是能瞬间造出所有的兵。
题目输入：
一个整数CASE，代表测试数据的组数。对于每组测试，输入一个整数N,代表兵营里待造的兵的数量（1<=N<=100000）.接下来是N个数，每个数代表了一种兵，依次表示兵营里的兵种。
题目输出：
Yes:如果能被瞬间造出。No:不能被瞬间造出。
输入样例：
4
8
3 1 1 2 2 1 1 3
6
1 1 2 2 3 3
6
1 1 2 3 2 3
3
2 2 2
   
输出样例：
Yes
Yes
No
No
提示：




题目：RareOrder(1584)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
			A rare book collector recently discovered a book wriuen in an unfamiliar language that used the same characters as the English language. The book: contained a short index. but the ordering of the items in the index was different from what onc would expect if the characters were ordered the same way as in the English alphabet The collector tried to use the index to determine the ordering of characters (i..e , the collating sequence) of the strange alphabet, then gave up with frusttation at the tedium of the task. You are to write a program to complete the colleclOr's work. In panicular. your program will take a set of strings that has been sorted according to a panicular collating sequence and determine what that sequence is.		
题目输入：
	The input consists of an ordered list of strings of uppercase letters. one string per line. Each string contains at most 20 characters. The end of the list is signalled by a line that is the single character 'j', Not all letters are necessarily used, but the list will imply a complete ordering among those letters that are used. A sample input file is shown below.	
题目输出：
	Your output should be a single line containing uppercase lellers in the order that specifies the collating sequence used to produce the input data file. Correct output for the input data file above is shown below.	
输入样例：
XWY
ZX
ZXY
ZXW
YWWX
#
输出样例：
XZYW
提示：
None



题目：Theeasiestproblemever(1241)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
bobo heared from fishhead that you have just learned dfs(the Depth-First-Search algorithm),so he want you to help him solve a very easy problem.Just count how many consecutive 0 areas are there in a map consists of hexadecimal numbers.Of course you must change the map consists of hexadecimal numbers into the map consists of binary numbers.
题目输入：
The input contains a lot of test cases,and is terminated by end of file.
For each test case, you will get a pair of R(1<=R<=50)and C(1<=C<=50) represents how many rows and columns are there.
Than there R rows every row contains C hexadecima numbers.
题目输出：
Just print the case number and the number of areas of consecutive number 0 appers after the transformation.
输入样例：
5 5
fffff
ff00f
fffff
f0f0f
fffff

10 10
ffffffffff
1010110101
101010101f
10100101ff
ffffffffff
f0000000ff
1010110101
101010101f
10100101ff
ffffffffff
输出样例：
Case 1: 3
Case 2: 5
提示：




题目：LunchTime(1790)
时间限制：1000MS
空间限制：65535KB
题目描述：
The campus of Nanjing University of Science and Technology can be viewed as a graph with N vertexes and M directed edges (vertexes are numbered from 0 to N-1). Each edge has the same length 1. Every day, there are K students walking to the dinning-hall (vertex N-1) from the teaching building (vertex 0) at lunch time. They all want reach the dinning-hall as soon as possible. However, each edge can only serve at most ci students at any time. Can you make arrangements for students, so that the last student can reach the dinning-hall as soon as possible? (It is assumed that the speed of the students is 1 edge per unit time)
题目输入：
There are several test cases, please process till EOF.

The first line of each test case contains three integer N(2<=N<=2500), M(0<=M<=5000), K(0<=K<=109). Then follows M lines, each line has three numbers ai, bi, ci(0<=ci<=20), means there is an edge from vertex ai to bi with the capacity ci.
题目输出：
For each test case, print an integer represents the minimum time. If the requirements can not be met, print “No solution”(without quotes) instead.
输入样例：
5 6 4
0 1 2
0 3 1
1 2 1
2 3 1
1 4 1
3 4 2
3 3 10
0 1 1
1 2 1
0 2 1
2 0 1

输出样例：
36
No solution

提示：
None



题目：SweetButter(1487)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
Farmer John has discovered the secret to making the sweetest butter in all of Wisconsin: sugar. By placing a sugar cube out in the pastures, he knows the N (1 <= N <= 500) cows will lick it and thus will produce super-sweet butter which can be marketed at better prices. Of course, he spends the extra money on luxuries for the cows. FJ is a sly farmer. Like Pavlov of old, he knows he can train the cows to go to a certain pasture when they hear a bell. He intends to put the sugar there and then ring the bell in the middle of the afternoon so that the evening's milking produces perfect milk. FJ knows each cow spends her time in a given pasture (not necessarily alone). Given the pasture location of the cows and a description of the paths the connect the pastures, find the pasture in which to place the sugar cube so that the total distance walked by the cows when FJ rings the bell is minimized. FJ knows the fields are connected well enough that some solution is always possible.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1: Three space-separated integers: N, the number of pastures: P (2 <= P <= 800), and the number of connecting paths: C (1 <= C <= 1,450). Cows are uniquely numbered 1..N. Pastures are uniquely numbered 1..P. Lines 2..N+1: Each line contains a single integer that is the pasture number in which a cow is grazing. Cow i's pasture is listed on line i+1. Lines N+2..N+C+1: Each line contains three space-separated integers that describe a single path that connects a pair of pastures and its length. Paths may be traversed in either direction. No pair of pastures is directly connected by more than one path. The first two integers are in the range 1..P; the third integer is in the range (1..225).
题目输出：
Line 1: A single integer that is the minimum distance the cows must walk to a pasture with a sugar cube.
输入样例：
3 4 5
2
3
4
1 2 1
1 3 5
2 3 7
2 4 3
3 4 5
输出样例：
8
提示：
This diagram shows the connections geometrically:           P2   P1 @--1--@ C1         |         |        5  7  3         |            |     C3       C2 @--5--@          P3    P4OUTPUT DETAILS:Putting the cube in pasture 4 means: cow 1 walks 3 units; cow 2 walks 5units; cow 3 walks 0 units -- a total of 8.



题目：躲雨(1686)
时间限制：2000 MS
空间限制：65535 KB
题目描述：
一场突如其来的大雨，让校园里面的人一下忙碌起来，大家都忙着找个地方躲雨，现在请你统计一下大家离最近躲雨的距离。假设每个躲雨的地方可以容纳无数个人。
题目输入：
输入数据第一行两个整数N和M，表示校园的大小，接下来N行。每行有M个字符。‘#’号表示可以躲雨的地方，‘*’表示这点是不可行的，‘.’表示人，其中2<=N,M<=1000。
题目输出：
统计行走每种距离的人数，按照距离从小到大输出。如果一个人无法到达可以躲雨的地方，这个人的行走距离为0。保证输入数据中至少有一个人。
输入样例：
3 4
#.*.
#*.*
#...

输出样例：
0 1
1 2
2 1
3 2

提示：
无法达到躲雨地方的人有一个，坐标为(1,4)。
走一步就可以到达躲雨地方的人有两个，坐标为(1,2),(3,2)。
走两步就可以到达躲雨地方的人有一个，坐标为(3,3)。
走三步就可以到达躲雨地方的人有两个人，坐标为(2,3),(3,4)



题目：AdditionChains(1385)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
An addition chain for n is an integer sequence <a0, a1,a2,...,am> with the following four properties: 

a0 = 1 
am = n 
a0<a1<a2<...< am-1<am 
For each k (1<=k<=m) there exist two (not neccessarily different) integers i and j (0<=i, j<=k-1) with ak=ai+aj You are given an integer n. Your job is to construct an addition chain for n with minimal length. If there is more than one such sequence, any one is acceptable.For example, <1,2,3,5> and <1,2,4,5> are both valid solutions when you are asked for an addition chain for 5. 
题目输入：
The input file will contain one or more test cases. Each test case consists of one line containing one integer n (1<=n<=100). Input is terminated by a value of zero (0) for n. 
题目输出：
For each test case, print one line containing the required integer sequence. Separate the numbers by one blank. 
输入样例：
5
7
12
15
77
0

输出样例：
1 2 4 5
1 2 4 6 7
1 2 4 8 12
1 2 4 5 10 15
1 2 4 8 9 17 34 68 77

提示：
The problem is a little time-critical, so use proper break conditions where necessary to reduce the search space. 



题目：DNAcomputing(1038)
时间限制：3000 ms
空间限制：65536 ms
题目描述：
DNA computing is a form of computing which uses DNA, biochemistry and molecular biology, instead of the traditional silicon-based computer technologies. DNA computing, or, more generally, molecular computing, is a fast developing interdisciplinary area. Research and development in this area concerns theory, experiments and applications of DNA computing. DNA computing is fundamentally similar to parallel computing in that it takes advantage of the many different molecules of DNA to try many different possibilities at once. So, many NP problem can be solved through DNA computing , such as Hamiltonian path problem, SAT problems, and so on.The core reaction of DNA computing is the specific hybridization, which may results in incorrect or undesirable computations. Therefore, so far much works have focused on designing the 题D目N：A乱 矿s流e(q1u1e3n9c)e
s to make the molecular computation more reliable.
The DNA encoding p时r间o限b制le：m1 0c0a0n  mbse
 described as follows: the encoding alphabet of  DNA sequence i空s间 限t制h：e6 5s535 ms
et of nucleic acid bases ,and in the encoding set Z of DNA strands whose length is L, ,and  ,search the subset W of Z which satisfies (any subset of Z can be treat as a code set):
(1)  ,the total number of A、C in   is L/2;
(2)  ,the hamming distance （the Hamming distance between two strings of equal length is the number of positions for which the corresponding symbols a题r目e描 述d：i
ff
eWrAeVnwti）nbde和tWwAeVesnw e e ta又n进d行 了 一 场i大s战 ，a一t场 决l战e后a，sWtA VDw.in
dI几n乎 扫o平r了dWeArV stwoe esti的m所p有l部i队f，y胜 利t将h至e。 可e是nWAcVosdwienegt 却p玩r起o了b乱l矿e流m。,已 知w地e图 上d的o矿n点’和t一 些w路a。n为t了 尽y快o找u到 矿t点o， WfAiVnwdi nd决定要进行多线操作，即把部队分成若干份。同时他又不想走已经走过的路，而且也不敢把部队分得太散，万一遇到WAVsweet的残余部队就杯具了。现在问你，WAVwind至少要把部队分成多少队，才能走遍地图上所有的路（因为sweet也会在某些路上建造建筑），且不走回头路,即不走重复的路。
such a subset with the biggest size, we only want you to find the best subset satisfying the two conditions. The strategy to compare two subset is as follows:
Suppose   are two subset satisfying the two conditions. If   is a subset of  ,then   is better than  . otherwise,  we firstly order the elements of them independently based on lexicographic. then, we get the first element   from 题 目 输a入n：d
 多t组h测e试 数f据i，r以s文t件 末e尾l结e束m。e每n组t数 据 第 一f行r两o个m整 数 N., MW（e1 <c=oNn<s=i1d0e0r, 0 < =tMo< =b2e0 0b）e,t分t别e表r示 有tNh个a矿n点 ， 有 Mi条f路 。 接 下i来sM 行i,n每 行f2r个o整n数ta ,obf表 示 a 和ibn之 间l有e一x条i路c（o不g会r有a2p条h路i连c接.同 样 的o2n个 矿t点h，e即 比c如o1n t2r a,r2 1这种重复的情况不会出现，没有路连着的矿不考虑）.
y, we think   is better than   if   is behind  . On the other hand, if   is the same as  , we then get the second element   from   and the second element   from   , if they are also the same ,we will get the next pairs until we can evaluate them.
For exam题p目l输e出s： 
:至少
需(要1分)成 的 部队
数 。 
is better than   because   is a subset of  .
(2)  
Firstly ,we order them, so  
Then   is better than   because  is in front of  .
Now , we will give you th输e入 样l例e：n
g3t h3 L
 1a n2d 
t2h e 3di
s1t a3nc
e 
D4,  2ca
n1  y2ou
 3f i4nd
 
the best code set.
输出样例：
1
2

题目输入：
There are several cases. Each case contains two integers, L (0
            
提示：




题目输出：
For each case, output several lines, the first line is the size of the code set, then print all the elements of the code set in lexicographic. A element per line. 
输入样例：
2 2
输出样例：
4
AG
CT
GA
TC

提示：




题目：Squares (1585)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	A children's board game consists of a square array of dots that contains lines connecting some of the pairs of adjacent dots. One part of the game requires that the players count the number of squares of certain sizes that are formed by these lines. For example, in the figure shown below, there are 3 squares-2 of size 1 and 1 of size 2. (The ``size" of a square is the number of lines segments required to form a side.)		Your problem is to write a program that automates the process of counting all the possible squares.	
题目输入：
	The input file represents a series of game boards. Each board consists of a description of a square array of n2 dots (where 2 <= n <= 9) and some interconnecting horizontal and vertical lines. A record for a single board with n2 dots and m interconnecting lines is formatted as follows:		Line 1:         n       the number of dots in a single row or column of the array		Line 2:         m       the number of interconnecting lines		Each of the next m lines are of one of two types:		H i j  indicates a horizontal line in row i which connects		the dot in column j to the one to its right in column j + 1		or		V i j  indicates a vertical line in column i which connects		the dot in row j to the one below in row j + 1	Information for each line begins in column 1. The end of input is indicated by end-of-file. The first record of the sample input below represents the board of the square above.	
题目输出：
			For each record, label the corresponding output with ``Problem #1", ``Problem #2", and so forth. Output for a record consists of the number of squares of each size on the board, from the smallest to the largest. lf no squares of any size exist, your program should print an appropriate message indicating so. Separate output for successive input records by a line of asterisks between two blank lines, like in the sample below.							
输入样例：
4
16
H 1 1
H 1 3
H 2 1
H 2 2
H 2 3
H 3 2
H 4 2
H 4 3
V 1 1
V 2 1
V 2 2
V 2 3
V 3 2
V 4 1
V 4 2
V 4 3
2
3
H 1 1
H 2 1
V 2 1
输出样例：
Problem #1

2 square (s) of size 1
1 square (s) of size 2

**********************************

Problem #2

No completed squares can be found.

提示：
None



题目：Thief(1242)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Many years later , xiaoyoulei start up a big company，the company has a lot of rooms layers of nested，it’s very beautiful，but it cause a problem that his staff are very easy to go wrong ways. what’s more ,once the door is locked , it’s easy to get lost.The company layout like  the picture below：

In order to make up for his failure design on the room layout , xiaoyoulei make a decision that he will select some keys just in the corresponding rooms .（the arc in the picture means there is a door，for example the arc between room 1 and room 2means there is a door . The room where the arc locates there has the key . if the door is open ，you can get in both of the room from the other one . But if the door is locked ，because Room 2 has the key to open the lock , so from room 2 you can get through to room 1. But if you are in the room 1. You won’t get through to room 2.）Xiao you lei has some bad habit，that he likes to put valuables in one room of the company. To show off his wealthiness , he also told others which room the valuables are there.Here comes the problem , there are thieves in the company! Now ，if we could tell you the room numbers where the thieves are there and the room numbers where the valuables are . Could you tell me how many doors we must lock at least to prevent the thieves to steal the valuables in the room . if no matter how many doors were locked ,we  can not prevent the thieves.（for example the thief is in room 3，the valuables are in room 2，than the thief can get the keys in room 3 to get in room 4, and get the key in room 4 to get in room 2. ），just call xiao you lei！
题目输入：
The first line is a  T，means the test case numbers。
For each test case. The first line is M and N (1 <=m<= 20; 0 <=n<= 19)，M means how many rooms are there，N means where the valueables are there。
There are M more lines to indicate the condition of all the M rooms，the first letter in each line may be a T or an S，T means the room has a thief ，S means there isn’t has a thief 。（you may depend there are more than one thief and in different rooms ），than there is a number p (0 <=p <= 20) ，means the room has how many doors to get in other rooms，and has the key of the door。（example，if the first line below M and N comes “ S 2 2 3 “，it means room 1 don’t have a thief，it can go through to two rooms numbered ROOM 2 and ROOM 3，when the door is locked.ROOM  1 still can get through to ROOM 2 and ROOM 3）
题目输出：
One integer means how many doors you need to lock or print a line “call new sister right now！”（not include the quotation mark）。
输入样例：
3
7 2
S 0
T 3 0 4 5
S 2 1 6
S 2 1 2
S 0
S 0
S 0
7 2
I 0
S 3 0 4 5
S 2 1 6
T 2 1 2
S 0
S 0
T 0
4 3
T 0
S 1 2
S 1 0
S 4 1 1 2 2
输出样例：
2
call new sister right now!
1
提示：




题目：Drunk(1791)
时间限制：1000MS
空间限制：65535KB
题目描述：
	Jenny is seriously drunk. He feels as if he is in an N-dimension Euclidean space, wandering aimlessly. In each step, he walks toward some direction and the “length” of each step will not exceed R. Technically speaking, Jenny is initially located at the origin of the N-dimension Euclidean space. Each step can be represented by a random N-dimension vector(x1, x2,..... ,xn) chosen uniformly from possible positions satisfying xi>=0 and x1^2 + x2^2 + ....<=R^2.	Assume the expectation of his coordinate after his first step is (y1, y2,......yn). He wants to know the minimum yi .
题目输入：
	There are several (about 10000) test cases, please process till EOF.	Each test case, only one line contains two integers N and R, representing the dimension of the space and the length limit of each step.(1<=n<=2
题目输出：
	For each test case, print a real number representing the answer to the question above.	Your answer is considered correct if the difference between your answer and the correct one is less than 10^-6.
输入样例：
2 1

输出样例：
0.4244131816

提示：
None



题目：山高人为峰(1687)
时间限制：3000 MS
空间限制：65535 KB
题目描述：
给一个h*w的地图，每个位置上(x,y)(1<=x<=h,1<=y<=w)有个一数值h，代表该点（山峰）的海拔。现有一个登山爱好者，想从该地图h*w个位置上选个登山起点（sx，sy），沿上下左右四个方向走，以达到更高的山峰为成功目标。但该登山爱好者有个嗜好，从来不走海拔小于或等于sh-d的点。其中sh为登山起点的海拔，d为他的嗜好度。 请问在h*w的地图上有多少个点可以作为该登山爱好者的登山起点，在满足他的嗜好情况下，可以达到更高的山峰（想对于登山起点）。
题目输入：
第一行为一个正整数t（t<=25），代表测试组数。每一组测试数据：一行有三个整数1 ≤ h ≤ 500, 1 ≤ w ≤ 500 and 1 ≤ d ≤ 1 000 000 000. 其中h 和w 分别为地图的高和宽. d为该登山者的嗜好度。接下来有h行w列个整数，第x行的第y个整数，代表该点的海拔（0 ≤ h ≤ 1 000 000 000）
题目输出：
对于每一组测试数据：输出一个整数n，以换行结尾（代表在h*w的地图上有n个点可以作为该登山爱好者的登山起点，以达到更高的山峰）
输入样例：
3
2 2 1
0 1
2 0
2 2 2
0 1
2 0
6 10 2
0 0 0 0 0 0 0 0 0 0
0 1 2 1 1 1 1 0 1 0
0 2 1 2 1 3 1 0 0 0
0 1 2 1 3 3 1 1 0 0
0 2 1 2 1 1 1 0 2 0
0 0 0 0 0 0 0 0 0 0

输出样例：
2
3
56

提示：
None



题目：BinomialShowdown(1386)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
In how many ways can you choose k elements out of n elements, not taking order into account? Write a program to compute this number. 
题目输入：
The input file will contain one or more test cases.
Each test case consists of one line containing two integers n (n>=1) and k (0<=k<=n).
Input is terminated by two zeroes for n and k.
题目输出：
For each test case, print one line containing the required number. This number will always fit into an integer, i.e. it will be less than 231. 
输入样例：
4 2
10 5
49 6
0 0

输出样例：
6
252
13983816

提示：
Don't underestimate the problem. The result will fit into an integer - but if all intermediate results arising during the computation will also fit into an integer depends on your algorithm. The test cases will go to the limit. 



题目：RidingtheFences(1488)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer John owns a large number of fences that must be repaired annually. He traverses the fences by riding a horse along each and every one of them (and nowhere else) and fixing the broken parts. Farmer John is as lazy as the next farmer and hates to ride the same fence twice. Your program must read in a description of a network of fences and tell Farmer John a path to traverse each fence length exactly once, if possible. Farmer J can, if he wishes, start and finish at any fence intersection. Every fence connects two fence intersections, which are numbered inclusively from 1 through 500 (though some farms have far fewer than 500 intersections). Any number of fences (>=1) can meet at a fence intersection. It is always possible to ride from any fence to any other fence (i.e., all fences are "connected"). Your program must output the path of intersections that, if interpreted as a base 500 number, would have the smallest magnitude. There will always be at least one solution for each set of input data supplied to your program for testing.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  The number of fences, F (1 <= F <= 1024)  Line 2..F+1:  A pair of integers (1 <= i,j <= 500) that tell which pair of intersections this fence connects.
题目输出：
The output consists of F+1 lines, each containing a single integer. Print the number of the starting intersection on the first line, the next intersection's number on the next line, and so on, until the final intersection on the last line. There might be many possible answers to any given input set, but only one is ordered correctly.
输入样例：
9
1 2
2 3
3 4
4 2
4 5
2 5
5 6
5 7
4 6
输出样例：
1
2
3
4
2
5
4
6
5
7
提示：




题目：WebgameGuduSanGuo(1039)
时间限制：10000 ms
空间限制：65536 ms
题目描述：
Webgame is a new style of game; you do not need the game client. Users can play through the browser. GuduSanGuo is a strategy type of webgame, in GuduSanGuo you can build your own army to attack other country.
There are many kinds of units you can build. Each unit has its own attributes: attack, hit point (hp), armor. When you own a strong army, you can start the war. Of course before the war, you must detect the military strength you attack against. For a coming war, you have to estimate the cost of the war. In the game the cost of the war is the units you lost which can calculated as follows: the number of lost units = (attacks - armor) / hp. Each war breakout among cities, in a city there are more than one kind of unit. So the damage should distribute to each unit. The damage each unit bear is decided by the number of units in the proportion of total units count. For example, there are two kinds of unit: Footman and Archer. The number of Footman is 70 and Archer is 30.If the total damages is 100,the result is,70% damages to Footman and 30% damages to Archer.
  Science and technology played an important role, you can upgrade your army’s defense and attack, and you can assume that each level upgrade 10% of the unit’s initial armor and attack.
Also you can attack one city with many cities simultaneously, but the war is calculated separately and the order of the war is decision by arrive time. Now can you program and calculate the results of the war? You should note that all calculations are based on integer, the decimal is ignored.
题目输入：
First line of input is a integer m(m<10) means the number of units. Then followed by m lines, each line contains the unit name, attack value, armor and hp. The next is the information of the city you attack include city name, technology level, and Military details, first line is city name, next line is technology level, then a integer t means the number of units the city have. Followed by t lines contain each unit's name and the number of unit. You can assume that all the unit names are occurred in the total units before. The last is your cities' information. The beginning is the number of cities n(n<10). Then n blocks of city information follow. The format is the same as before, but each block contain an arriving time (an integer) at last.
题目输出：
You should output all war's result, for each war you should give the Attacking side's and Defensive side's basic information such as city name, each unit's name and the number, total attacks and armors then you have to output the lost unit. The sequence of units is ordered by unit name and the war's sequence is ordered by arriving time, that means which war begin first output first. You can see the simple output for the detail.
输入样例：
8
Swordman 18 10 100
LongPikeman 60 25 150
Archer 70 20 120
Lancesoldiers 45 30 160
LightCavalry 70 25 160
RePikeman 80 50 180
EvenCrossbowmen 145 20 260
Hussars 200 45 465
changsha
0
1
Swordman 100
2
yongzhou
0
2
Swordman 70
Archer 30
30
xian
0
2
Swordman 70
Archer 30
40

输出样例：
Attacking side:
CityName:yongzhou
Unit:
Archer 30
Swordman 70
Total Attacks:3360
Total Armors :1300
Lost Unit:
Archer 1
Swordman 3
Defensive side:
CityName:changsha
Unit:
Swordman 100
Total Attacks:1800
Total Armors :1000
Lost Unit:
Swordman 23
Attacking side:
CityName:xian
Unit:
Archer 30
Swordman 70
Total Attacks:3360
Total Armors :1300
Lost Unit:
Archer 0
Swordman 0
Defensive side:
CityName:changsha
Unit:
Swordman 77
Total Attacks:1386
Total Armors :770
Lost Unit:
Swordman 25

提示：




题目：TriangularVertices(1586)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	Consider the points on an infinite grid of equilateral triangles as shown below:			Note that if we number the points from left to right and top to bottom, then groups of these points form the vertices of certain geometric shapes. For example, the sets of points {1,2,3} and {7,9,18} are the vertices of triangles, the sets {11,13,26,24} and {2,7,9,18} are the vertices of parallelograms, and the sets {4,5,9,13,12,7} and {8,10,17,21,32,34} are the vertices of hexagons.		Write a program which will repeatedly accept a set of points on this triangular grid, analyze it, and determine whether the points are the vertices of one of the following ``acceptable" figures: triangle, parallelogram, or hexagon. In order for a figure to be acceptable, it must meet the following two conditions:	 1)	Each side of the figure must coincide with an edge in the grid.	and 		2)	All sides of the figure must be of the same length. 
题目输入：
The input will consist of an unknown number of point sets. Each point set will appear on a separate line in the file. There are at most six points in a set and the points are limited to the range 1..32767.
题目输出：
For each point set in the input file, your program should deduce from the number of points in the set which geometric figure the set potentially represents; e.g., six points can only represent a hexagon, etc. The output must be a series of lines listing each point set followed by the results of your analysis.
输入样例：
1 2 3
11 13 29 31
26 11 13 24
4 5 9 13 12 7
1 2 3 4 5
47
11 13 23 25
输出样例：
1 2 3 are the vertices of a triangle
11 13 29 31 are not the vertices of an acceptable figure
26 11 13 24 are the vertices of a parallelogram
4 5 9 13 12 7 are the vertices of a hexagon
1 2 3 4 5 are not the vertices of an acceptable figure
47 are not the vertices of an acceptable figure
11 13 23 25 are not the vertices of an acceptable figure
提示：
None



题目：炸弹人的阴谋(1140)
时间限制：1000 ms
空间限制：65535 ms
题目描述：

DOTA联合会现要召集各DOTA英雄去各个分会商量DOTA6.68版本的更新问题。由于哥布林工程师不会在-rd模式中出现，少了很多出风头的机会，所以他对DOTA联合会早就心存怨恨，借着这个机会，他预谋了一次暗杀。他准备在某些必经之路上放上炸弹，可是他的炸弹数量不多了，他准备把火力全部集中在一条路上。可是，他的这个阴谋被某人看穿了并报告给了DOTA联合会，联合会决定在各个分会间再建造几条路，再发给每个英雄一颗真视宝石（由于英雄们都没什么拆弹技术，所以当他们发现某条道路有炸弹时，他们只能绕道走）。问：联合会至少要建立多少条路才能使得各英雄们能安全到达每个分会去开会。
题目输入：
第一行一个整数T,表示有T组测试数据。对于每组测试数据，第一行为2个整数N和M（3<=N<=2000,2<=M<=n*(n-1)/2），表示有N个分会，各分会间已经有了M条路（原先保证各分会间是相通的）。接下来M行，每行2个整数A和B，表示分会A和分会B之间有路相通（各分会编号分别为1~N）。
题目输出：
联合会最少需要再建的道路数量。
输入样例：
        2
	10 12
	1 2
	1 3
	1 4
	2 5
	2 6
	5 6
	3 7
	3 8
	7 8
	4 9
	4 10
	9 10
	
	3 3
	1 2
	2 3
	1 3

输出样例：
 2
 0

提示：




题目：Travelroundtheworld(1243)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
Bobo want’s to travel round the world by helicopter . But he find a problem that the fuel prices varied between the cities he visited. He want to save some money by have a plan about where he filled his fuel.To help him (and save money yourself next time), you want to write a program for finding the cheapest way to travel between cities, filling your helicopter on the way. We assume that all helicopters use one unit of fuel per unit of distance, and start with an empty gas tank.
题目输入：
The first line of input gives 1 ≤ n ≤ 1000 and 0 ≤ m ≤ 10000, the number of countriess and air lines. Then follows a line with n integers 1 ≤ pi≤ 100, where pi is the fuel price in the ith country. Then follow m lines with three integers 0 ≤ u, v 
            
题目输出：
For each query, output the price of the cheapest trip from s to e using a helicopter with the given capacity, or "impossible" if there is no way of getting from s to e with the given car.
输入样例：
5 5
10 10 20 12 13
0 1 9
0 2 8
1 2 1
1 3 11
2 3 7
2
10 0 3
20 1 4
输出样例：
170
impossible
提示：




题目：Cirno’sPresent(1792)
时间限制：2000MS
空间限制：65535KB
题目描述：
One day, three fairies, Sunny, Luna and Star visited Cirno’s house. Cirno was very happy, so she decided to give a present to them.

Cirno’s present was a tree with N nodes. Each node of the tree has an equal possibility to be owned by one of Sunny, Luna or Star. After having decided every node’s owner, Cirno cut the edges that connect different owner’s nodes, after which each of the three fairies got some connected component of nodes (possibly none).

Then each of the three fairies had to spend some magical energy repairing the components she got. Suppose she had X components containing odd number of nodes and Y components containing even number of nodes, the magical energy she would spend equals max(0, X − Y ).

Cirno would compensate for the energy they spent with some food, so she asked you the expectation of the total energy the three fairies would spend, and your task is to find out the answer.

To make it simpler, as it’s easy to prove the multiplication of the expectation and the Nth power of three makes an integer, your task is to find the remainder of the multiplication divided by 109 + 7.
题目输入：
There are several test cases, please process till EOF.

Each test case starts with a line containing one integer N (1 ≤ N ≤ 300). Then follows N − 1 lines, each contains two integers u and v (1 ≤ u, v ≤ N ), representing an edge between node u and node v.
题目输出：
For each test case, print the remainder of the product of the expected energy cost and the N -th power of three (actually, the remainder divided by 109 + 7) in a line.
输入样例：
1
2
1 2
3
2 1
1 3
输出样例：
3
12
51
提示：




题目：逃跑(1688)
时间限制：2000 MS
空间限制：65535 KB
题目描述：
Busoniya王子成功地杀掉了恶魔，但是他进入恶魔洞穴的路口被其他敌人破坏了。幸运的是，还有另外一条出路，不过要冒着被飞龙攻击的危险。    那条路是岩浆路，在一片岩浆中，有N个石块，同时有M座桥连接这些石块，石块标号从0开始标记到N-1。 在个区域中，有D条飞龙巡逻着，对于每条飞龙，它把守着C个石块, (C只有2,3,4这3种情况)，每条飞龙的巡逻轨迹是有规律的：如果C是3，这3个石块为a,b,c，则初始时飞龙在a石块上，经过1个单位时间后去b处，再过一个单位时间去c处，再过一个单位时间去a处，循环的在a,b,c,3个石块上巡逻。当某个时刻某个石块上有人时，飞龙刚好巡逻到，那么飞龙就会攻击他。    经过与恶魔的恶战后，Busoniya王子已经没有多少体力去对付飞龙了，所以他希望能避开飞龙，顺利逃脱出去。同时，每个石块不能停留，防止飞龙发现，所以，Busoniya王子想知道从他所在的位置S号石块到出口T号石块，恰好经过K个时间有多少种走法(初始时间是0)。
题目输入：
第一行5个数，N,M,S,T,K，( 1 <= N <= 50 , 1 ≤ K ≤ 2,000,000,000 )然后M行，每行一条无向边连接si,ti然后D，表示飞龙数量 ( 1 <= D <= 20 )然后D行，每行先是C，然后C个编号输入保证飞龙初始位置不在S位置当输入0 0 0 0 0 时结束
题目输出：
输出多少种走法，因为数据很大，所以输出结果除以9907的余数
输入样例：
5 8 0 4 5
0 1
0 2
0 3
1 2
1 4
2 3
2 4
3 4
1
3 1 2 3
0 0 0 0 0

输出样例：
16

提示：

	
		
			
				 时刻 
			
			
				 王子位置 
			
			
				飞龙位置 
			
		
		
			
				 0
			
			
				 0
			
			
				 1
			
		
		
			
				 1
			
			
				 1
			
			
				 2
			
		
		
			
				 2
			
			
				 2
			
			
				 3
			
		
		
			
				 3
			
			
				 0
			
			
				 1
			
		
		
			
				4 
			
			
				 3
			
			
				 2
			
		
		
			
				 5
			
			
				 4
			
			
				 3
			
		
	




题目：Compromise(1387)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
In a few months the European Currency Union will become a reality. However, to join the club, the Maastricht criteria must be fulfilled, and this is not a trivial task for the countries (maybe except for Luxembourg). To enforce that Germany will fulfill the criteria, our government has so many wonderful options (raise taxes, sell stocks, revalue the gold reserves,...) that it is really hard to choose what to do. 
Therefore the German government requires a program for the following task: Two politicians each enter their proposal of what to do. The computer then outputs the longest common subsequence of words that occurs in both proposals. As you can see, this is a totally fair compromise (after all, a common sequence of words is something what both people have in mind). 
Your country needs this program, so your job is to write it for us. 
题目输入：
The input file will contain several test cases.
Each test case consists of two texts. Each text is given as a sequence of lower-case words, separated by whitespace, but with no punctuation. Words will be less than 30 characters long. Both texts will contain less than 100 words and will be terminated by a line containing a single '#'.
Input is terminated by end of file. 
题目输出：
For each test case, print the longest common subsequence of words occuring in the two texts. If there is more than one such sequence, any one is acceptable. Separate the words by one blank. After the last word, output a newline character. 
输入样例：
die einkommen der landwirte
sind fuer die abgeordneten ein buch mit sieben siegeln
um dem abzuhelfen
muessen dringend alle subventionsgesetze verbessert werden
#
die steuern auf vermoegen und einkommen
sollten nach meinung der abgeordneten
nachdruecklich erhoben werden
dazu muessen die kontrollbefugnisse der finanzbehoerden
dringend verbessert werden
#

输出样例：
die einkommen der abgeordneten muessen dringend verbessert werden

提示：




题目：ShoppingOffers(1489)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
In a certain shop, each kind of product has an integer price. For example, the price of a flower is 2 zorkmids (z) and the price of a vase is 5z. In order to attract more customers, the shop introduces some special offers. A special offer consists of one or more product items together for a reduced price, also an integer. Examples: three flowers for 5z instead of 6z, or two vases together with one flower for 10z instead of 12z. Write a program that calculates the price a customer has to pay for a purchase, making optimal use of the special offers to make the price as low as possible. You are not allowed to add items, even if that would lower the price. For the prices and offers given above, the (lowest) price for three flowers and two vases is 14z: two vases and one flower for the reduced price of 10z and two flowers for the regular price of 4z.
题目输入：
There are several test cases, end by EOF, for each test case:The input file has a set of offers followed by a purchase. Line 1:  s, the number of special offers, (0 <= s <= 99).  Line 2..s+1:  Each line describes an offer using several integers. The first integer is n (1 <= n <= 5), the number of products that are offered. The subsequent n pairs of integers c and k indicate that k items (1 <= k <= 5) with product code c (1 <= c <= 999) are part of the offer. The last number p on the line stands for the reduced price (1 <= p <= 9999). The reduced price of an offer is less than the sum of the regular prices.  Line s+2:  The first line contains the number b (0 <= b <= 5) of different kinds of products to be purchased.  Line s+3..s+b+2:  Each of the subsequent b lines contains three values: c, k, and p. The value c is the (unique) product code (1 <= c <= 999). The value k indicates how many items of this product are to be purchased (1 <= k <= 5). The value p is the regular price per item (1 <= p <= 999). At most 5*5=25 items can be in the basket.
题目输出：
A single line with one integer: the lowest possible price to be paid for the purchases.
输入样例：
2
1 7 3 5
2 7 1 8 2 10
2
7 3 2
8 2 5
输出样例：
14
提示：




题目：MagicTower(1040)
时间限制：2000 ms
空间限制：65536 ms
题目描述：
Accplayer now falls in love with a flash game called “Magic Tower”. A hero is lost in the magic tower, which is filled with monsters and treasure. His goal is to reach the top floor and rescue the princess. Accplayer plays this game over and over again, but never succeeds. How complex the game is! Now he asks his best friend, you, to help him find out how to solve the puzzle.
To simplify the problem, we may assume the tower has only one floor. There are many elements on the floor, such as monsters, herbs, keys and doors. There are at most 12 elements.
A hero has H health points (Hp) at the beginning.
If he walks into a place occupied by a monster, he may lose mi Hp according to the power of the monster. If his current Hp is no bigger than mi, he dies. Otherwise, the monster is killed and will not appear again. 
If he walks into a place occupied by a herb，he needs to eat it. His current Hp will be increased by hi according to the power of the herb, and the herb will not appear again. The hero’s Hp may be bigger than H.
If he walks into a place occupied by a key, he can pick up the key. Each key has a color, and some keys may have the same color. One key can open only one door with the same color. If a key is picked up, it will not appear again.
If he tries to walk into a place occupied by a door, he needs a key with the same color to open it. If he manages to open it, the door disappears, as well as the key.
Now you are given the map of the floor and the description of the elements, you need to find the path leading the hero to the princess.
题目输入：
The input will consist of multiple cases. Your program should process to the end of the input file.
In the first line of each case, there are three integers N, M, and H. The hero has H Hp at the beginning of the game. 3≤N, M≤12. H>0.
The next N lines describe the maze of the game, M characters each line. The characters is from the set {‘.’,’#’,’@’,’*’,’A’-‘Z’}.No other characters will appear.
The character‘.’ represents an empty place. The hero can freely walk into these places.
The character‘#’ represents some obstacles, such as walls, trees, etc. The hero can not walk into any obstacles.
The character‘@’ represents the starting place of the hero. It is of course an empty place.
The character‘*’ represents the place of the princess. If the hero manages to arrive at this place, he wins.
The uppercase character ‘A’-‘Z’ represent the elements described before. There are totally T elements. 0≤T≤12. The elements are represented by distinct characters，which are the first T characters in the alphabet.
Following T lines are the description of the elements, one element per line. The first character is the same with the one in the maze. The second is a string describing the type of the element. 
If it is “Monster”, it is followed by an integer mi describing the hp the hero may lose if he meets with the monster.
If it is “Herb”, it is followed by an integer hi describing the hp the hero may increase if he picks up the herb.
If it is “Key”, it is followed by a word describing the color of the key.
If it is “Door”, it is followed by a word describing the color of the door.
题目输出：
The output will consists of three lines for each case.
The first line is in the format of “Case X:”. X is the number of the input case counting from 1.
The second line is an integer describing the minimum number of steps to reach the princess. The hero can only move to the adjacent four places, and can never move out of the maze. You may assume there are walls around the maze. If there is no way to reach the princess, just output “Impossible!” 
The third line should be the path leading the hero to the princess. Each character of the path should be in the set of {“^”,””}, which means walking up, left, down and right. If there are many solutions, you should output in accordance with the following order: “^”,””. If the path does not exist, just output “Game Over!”
Separate cases by one blank line.
输入样例：
5 5 5
.....
.###.
.#...
.#.##
@#..*

5 5 5
.....
.###.
.#...
.#.##
@#.#*

5 5 5
.....
.###.
.#...
.#A#D
@#BC*
A Monster 4
B Herb 5
C Monster 10
D Monster 5

5 5 5
*#B..
A.##.
...#.
.#.#.
@#...
A Door Red
B Key Red

输出样例：
Game Over!

Case 3:
20
^^^^>>>>vv<>vv

Case 4:
28
^^>>vv>>^^^^<<>>vvvv<
提示：




题目：MessageDecoding(1587)
时间限制：10000 ms
空间限制：65535 ms
题目描述：
 	Some message encoding schemes require that an encoded message be sent in two parts. The first part, called the header, contains the characters of the message. The second part contains a pattern that represents the message. You must write a program that can decode messages under such a scheme.   	   	The heart of the encoding scheme for your program is a sequence of ``key" strings of 0's and 1's as follows:   	   	   	   	The first key in the sequence is of length 1, the next 3 are of length 2, the next 7 of length 3, the next 15 of length 4, etc. If two adjacent keys have the same length, the second can be obtained from the first by adding 1 (base 2). Notice that there are no keys in the sequence that consist only of 1's.   	   	The keys are mapped to the characters in the header in order. That is, the first key (0) is mapped to the first character in the header, the second key (00) to the second character in the header, the kth key is mapped to the kth character in the header. For example, suppose the header is:   	   	AB#TANCnrtXc   	   	   	Then 0 is mapped to A, 00 to B, 01 to #, 10 to T, 000 to A, ..., 110 to X, and 0000 to c.   	   	The encoded message contains only 0's and 1's and possibly carriage returns, which are to be ignored. The message is divided into segments. The first 3 digits of a segment give the binary representation of the length of the keys in the segment. For example, if the first 3 digits are 010, then the remainder of the segment consists of keys of length 2 (00, 01, or 10). The end of the segment is a string of 1's which is the same length as the length of the keys in the segment. So a segment of keys of length 2 is terminated by 11. The entire encoded message is terminated by 000 (which would signify a segment in which the keys have length 0). The message is decoded by translating the keys in the segments one-at-a-time into the header characters to which they have been mapped. 
题目输入：
 	The input file contains several data sets. Each data set consists of a header, which is on a single line by itself, and a message, which may extend over several lines. The length of the header is limited only by the fact that key strings have a maximum length of 7 (111 in binary). If there are multiple copies of a character in a header, then several keys will map to that character. The encoded message contains only 0's and 1's, and it is a legitimate encoding according to the described scheme. That is, the message segments begin with the 3-digit length sequence and end with the appropriate sequence of 1's. The keys in any given segment are all of the same length, and they all correspond to characters in the header. The message is terminated by 000.   	   	Carriage returns may appear anywhere within the message part. They are not to be considered as part of the message. 
题目：MagicSquares(1244)
题目输出：
For each data set, your program must write its decoded message on a separate line. There should not be blank lines between messages.
时间限制：1000 ms
空间限制：65535 ms
输入样例：
TNM AEIOU
0010101100011
1010001001110110011
11000
$#**\
0100000101101100011100101000
题目描述：
Following the success of the magic cube, rayafjyblue invented its planar version, called magic squares. This is a sheet composed of 8 equal-sized squares: 1 2 3 4    8 7 6 5  
In this task we consider the version where each square has a different color. Colors are denoted by the first 8 positive integers. A sheet configuration is given by the sequence of colors obtained by reading the colors of the squares starting at the upper left corner and going in clockwise direction. For instance, the configuration of Figure 3 is given by the sequence (1,2,3,4,5,6,7,8). This configuration is the initial configuration.Three basic transformations, identified by the letters `A', `B' and `C', can be applied to a sheet:· 'A': exchange the top and bottom row,· 'B': single right circular shifting of the rectangle,· 'C': single clockwise rotation of the middle four squares.Below is a demonstration of applying the transformations to the initial squares given above: A: 8765    B: 4123   C: 1724    12输出样例：
TAN ME
##*\$
34        5876        8635
All possible configurations are available using the three basic transformations.You are to write a program that computes a minimal sequence of basic transformations that transforms the initial configuration above to a specific target configuration.
提示：
None



题目输入：
In each case, the first line contains a integer which means the case number.
Next, a single line with eight space-separated integers (a permutation of (1..8)) tha t are the target configuration.
题目输出：
Print a single integer that is the length of the shortest transformation sequence  in the first line.
Then, print the lexically earliest string of transformations expressed as a string of characters, 60 per line except possibly the last line.
输入样例：
1
2 6 8 4 5 7 3 1
输出样例：
7
BCABCCB
提示：
方老师想提醒她亲爱的学弟们：
这题最恶心的地方就是状态的标记了，很容易爆内存，开个7维数组水吧水吧~~当然如果你并非偶这么菜的话，可以尝试康托展开~~



题目：WallPainting(1793)
时间限制：4000MS
空间限制：65535KB
题目描述：
Ms.Fang loves painting very much. She paints GFW(Great Funny Wall) every day. Every day before painting, she produces a wonderful color of pigments by mixing water and some bags of pigments. On the K-th day, she will select K specific bags of pigments and mix them to get a color of pigments which she will use that day. When she mixes a bag of pigments with color A and a bag of pigments with color B, she will get pigments with color A xor B.

When she mixes two bags of pigments with the same color, she will get color zero for some strange reasons. Now, her husband Mr.Fang has no idea about which K bags of pigments Ms.Fang will select on the K-th day. He wonders the sum of the colors Ms.Fang will get with (N  K) different plans.

For example, assume n = 3, K = 2 and three bags of pigments with color 2, 1, 2. She can get color 3, 3, 0 with 3 different plans. In this instance, the answer Mr.Fang wants to get on the second day is 3 + 3 + 0 = 6.

Mr.Fang is so busy that he doesn’t want to spend too much time on it. Can you help him?

You should tell Mr.Fang the answer from the first day to the n-th day.
题目输入：
There are several test cases, please process till EOF.

For each test case, the first line contains a single integer N (1 ≤ N ≤ 103 ).The second line contains N integers. The i-th integer (not exceed 109 ) represents the color of the pigments in the i-th bag.
题目输出：
For each test case, output N integers in a line representing the answers(mod 106 + 3) from the first day to the n-th day.
输入样例：
4
1 2 10 1
输出样例：
14 36 30 8

提示：
None



题目：树的遍历(1141)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
 鱼头伯伯前几天一定给你们讲过树的三种遍历方式。现在，给出先序遍历和中序遍历，要求你输出它的后序遍历。如果你做出这题，说明你是个上课认真听讲的好孩子，鱼头伯伯会很高兴的哦~  加油吧
题目输入：
多组测试数据，到文件末尾结束。每组测试给出2个字符串，分别代表先序和中序遍历。（字符串长度<=26,且其中没有相同的字符）
题目输出：
后序遍历
输入样例：
DBACEGF ABCDEFG
BCAD CBAD

输出样例：
ACBFGED
CDAB
提示：




题目：DungeonMaster(1388)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides. 
Is an escape possible? If yes, how long will it take? 
题目输入：
The input file consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).
L is the number of levels making up the dungeon.
R and C are the number of rows and columns making up the plan of each level.
Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a '#' and empty cells are represented by a '.'. Your starting position is indicated by 'S' and the exit by the letter 'E'. There's a single blank line after each level. Input is terminated by three zeroes for L, R and C. 
题目输出：
Each maze generates one line of output. If it is possible to reach the exit, print a line of the form

    Escaped in x minute(s). 

where x is replaced by the shortest time it takes to escape.
If it is not possible to escape, print the line

    Trapped! 
输入样例：
3 4 5
S....
.###.
.##..
###.#

#####
#####
##.##
##...

#####
#####
#.###
####E

1 3 3
S##
#E#
###

0 0 0

输出样例：
Escaped in 11 minute(s).
Trapped!

提示：




题目：一起来数数有几个多边形(1689)
时间限制：3000MS
空间限制：131070Kb
题目描述：
	我外甥女今年2岁了，最近和她玩的时候，我看到她有好多儿童书，有的还是可以发声的，瞬间觉得科技发展了，想当年，我小时候只有一块钱的发条青蛙玩，额(⊙o⊙)…扯远了……呵呵……	         其中有一本书是数数，开始是数小木棒，还有水果等等，到最后一页的时候，上面这样写的：小朋友，学习了这么久，我们来数数下面这张图里有多少三角形，图如下：			我数了半天，居然数不清了，无语啊~O__O”~…，现在请大家来帮帮忙。	我们将上图三角形叫做3阶，因为它每条边都被分成了3等份。现在有n阶的三角形，请你来数数有多少个三角形，多少个菱形，多少个平行四边形（因为你们都比我和我外甥女聪明，所以稍微加大一点难度哈~）	
题目输入：
	每隔case有一个正整数n(1<n<2^31-1)，表示你将要数的是n阶三角形
题目输出：
	每个case输出三行，分别表示三角形，菱形，平行四边形的个数。答案模除20120709
输入样例：
2
3

输出样例：
5
3
3
13
9
15

提示：
None



题目：Chinesecheckers(1041)
时间限制：1000 ms
空间限制：65536 ms
题目描述：
I think almost everyone play Chinese checkers when we were young. 
Recently, hft777 is fond of playing Chinese checkers. But he is puzzled with how many steps at least to move all his pieces to his opposite position.
To make the problem simple, now we take a line into account. There are n positions on a line, numbered from 0 to n-1.At fast, two same balls is on 0 and 1 position, and every time you can move a ball left or right, or you can move a ball on the position x to the position z on the other side of the ball on the position y, and |x-y|=|y-z|. And you must mark sure the ball can’t move out of the bounder, and the two balls can’t be on one same position. Now, hft777 wants to how many steps at least to move the two same to the n-2, n-1 positions.
题目输入：
The first line of the input is one integer t, the number of testcase.
For each testcase, one integer n for a line, corresponding to the length of the line.  2≤n<1000 
题目输出：
For each testcase output the minimum steps.
输入样例：

2
3
4
输出样例：
1
2

提示：




题目：HomeontheRange(1490)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer John grazes his cows on a large, square field N (2 <= N <= 250) miles on a side (because, for some reason, his cows will only graze on precisely square land segments). Regrettably, the cows have ravaged some of the land (always in 1 mile square increments). FJ needs to map the remaining squares (at least 2x2 on a side) on which his cows can graze (in these larger squares, no 1x1 mile segments are ravaged). Your task is to count up all the various square grazing areas within the supplied dataset and report the number of square grazing areas (of sizes >= 2x2) remaining. Of course, grazing areas may overlap for purposes of this report.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  N, the number of miles on each side of the field. Line 2..N+1:  N characters with no spaces. 0 represents "ravaged for that block; 1 represents "ready to eat".
题目输出：
Potentially several lines with the size of the square and the number of such squares that exist. Order them in ascending order from smallest to largest size.
输入样例：
6
101111
001111
111111
001111
101101
111001
输出样例：
2 10
3 4
4 1
提示：




题目：Ball(1794)
时间限制：1000
空间限制：65535
题目描述：
	Jenny likes balls. He has some balls and he wants to arrange them in a row on the table. Each of those balls can be one of three possible colors: red, yellow, or blue. More precisely, Jenny has R red balls, Y yellow balls and B blue balls. He may put these balls in any order on the table, one after another. Each time Jenny places a new ball on the table, he may insert it somewhere in the middle (or at one end) of the already-placed row of balls. Additionally, each time Jenny places a ball on the table, he scores some points (possibly zero). The number of points is calculated as follows:	• For the ﬁrst ball being placed on the table, he scores 0 point.	• If he places the ball at one end of the row, the number of points he scores equals to the number of diﬀerent colors of the already-placed balls (i.e. expect the current one) on the table.	• If he places the ball between two balls, the number of points he scores equals to the number of diﬀerent colors of the balls before the currently placed ball, plus the number of diﬀerent colors of the balls after the current one.	What’s the maximal total number of points that Jenny can earn by placing the balls on the table?
题目输入：
	There are several test cases, please process till EOF. Each test case contains only one line with 3 integers R, Y and B, separated by single spaces. All numbers in input are non-negative and won’t exceed 10^9.	
题目输出：
	For each test case, print the answer in one line.
输入样例：
2 2 2
3 3 3
4 4 4

输出样例：
15
33
51

提示：
None



题目：SpreadsheetCalculator (1588)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	A spreadsheet is a rectangular array of cells. Cells contain data or expressions that can be evaluated to obtain data. A ``simple" spreadsheet is one in which data are integers and expressions are mixed sums and differences of integers and cell references. For any expression, if each cell that is referenced contains an integer, then the expression can be replaced by the integer to which the expression evaluates. You are to write a program which evaluates simple spreadsheets.	
题目输入：
	Input consists of a sequence of simple spreadsheets. Each spreadsheet begins with a line specifying the number of rows and the number of columns. No spreadsheet contains more than 20 rows or 10 columns. Rows are labeled by capital letters A through T. Columns are labeled by decimal digits 0 through 9. Therefore, the cell in the first row and first column is referenced as A0; the cell in the twentieth row and fifth column is referenced as T4.	Following the specification of the number of rows and columns is one line of data for each cell, presented in row-major order. (That is, all cells for the first row come first, followed by all cells for the second row, etc.)	Each cell initially contains a signed integer value or an expression involving unsigned integer constants, cell references, and the operators + (addition) and - (subtraction).	If a cell initially contains a signed integer, the corresponding input line will begin with an optional minus sign followed by one or more decimal digits.	If a cell initially contains an expression, its input line will contain one or more cell references or unsigned integer constants separated from each other by + and - signs. Such a line must begin with a cell reference. No expression contains more than 75 characters. No line of input contains leading blanks. No expression contains any embedded blanks. However, any line may contain trailing blanks.	The end of the sequence of spreadsheets is marked by a line specifying 0 rows and 0 columns.	
题目输出：
	For each spreadsheet in the input, you are to determine the value of each expression and display the resulting spreadsheet as a rectangular array of numbers with the rows and columns appropriately labeled. In each display, all numbers for a column must appear right-justified and aligned with the column label.	Operators are evaluated left to right in each expression; values in cells are always less than 10000 in absolute value. Since expressions may reference cells that themselves contain expressions, the order in which cells are evaluated is dependent on the expressions themselves.	If one or more cells in a spreadsheet contain expressions with circular references, then the output for that spreadsheet should contain only a list of the unevaluated cells in row-major order, one per line, with each line containing the cell label, a colon, a blank, and the cell's original expression.	A blank line should appear following the output for each spreadsheet.	
输入样例：
2 2
A1+B1
5
3
B0-A1
3 2
A0
5
C1
7
A1+B1
B0+A1
0 0
输出样例：
      0     1
A     3     5
B     3    -2

A0: A0
B0: C1
C1: B0+A1
提示：
None



题目：麻烦的任务冲突(1690)
时间限制：1000MS
空间限制：65535Kb
题目描述：
	在公司，我们是做移动用户行为分析的，最近，我们的项目正式上线了。其中有一个模块，是要判断两个任务之间是否存在冲突。任务冲突如下定义：	         每一个任务都需要选取全流量的部分，因此需要一个模数和余数，比如我需要全流量的20%，那么我只要配置模数为5，余数为1，所有ID%5=1的流量都会被该任务接收。但是，很多任务之间是没有协调过的，因此需要判断一组任务之间是不是存在冲突，比如有两个任务A，B  ,A:模5余1 B:模7余2，那么这两个任务是有冲突的（如ID=16就会导致冲突 ）。为了保持任务分流的机动性，将余数改成区间，即一个任务表示如：17 2 7，表示ID模除17余数在2到7范围(闭区间)的都是该任务所需要的。	         现在有很多人提出了一堆的任务，这些任务都是针对对同一种类的ID的，因此，上线前需要判断，这些任务是不是存在冲突，输出只有两种可能," 发现了冲突！"、“没有发现冲突！”。
题目输入：
	多个输入样例，以文件尾结束	每个样例的第一行有一个整数N（N<=20120），表示有N个任务，	接着N行，每行有三个整数a,b,c(0<=b<=c<a<2*10^9)，表示任务编号模除a的值在区间[b,c]中
题目输出：
	输出是否有冲突，有输出“发现了冲突！”，否则输出“没有发现冲突！”。
输入样例：
2
7 2 2
9 2 2
2
7 2 3
7 5 6

输出样例：
发现了冲突！
没有发现冲突！

提示：
None



题目：EquationSolver(1389)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Write a program that can solve linear equations with one variable. 
题目输入：
The input file will contain a number of equations, each one on a separate line. All equations are strings of less than 100 characters which strictly adhere to the following grammar (given in EBNF):

    Equation   := Expression '=' Expression
    Expression := Term { ('+' | '-') Term }
    Term       := Factor { '*' Factor }
    Factor     := Number | 'x' | '(' Expression ')'
    Number     := Digit | Digit Number
    Digit      := '0' | '1' | ... | '9'

Although the grammar would allow to construct non-linear equations like "x*x=25", we guarantee that all equations occuring in the input file will be linear in x. We further guarantee that all sub-expressions of an equation will be linear in x too. That means, there won't be test cases like x*x-x*x+x=0 which is a linear equation but contains non-linear sub-expressions (x*x).
Note that all numbers occuring in the input are non-negative integers, while the solution for x is a real number. 
题目输出：
For each test case, print a line saying "Equation #i (where i is the number of the test case) and a line with one of the following answers:

    * If the equation has no solution, print "No solution.".
    * If the equation has infinitely many solutions, print "Infinitely many solutions.".
    * If the equation has exactly one solution, print "x = solution" where solution is replaced by the appropriate real number (printed to six decimals). 

Print a blank line after each test case. 
输入样例：
x+x+x=10
4*x+2=19
3*x=3*x+1+2+3
(42-6*7)*x=2*5-10

输出样例：
Equation #1
x = 3.333333

Equation #2
x = 4.250000

Equation #3
No solution.

Equation #4
Infinitely many solutions.

提示：




题目：澄海3C(1142)
时间限制：1000 ms
空间限制：65535 ms
题目描述：

WAVwind有段时间非常迷恋澄海3C，为什么呢？因为它非常喜欢里面的剑圣和恶魔猎手（或者黑暗游侠和光明游侠）合体的熊猫，这样既有了能力更强的英雄，而减少了操作。WAVwind常常幻想，如果每个英雄都可以和任意的英雄（本来的或合成的）合体，那游戏肯定会更精彩。现在，我们假设这个幻想已经成真，但是每次合体都要花钱（比如剑圣价值A金币，恶魔猎手价值B金币，那么他们两合体需要花费A+B金币的钱）WAVwind很想知道最少花多少钱可以将所有英雄合体.。已知有N个英雄可选，每个英雄有个价值Ai，每次合体得到的新英雄的价值是合体的两个英雄的价值之和。问：为了完成N个英雄的全部合体，WAVwind最少需要花费多少钱？
题目输入：
多组测试数据，一个整数T，表示测试数据个数。每组测试数据以一个整数N开始（1<=N<=100），表示可选英雄个数。下面接着有N个整数，表示每个英雄的价值。
题目输出：
WAVwind最少花费的金币。
输入样例：
1
4
2  7   7   6

输出样例：
 44
提示：




题目：LogsGame(1245)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Bobo and treert, play the following game.There are n logs, each of exactly m meters in length. They move in turns. For each move one chooses a log and cuts off it into some number (more than one) of equal parts, the length of each log is expressed by an integer and is no less than k meters. Each resulting part is also a log which can be cut off in future by any one. The one that can't make a move loses. Thus, the other one wins.Bobo makes the first move. The players play in the optimal way. Determine the winner.
题目输入：
In each case, the first line contains three integers n, m, k (1 ≤ n, m, k ≤ 10^9).


题目输出：
Print "bobo", if bobo wins, or "treert", if treert wins. You should print everything without the quotes.
输入样例：
1 15 4
4 9 5

输出样例：
bobo
treert

提示：
In the first sample they only have one log, of 15 meters in length. Bobo moves first. The only move he can do is to split the log into 3 parts each 5 meters in length. Then treert moves but he can't split any of the resulting logs, as k = 4. Thus, the winner is bobo.
In the second example they have 4 logs 9 meters in length. Bobo can't split any of them, so that the resulting parts possessed the length of not less than 5 meters, that's why he loses instantly.




题目：DoctorNiGONiGO’smulti-coreCPU(1042)
时间限制：3000 ms
空间限制：65536 ms
题目描述：
Doctor NiGONiGO has developed a new kind of multi-core CPU, it works as follow. There are q (1 < q ≤ 50) identical cores in the CPU, and there are p (0 < p ≤ 200) jobs need to be done. Each job should run in some core and need only one unit time. The cores in the CPU can work simultaneously but each core can implement only one job at a time. When a job completed, it will incur a deferral cost. Job i has a deferral cost c(i, j) (0 ≤ c(i, j) ≤ 1000000), where j is the completion time of the job (1 ≤ j ≤ p because any job done in the time later than p obviously not the optimal solution). Here we assume that c(i, j) is a monotonically no decreasing function of j. Now you are asked to find the schedule which have the minimum overall deferral cost.
题目输入：
An integer T indicated the number of test cases. 
For each test case:
There are two integers q, p in first line. 
And Following is p lines, each line contain p integer, the jth integer of the ith line is the deferral cost c(i, j).
题目输出：
For each test case, output a singer integer, which is the minimum total deferral cost of the Problem.
输入样例：
1
2 4
89 145 181 269
4 86 158 164
60 143 157 165
4 45 109 207

输出样例：
254
提示：




题目：AGame(1491)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Consider the following two-player game played with a sequence of N positive integers (2 <= N <= 100) laid onto a game board. Player 1 starts the game. The players move alternately by selecting a number from either the left or the right end of the sequence. That number is then deleted from the board, and its value is added to the score of the player who selected it. A player wins if his sum is greater than his opponents. Write a program that implements the optimal strategy. The optimal strategy yields maximum points when playing against the "best possible" opponent. Your program must further implement an optimal strategy for player 2.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  N, the size of the board  Line 2-etc:  N integers in the range (1..200) that are the contents of the game board, from left to right
题目输出：
Two space-separated integers on a line: the score of Player 1 followed by the score of Player 2.
输入样例：
6
4 7 2 9
5 2
输出样例：
18 11
提示：




题目：DTree(1795)
时间限制：4000
空间限制：65535
题目描述：
There is a skyscraping tree standing on the playground of Nanjing University of Science and Technology. On each branch of the tree is an integer (The tree can be treated as a connected graph with N vertices, while each branch can be treated as a vertex). Today the students under the tree are considering a problem: Can we find such a chain on the tree so that the multiplication of all integers on the chain (mod 10^6+3) equals to K?Can you help them in solving this problem?
题目输入：
There are several test cases, please process till EOF.Each test case starts with a line containing two integersN(1 <= N <= 10^5) and K(0 <= K <= 10^6+3).The following line contains n numbers v_i(1 <= v_i <= 10^6+3), where v_i indicates the integer on vertex i. Then follows N-1 lines. Each line contains two integers x and y,representing an undirected edge between vertex x and vertex y.
题目输出：
For each test case, print a single line containing two integers a and b (where a<b), representing the two endpoints of the chain. If multiply solutions exist, please print the lexicographically smallestone. In case no solution exists, print ``No solution''(without quotes) instead.For more information, please refer to the Sample Output below.
输入样例：
5 60
2 5 2 3 3
1 2
1 3
2 4
2 5
5 2
2 5 2 3 3
1 2
1 3
2 4
2 5
输出样例：
3 4
No solution
提示：
None



题目：GettinginLine (1589)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	Computer networking requires that the computers in the network be linked.	This problem considers a ``linear" network in which the computers are chained together so that each is connected to exactly two others except for the two computers on the ends of the chain which are connected to only one other computer. A picture is shown below. Here the computers are the black dots and their locations in the network are identified by planar coordinates (relative to a coordinate system not shown in the picture).	Distances between linked computers in the network are shown in feet.						For various reasons it is desirable to minimize the length of cable used.	Your problem is to determine how the computers should be connected into such a chain to minimize the total amount of cable needed. In the installation being constructed, the cabling will run beneath the floor, so the amount of cable used to join 2 adjacent computers on the network will be equal to the distance between the computers plus 16 additional feet of cable to connect from the floor to the computers and provide some slack for ease of installation.	The picture below shows the optimal way of connecting the computers shown above, and the total length of cable required for this configuration is (4+16)+ (5+16) + (5.83+16) + (11.18+16) = 90.01 feet.						
题目输入：
	The input file will consist of a series of data sets. Each data set will begin with a line consisting of a single number indicating the number of computers in a network. Each network has at least 2 and at most 8 computers. A value of 0 for the number of computers indicates the end of input.	After the initial line in a data set specifying the number of computers in a network, each additional line in the data set will give the coordinates of a computer in the network. These coordinates will be integers in the range 0 to 150. No two computers are at identical locations and each computer will be listed once.	
题目输出：
	The output for each network should include a line which tells the number of the network (as determined by its position in the input data), and one line for each length of cable to be cut to connect each adjacent pair of computers in the network. The final line should be a sentence indicating the total amount of cable used.	In listing the lengths of cable to be cut, traverse the network from one end to the other. (It makes no difference at which end you start.) Use a format similar to the one shown in the sample output, with a line of asterisks separating output for different networks and with distances in feet printed to 2 decimal places.	
输入样例：
6
5 19
55 28
38 101
28 62
111 84
43 116
5
11 27
84 99
142 81
88 30
95 38
3
132 73
49 86
72 111
0
输出样例：
**********************************************************
Network #1
Cable requirement to connect (5,19) to (55,28) is 66.80 feet.
Cable requirement to connect (55,28) to (28,62) is 59.42 feet.
Cable requirement to connect (28,62) to (38,101) is 56.26 feet.
Cable requirement to connect (38,101) to (43,116) is 31.81 feet.
Cable requirement to connect (43,116) to (111,84) is 91.15 feet.
Number of feet of cable required is 305.45.
**********************************************************
Network #2
Cable requirement to connect (11,27) to (88,30) is 93.06 feet.
Cable requirement to connect (88,30) to (95,38) is 26.63 feet.
Cable requirement to connect (95,38) to (84,99) is 77.98 feet.
Cable requirement to connect (84,99) to (142,81) is 76.73 feet.
Number of feet of cable required is 274.40.
**********************************************************
Network #3
Cable requirement to connect (132,73) to (72,111) is 87.02 feet.
Cable requirement to connect (72,111) to (49,86) is 49.97 feet.
Number of feet of cable required is 136.99.

提示：
None



题目：岛国的火车票(1691)
时间限制：2000MS
空间限制：131070Kb
题目描述：
岛国是一个狭长的国家，由于国家的人数越来越多，所以他们开始不断的和邻国发生争议，想要将天朝的钓鱼岛国有化，骗取棒子的独岛……额，扯远了……言归正传，在岛国，只有一条铁路干线，而火车在每段路上的载客人数又是固定的，因此对火车票管理系统的要求也越来越高，现在他们在完成一个新的系统，实现以下功能：采用先来先服务的方式，对于每个来买票的人，尽可能的多给他想要的票（每个人买的票不超过10张，以每张票的起点、终点表示这张票），有多种方式可以达到最大张数时，输出字典最小的方案（见样例说明）。
题目输入：
	第一行一个整数case(case<=20)，表示测试数据的组数。	对于每组测试数据第一行三个整数N,K,Q。（N表示火车站的个数，标号从1到N。K表示每段路上的载客最大值，Q表示来买票的人数）接下来Q部分，每部分第一行一个整数m，表示当前这个人要买的票数，接下来m对数，每对数a,b表示有一张票是从a站到b站。	（N<=50000,K<=100,Q<=1000,m<=10,1<=a<b<=N）
题目输出：
	对于每个来买票的人，输出两行，第一行一个整数w，表示他最多可以买到的火车票张数，第二行w对数，形如(A1,B1)(A2,B2)...(Aw,Bw)，如果w为0，直接输出空行。
输入样例：
1
10 2 3
3
1 5
3 6
2 7
1
3 7
1
6 10

输出样例：
2
(1 5)(2 7)
0

1
(6 10)

提示：

	对于第一个来买票的人，最多可以给他两张票，可以有两种方案，(1 5)(3
6) 和(1 5)(2 7)，字典序的比较是两种方案的每张票依次比较过去，先比较起点，若起点相同再比较终点。因此后者字典序较小，所以输出后者。




题目：Frogger(1390)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Freddy Frog is sitting on a stone in the middle of a lake. Suddenly he notices Fiona Frog who is sitting on another stone. He plans to visit her, but since the water is dirty and full of tourists' sunscreen, he wants to avoid swimming and instead reach her by jumping. Unfortunately Fiona's stone is out of his jump range. Therefore Freddy considers to use other stones as intermediate stops and reach her by a sequence of several small jumps. To execute a given sequence of jumps, a frog's jump range obviously must be at least as long as the longest jump occuring in the sequence. The frog distance (humans also call it minimax distance) between two stones therefore is defined as the minimum necessary jump range over all possible paths between the two stones. 
You are given the coordinates of Freddy's stone, Fiona's stone and all other stones in the lake. Your job is to compute the frog distance between Freddy's and Fiona's stone. 
题目输入：
The input file will contain one or more test cases. The first line of each test case will contain the number of stones n (2<=n<=200). The next n lines each contain two integers xi,yi (0 <= xi,yi <= 1000) representing the coordinates of stone #i. Stone #1 is Freddy's stone, stone #2 is Fiona's stone, the other n-2 stones are unoccupied. There's a blank line following each test case. Input is terminated by a value of zero (0) for n. 
题目输出：
For each test case, print a line saying "Scenario #x" and a line saying "Frog Distance = y" where x is replaced by the test case number (they are numbered from 1) and y is replaced by the appropriate real number, printed to three decimals. Put a blank line after each test case, even after the last one. 
输入样例：
2
0 0
3 4

3
17 4
19 4
18 5

0

输出样例：
Scenario #1
Frog Distance = 5.000

Scenario #2
Frog Distance = 1.414

提示：




题目：LuckyNumber(1246)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Bobo loves numbers and 9 is his most favorite. When encountering a number, he always calculates its lucky remainder - the remainder after division by 9.This time bobo is given a number X of length N which contains no zeros. He is asked to find the supersum of X: super(X). super(X) is defined as follows. For a given non-full set S of digit positions in X we erase the digits in these positions to obtain a sub-number. For example, if X = 12345 and S = {2, 4} we erase 2nd and 4th digits and obtain a sub-number 135. Supersum of X is simply the sum of sub-numbers for all valid sets S. For example, if X is 123, then super(X) = 123 + 12 + 13 + 23 + 1 + 2 + 3 = 177.Calculating super(X) is very difficult for bobo. However, before getting to work he is wondering if it is possible to quickly tell what the lucky reminder of the supersum of X is. You have to help him.
题目输入：
In each case, you will be given a number X (1 <= X <= 10^50), which each digit of X will be one of the following: 1, 2, 3, 4, 5, 6, 7, 8, 9.

题目输出：
Just print one number a line, which defines the lucky reminder of the supersum of X.

输入样例：
123
24816
8
11235813213455
输出样例：
6
3
8
7

提示：
Example from the problem statement. super(123) = 177, which gives remainder 6 after division by 9.
You are expected to use long long.




题目：ClosedFences(1492)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A closed fence in the plane is a set of non-crossing, connected line segments with N corners (3 < N < 200). The corners or vertices are each distinct and are listed in counter-clockwise order in an array {xi, yi}, i in (1..N). Every pair of adjacent vertices defines a side of the fence. Thus {xi yi xi+1 yi+1} is a side of the fence for all i in (1..N). For our purposes, N+1 = 1, so that the first and last vertices making the fence closed. Here is a typical closed fence and a point x,y:                          * x3,y3                 x5,y5  /     x,y *          *   /                     /  /                      /   *                  x6,y6*   x4,y4                     |                              |                          x1,y1*----------------* x2,y2Write a program which will do the following: Test an ordered list of vertices {xi,yi}, i in (1..N) to see if the array is a valid fence. Find the set of fence sides that a person (with no height) who is standing in the plane at position (x,y) can "see" when looking at the fence. The location x,y may fall anywhere not on the fence. A fence side can be seen if there exists a ray that connects (x,y) and any point on the side, and the ray does not intersect any other side of the fence. A side that is parallel to the line of sight is not considered visible. In the figure, above the segments x3,y3-x4,y4; x5,y5-x6,y6; and x6-y6-x1,y1 are visible or partially visible from x,y.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  N, the number of corners in the fence  Line 2:  Two space-separated integers, x and y, that are the location of the observer. Both integers will fit into 16 bits. Line 3-N+2:  A pair of space-separated integers denoting the X,Y location of the corner. The pairs are given in counterclockwise order. Both integers are no larger than 1000 in magnitude.
题目输出：
If the sequence is not a valid fence, the output is a single line containing the word "NOFENCE". Otherwise, the output is a listing of visible fence segments, one per line, shown as four space-separated integers that represent the two corners. Express the points in the segment by showing first the point that is earlier in the input, then the point that is later. Sort the segments for output by examining the last point and showing first those points that are earlier in the input. Use the same rule on the first of the two points in case of ties.
输入样例：
13
5 5
0 0
7 0
5 2
7 5
5 7
3 5
4 9
1 8
2 5
0 9
-2 7
0 3
-3 1
输出样例：
7
0 0 7 0
5 2 7 5
7 5 5 7
5 7 3 5
-2 7 0 3
0 0 -3 1
0 3 -3 1
提示：




题目：TheMummyReturns(1043)
时间限制：2000 ms
空间限制：65536 ms
题目描述：
The mummy returns! Imhotep has caught O’Connell’s little child to the Oasis of Ahm Shere to resurrect the Scorpion King. To rescue their son, O’Connell and Evelyn follow him, as well as our famous playboy, Jonathan. The Scorpion King gobbles up the power of Imhotep and becomes more powerful. The only way to kill him is to stab him with the Sword of Holy, which is in the hand of our playboy. This was simple because Jonathan was good at playing dart. But things turn bad when Imhotep is between Jonathan and the Scorpion King. If the sword stabs Imhotep before the Scorpion King, Imhotep will get back his power and become unbeatable! The two heroes, O’Connell and Evelyn, are fighting to make the two devil unmoved, and the playboy, Jonathan, is trying to kill the Scorpion King without hurting Imhotep. Will he make it?
To simplify the problem, we assume that the two devils are two untouched circles, the sword is a point outside the circles, and its flying path is a straight ray. Giving the description of the two circles and the point, can you tell if there is a ray from the point which can intersect the circle of the Scorpion King without intersect the circle of Imhotep? Here two items intersect means they share at least one common point.
题目输入：
The input file consists of multiple test cases.
The only one line of each test case consists following parameters: Xs, Ys, Xi, Yi, Ri, Xk, Yk, Rk.
(Xs, Ys) is the location of the Sword of Holy.
(Xi, Yi) is the location of Imhotep, and Ri is its radius.
(Xk, Yk) is the location of the Scorpion King, and Rk is its radius.
Your program should process to the end of the input file.
题目输出：
For each test case, output one line consisting of one English word “Yes” if Jonathon can kill the Scorpion King without hurt Imhotep, or “No” if not.
输入样例：
0 0 0 1 0.5 0 3 0.5
0 0 0 1 0.5 1 0 0.5
输出样例：
No
Yes
提示：




题目：newfarkingloveagirl(1143)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
newFarking is a child in our ACM team.He want to get a girl's love。。。。。。。。
题目输入：
nothing

题目输出：
print the name of the girl .

输入样例：
nothing
输出样例：
Queenylv
提示：




题目：Cold(1806)
时间限制：4000 ms
空间限制：65535 KB
题目描述：
这两天冻死了，把王大锤都冻傻了，他想要知道到底有多冷，他把过去n天（编号1~n，1<=n<=1000）的气温t（-20~50）和天气状况w（晴，雨，雪）都翻了出来，并定义了一个冷指数c，譬如从第i天至第j天的c值=最低气温-2*雨天数-雪天数^2+晴天数。他一定是冻傻了，他想最冷是多冷，即c值的最小值。
题目输入：
多case，以EOF结尾。
第一行，一个整数n（1<=n<=1000）。
接下来n行，每行两个数，空格隔开，t w,t(-20<=t<=50),w(1表示晴天，0表示雨天，-1表示雪天)。
题目输出：
输出最冷的区间的c值。
输入样例：
4
1 1
2 1
3 1
4 1
输出样例：
2
提示：




题目：调整队形(1692)
时间限制：2000MS
空间限制：65535Kb
题目描述：
	YQ很喜欢跟小孩子玩，因为她觉得他们很可爱。正在实习的她就面对一群小朋友。现在她要给这些小朋友排一下队，考虑到很多因素，她要对刚开始排好的队伍进行下面的调整。	1 Move a b k: 把排在a到b的小朋友一起移动到排在k的小朋友后面。如果当前的队伍是1 2 3 4 5 6 7 8，进行move 3 5 4 ，首先把[3,5]的数取出，剩下的数为1 2 6 7 8,再把这些小朋友插到排在第4的小朋友后面，最后的队伍为 1 2 6 7 3 4 5 8。如果k=0，表示把这些小朋友放到队首。	2 Flip a b :把排a到b的小朋友的，顺序颠倒一下。如果当前的队伍为1 2 5 4 3 6 7 8，进行flip 3 5, 最后的队尾为1 2 3 4 5 6 7 8。	 为了让这些小孩子能听自己的话，刚开始的时候，YQ给每个小朋友都发了一下糖果。她现在请你帮为她做完成两件事。	1 她在调整队伍的过程，她想知道某个区间的小朋友手中拿到的糖果最多是多少个。当输入为Max a b 时，输出排在a到b的小朋友拿到最多的糖果是多少。	2 最后在所有的输入结束，输出现在队伍中每个小朋友手中的糖果的个数。
题目输入：
	输入数据第一行两个整数N和M，表示小朋友的个数。第二行有N个数，表示刚开始每个小朋友手中拿到的糖果个数。接下来有M行。输入格式为题目描述中得Move,Flip和Max 三种。其中，1<N,M<=100,000，小朋友手中的糖果个数x，满足0<x<100,000。所有的输入数据都是合法的。
题目输出：
	对于每个max询问，输出当前区间最多的糖果个数。	最后再输出经过调整后队伍中每个小朋友手中的糖果的个数。
输入样例：
6 4
3 2 1 6 5 4
Max 1 3
Move 4 6 0
Max 1 3
Flip 1 6

输出样例：
3
6	
1 2 3 4 5 6

提示：

	刚开始每个小朋友手中的糖果为 3 2 1 6 5 4 所以询问排在第1到第3的小朋友手中最多糖果个数为3。


	Move操作之后的每个小朋友手中糖果为 6 5 4 3 2 1。此时再询问排在第1到第3的小朋友手中最多糖果个数，为6。


	Flip 1 6操作结束后，最后的队伍中每个小朋友的糖果为 1 2 3 4 5 6。




题目：MothEradication (1590)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	Entomologists in the Northeast have set out traps to determine the influx of Jolliet moths into the area. They plan to study eradication programs that have some potential to control the spread of the moth population.	The study calls for organizing the traps in which moths have been caught into compact regions, which will then be used to test each eradication program. A region is defined as the polygon with the minimum length perimeter that can enclose all traps within that region. For example, the traps (represented by dots) of a particular region and its associated polygon are illustrated below.						You must write a program that can take as input the locations of traps in a region and output the locations of traps that lie on the perimeter of the region as well as the length of the perimeter.	
题目输入：
	The input file will contain records of data for several regions. The first line of each record contains the number (an integer) of traps for that region. Subsequent lines of the record contain 2 real numbers that are the x- and y-coordinates of the trap locations. Data within a single record will not be duplicated. End of input is indicated by a region with 0 traps.	
题目输出：
	Output for a single region is displayed on at least 3 lines:						One blank line must separate output from consecutive input records.	
输入样例：
3
1 2
4 10
5 12.3
6
0 0
1 1
3.1 1.3
3 4.5
6 2.1
2 -3.2
7
1 0.5
5 0
4 1.5
3 -0.2
2.5 -1.5
0 0
2 2
0
输出样例：
Region #1:
(1.0,2.0)-(4.0,10.0)-(5.0,12.3)-(1.0,2.0)
Perimeter length = 22.10

Region #2:
(0.0,0.0)-(3.0,4.5)-(6.0,2.1)-(2.0,-3.2)-(0.0,0.0)
Perimeter length = 19.66

Region #3:
(0.0,0.0)-(2.0,2.0)-(4.0,1.5)-(5.0,0.0)-(2.5,-1.5)-(0.0,0.0)
Perimeter length = 12.52
提示：
None



题目：Globetrotter(1391)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
As a member of an ACM programming team you'll soon find yourself always traveling around the world: Zürich, Philadelphia, San José, Atlanta,... from 1999 on the Contest Finals even will be on a different continent each year, so one day you might get to Japan or Australia. At the contest site it would be interesting to know how many miles you are away from home. For this sake, your job is to write a program to compute the geographical distance between two given locations on the Earth's surface. We assume that the Earth is a perfect sphere with a radius of exactly 6378 km. The geographical distance between A and B is the length of the geodetic line segment connecting A and B. The geodetic line segment between two points on a sphere is the shortest connecting curve lying entirely in the surface of the sphere. The value of pi is approximately 3.141592653589793.
题目输入：
The input file will consist of two parts: a list of cities and a list of queries.
City List
The city list consists of up to 100 lines, one line per city. Each line will contain a string ci and two real numbers lati and longi, representing the city name, its latitude and its longitude, respectively.
The city name will be shorter than 30 characters and will not contain white-space characters.
The latitude will be between -90 (South Pole) and +90 (North Pole). The longitude will be between -180 and +180 where negative numbers denote locations west of the meridian and positive numbers denote locations east of the meridian. (The meridian passes through Greenwich, London.)
The city list will be terminated by a line consisting of a single "#".
Query List
Each line will contain two city names A and B.
The query list will be terminated by the line "# #". 
题目输出：
For each query, print a line saying "A - B" where A and B are replaced by the city names. Then print a line saying x km" where x is replaced by the geographical distance (in km) between the two cities, rounded to the nearest integer.
If one of the cities in the query didn't occur in the city list, print a line saying "Unknown" instead. Print a blank line after each query. 
输入样例：
Ulm		48.700	10.500
Freiburg	47.700	9.500	
Philadelphia	39.883	-75.250
SanJose		37.366	-121.933
NorthPole	90	0
SouthPole	-90	0
#
Ulm Philadelphia
Ulm SanJose
Freiburg Philadelphia
Freiburg SanJose
Ulm Freiburg
SanJose Philadelphia
Ulm LasVegas
Ulm Ulm
Ulm NorthPole
Ulm SouthPole
NorthPole SouthPole
# #

输出样例：
Ulm - Philadelphia
6536 km

Ulm - SanJose
9367 km

Freiburg - Philadelphia
6519 km

Freiburg - SanJose
9412 km

Ulm - Freiburg
134 km

SanJose - Philadelphia
4023 km

Ulm - LasVegas
Unknown

Ulm - Ulm
0 km

Ulm - NorthPole
4597 km

Ulm - SouthPole
15440 km

NorthPole - SouthPole
20037 km

提示：




题目：NewProblem(1247)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
有一个无向图，现在不断地从中删边，并随机的问两点是否连通。
题目输入：
单case

第一行两个整数n，m(表示边点数目，边点都从0开始编号)(4 < n < 10000,4< m < 100000)

下面m行是边描述格式“ab”(重边、自交边都可能有)

接着一个整数p(4< p < 200000)
随后p行操作

有两种

	delete i：删除第i条边
	ask a b ：问a，b是否连通
题目输出：
对于每个ask，输出“yes”或“no”
输入样例：
5 5
13
14
12
10
43
10
ask 0 3
delete 0
ask 1 2
delete 1
ask 2 3
delete 2
ask 0 1
ask 0 3
delete 3
ask 1 2
输出样例：
yes
yes
no
yes
no
no
提示：




题目：AmericanHeritage(1493)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer John takes the heritage of his cows very seriously. He is not, however, a truly fine bookkeeper. He keeps his cow genealogies as binary trees and, instead of writing them in graphic form, he records them in the more linear `tree in-order' and `tree pre-order' notations. Your job is to create the `tree post-order' notation of a cow's heritage after being given the in-order and pre-order notations. Each cow name is encoded as a unique letter. (You may already know that you can frequently reconstruct a tree from any two of the ordered traversals.) Obviously, the trees will have no more than 26 nodes. Here is a graphical representation of the tree used in the sample input and output:                   C                /                  /                   B       G             /      /            A   D   H               /               E   FThe in-order traversal of this tree prints the left sub-tree, the root, and the right sub-tree. The pre-order traversal of this tree prints the root, the left sub-tree, and the right sub-tree. The post-order traversal of this tree print the left sub-tree, the right sub-tree, and the root.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  The in-order representation of a tree.  Line 2:  The pre-order representation of that same tree.
题目输出：
A single line with the post-order representation of the tree.
输入样例：
ABEDFCHG
CBADEFGH
输出样例：
AEFDBHGC
提示：




题目：aeasyproblem,canyou1A(1144)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Problems in Computer Science are often classified as belonging to a certain class of problems (e.g., NP, Unsolvable, Recursive). In this problem you will be analyzing a property of an algorithm whose classification is not known for all possible inputs. Consider the following algorithm: 
   1.    input n
  2.    print n
  3.    if n = 1 then STOP
  4.       if n is odd then   n <-- 3n+1
  5.       else   n <-- n/2
  6.    GOTO 2
 
Given the input 22, the following sequence of numbers will be printed 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 
It is conjectured that the algorithm above will terminate (when a 1 is printed) for any integral input value. Despite the simplicity of the algorithm, it is unknown whether this conjecture is true. It has been verified, however, for all integers n such that 0 < n < 1,000,000 (and, in fact, for many more numbers than this.) 
Given an input n, it is possible to determine the number of numbers printed before the 1 is printed. For a given n this is called the cycle-length of n. In the example above, the cycle length of 22 is 16. 
For any two numbers i and j you are to determine the maximum cycle length over all numbers between i and j. 
 
题目输入：
The input will consist of a series of pairs of integers i and j, one pair of integers per line. All integers will be less than 100,000 and greater than 0. 

You should process all pairs of integers and for each pair determine the maximum cycle length over all integers between and including i and j. 
You can assume that no operation overflows a 32-bit integer
题目输出：
For each pair of input integers i and j you should output i, j, and the maximum cycle length for integers between and including i and j. These three numbers should be separated by at least one space with all three numbers on one line and with one line of output for each line of input. The integers i and j must appear in the output in the same order in which they appeared in the input and should be followed by the maximum cycle length (on the same line). 
输入样例：
1 10
100 200
201 210
900 1000
输出样例：
1 10 20
100 200 125
201 210 89
900 1000 174
提示：
c-lou is a good boy so he only provided ten series of pairs integers i and j.



题目：JudgingFillingProblems(1044)
时间限制：2000 ms
空间限制：65536 ms
题目描述：
Yiyi is trying to develop an examine system. He finds it not so easy to judge filling question. There may be multiple answers for a blank, For example, The 2008 Olympic games was hold in ____City，The answer can be “Beijing”, and it can also be “Peking”, he made the answer like this: Beijing(Peking), which means that Beijing, Peking are both correct answers; A filling question may have several blanks, For some problems those blanks should be answered in order, for example, The 2000, 2004 Olympic games was hold respectively in ____City and ____City, The answer should be “Sydney Athens”; For other problems those blanks don’t need be answered in order, for example, ACRush has taken part in the ICPC world finals in the year ____ and ____, The answer could be “2007|2009”, and it can also be “2009|2007”. Now you are required to help him to write a program to judge the filling problems.
题目输入：
The first line contains an integer N, indicate the number of problems. The following N*3 lines, each 3 lines indicate a filling problem, the first line is the question, the second line is the answer(There will not be a answer contains ‘|’, ’(‘, ’)’ for every blank, For one problem every neighboring blanks are separated by “|” ), the third line indicate if the blanks should be filled in order, the word “True” means the blanks should be filled in order while “False” means that filling the blanks in order is not necessary. The following line contains an integer M, indicate the number of person, each person will fill all the problems, so there follows N*M lines, each N lines indicate a person’s answer for the N problems (There will not be a answer contains ‘|’, ‘(’, ‘)’ for every blank, For one problem every neighboring blanks are separated by “|” ), according to the sequence of the N problems.
题目输出：
There are M lines, for each person, write the number of blanks he/she filled correctly.
输入样例：
3
The 2004, 2008 Olympic games was hold respectively in ____City and ____City.
Athens|Beijing(Peking)
True
ACRush has taken part in the ICPC world finals in the year ____ and ____.
2007|2009
False
Aaaa____bbbb_____.
Ccc(cc)|Ddd(dd)
False
2
Athens|Beijing
2007|2009
Dd|cc
Beijing|Athens
2009|2008
Ddd|cc

输出样例：
5
3
提示：




题目：QuickSort(1807)
时间限制：5000 ms
空间限制：65535 KB
题目描述：
shangke7788最近学习了各种排序算法，有冒泡排序、选择排序、希尔排序、快速排序、归并排序和堆排序等等。
现在shangke7788有n个数字组成了一个数组，为了简化问题，这n个数字分别是1~n，每个数字当且仅当出现一次，shangke7788规定，对于里面的数字v只能和与他差值为1的数字进行交换，即v只能与v+1或者v-1进行交换，shangke7788比较关心最少的交换次数使得整个数组排成从小到大的序列，你能告诉他吗？
题目输入：
第一行输入一个T，表示有T组测试数据。
每组测试数据，第一行输入一个整数n(1 <= n <= 2000)，表示有n个数字。
接下来输入n个数字，数字范围在1~n之间，每个数字都不相同。
题目输出：
每组测试数据，按照输出格式"Case #X: Y"，其中X是当前的Case数，从1开始计数递增，Y就是你的答案。
输入样例：
2
4
3 4 1 2
5
5 4 3 2 1
输出样例：
Case #1: 4
Case #2: 10
提示：




题目：盖房子(1693)
时间限制：1000MS
空间限制：65535KB
题目描述：
	手机上的都市摩天楼的游戏大家想必都玩过，当年曾经让snow和xiaoyoulei课上课下玩了很多天，一直想找到个最优的建筑方案，于是想到了用程序去解决。	为了让题目更简单，我们简化了游戏，游戏规则如下：	地图是一个4*4的矩形，每格最多摆一个房子	格子相邻指有条边是公共的	有3种房子，蓝房子，红房子，绿房子	每种房子有个固定的价值	蓝房子随便摆，红房子只能摆在有蓝房子相邻的格子上，绿房子只能摆在有蓝房子和红房子相邻的格子上，该格子上原来的房子可以被拆掉。	如果知道了每种房子的价值，snow想知道价值最大是多少。
题目输入：
	第一行是Case数	对于每个case	3个整数，vb,vr,vg，代表蓝房子，红房子，绿房子的价值。0< vb,vr,vg <1000
题目输出：
	返回最大的价值
输入样例：
2
1 1 1
1 2 1

输出样例：
16
31

提示：
None



题目：Othello (1591)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	Othello is a game played by two people on an 8 x 8 board, using disks that are white on one side and black on the other. One player places disks with the white side up and the other player places disks with the black side up. The players alternate placing one disk on an unoccupied space on the board. In placing a disk, the player must bracket at least one of the other color disks. Disks are bracketed if they are in a straight line horizontally, vertically, or diagonally, with a disk of the current player's color at each end of the line. When a move is made, all the disks that were bracketed are changed to the color of the player making the move. (It is possible that disks will be bracketed across more than one line in a single move.)		Write a program to read a series of Othello games. The first line of the input is the number of games to be processed. Each game consists of a board configuration followed by a list of commands. The board configuration consists of 9 lines. The first 8 specify the current state of the board. Each of these 8 lines contains 8 characters, and each of these characters will be one of the following:		`-' 		 indicating an unoccupied square		`B' 		 indicating a square occupied by a black disk		`W' 		 indicating a square occupied by a white disk		The ninth line is either a `B' or a `W' to indicate which is the current player. You may assume that the data is legally formatted.	The commands are to list all possible moves for the current player, make a move, or quit the current game. There is one command per line with no blanks in the input. Commands are formatted as follows:	List all possible moves for the current player.	The command is an `L' in the first column of the line. The program should go through the board and print all legal moves for the current player in the format (x,y) where x represents the row of the legal move and y represents its column. These moves should be printed in row major order which means:	1)	all legal moves in row number i will be printed before any legal move in row number j if j is greater than i	and 2)	if there is more than one legal move in row number i, the moves will be printed in ascending order based on column number.	All legal moves should be put on one line. If there is no legal move because it is impossible for the current player to bracket any pieces, the program should print the message ``No legal move."	Make a move.	The command is an `M' in the first column of the line, followed by 2 digits in the second and third column of the line. The digits are the row and the column of the space to place the piece of the current player's color, unless the current player has no legal move. If the current player has no legal move, the current player is first changed to the other player and the move will be the move of the new current player. You may assume that the move is then legal. You should record the changes to the board, including adding the new piece and changing the color of all bracketed pieces. At the end of the move, print the number of pieces of each color on the board in the format ``Black - xx White - yy" where xx is the number of black pieces on the board and yy is the number of white pieces on the board. After a move, the current player will be changed to the player that did not move.	Quit the current game.	The command will be a `Q' in the first column of the line. At this point, print the final board configuration using the same format as was used in the input. This terminates input for the current game.	You may assume that the commands will be syntactically correct. Put one blank line between output from separate games and no blank lines anywhere else in the output.	
题目输入：
no
题目输出：
no
输入样例：
2
--------
--------
--------
---WB---
---BW---
--------
--------
--------
W
L
M35
L
Q
WWWWB---
WWWB----
WWB-----
WB------
--------
--------
--------
--------
B
L
M25
L
Q
输出样例：
(3,5) (4,6) (5,3) (6,4)
Black -  1 White -  4
(3,4) (3,6) (5,6)
--------
--------
----W---
---WW---
---BW---
--------
--------
--------

No legal move.
Black -  3 White - 12
(3,5)
WWWWB---
WWWWW---
WWB-----
WB------
--------
--------
--------
--------

提示：
None



题目：最长上凸序列(1248)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
相信大家都做过了最长递增子序列问题，现在有一个新问题，找一个先递增后递减的最长序列，就叫做最长上凸序列。
题目输入：
多case

对于每个case
第一行一个整数n(4< n < 100000)
第二行n个整数
题目输出：
对于每组case输出最长上凸序列的长度
输入样例：
10
1 2 3 4 5 6 7 8 9 0
6
2 5 8 3 6 3
输出样例：
10
5
提示：




题目：TreeRecovery(1392)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Little Valentine liked playing with binary trees very much. Her favorite game was constructing randomly looking binary trees with capital letters in the nodes. This is an example of one of her creations:                                                D
                                              / \
                                             /   \
                                            B     E
                                           / \     \
                                          /   \     \
                                         A     C     G
                                                    /
                                                   /
                                                  F

To record her trees for future generations, she wrote down two strings for each tree: a preorder traversal (root, left subtree, right subtree) and an inorder traversal (left subtree, root, right subtree). For the tree drawn above the preorder traversal is DBACEGF and the inorder traversal is ABCDEFG. She thought that such a pair of strings would give enough information to reconstruct the tree later (but she never tried it). 
Now, years later, looking again at the strings, she realized that reconstructing the trees was indeed possible, but only because she never had used the same letter twice in the same tree. However, doing the reconstruction by hand, soon turned out to be tedious. So now she asks you to write a program that does the job for her! 
题目输入：
The input file will contain one or more test cases.
Each test case consists of one line containing two strings preord and inord, representing the preorder traversal and inorder traversal of a binary tree. Both strings consist of unique capital letters. (Thus they are not longer than 26 characters.)
Input is terminated by end of file. 
题目输出：
For each test case, recover Valentine's binary tree and print one line containing the tree's postorder traversal (left subtree, right subtree, root). 
输入样例：
DBACEGF ABCDEFG
BCAD CBAD

输出样例：
ACBFGED
CDAB

提示：




题目：ElectricFence(1494)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
In this problem, `lattice points' in the plane are points with integer coordinates. In order to contain his cows, Farmer John constructs a triangular electric fence by stringing a "hot" wire from the origin (0,0) to a lattice point [n,m] (0<=;n<32000, 0<m<32000), then to a lattice point on the positive x axis [p,0] (p>0), and then back to the origin (0,0). A cow can be placed at each lattice point within the fence without touching the fence (very thin cows). Cows can not be placed on lattice points that the fence touches. How many cows can a given fence hold?
题目输入：
There are several test cases, end by EOF, for each test case:The single input line contains three space-separated integers that denote n, m, and p.
题目输出：
A single line with a single integer that represents the number of cows the specified fence can hold.
输入样例：
7 5 10
输出样例：
20
提示：




题目：RP(1145)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
最近huangc感觉自己的RP消耗很快，于是他决定去RP中心找一些事做增加自己的RP。huangc来到RP中心发现有N件事可以做，做每一件事耗费的体力值不同，增加的RP也不同，如果huangc做第i件事，他将耗费体力值wi，得到RP值ri，RP中心为了防止狂刷RP的事情发生，规定第i件事做的次数不能超过hi次（即<= hi），如果超过hi次，他这次得到的RP将为（ ri - （做的次数 -hi ） * ci ）。例如：当i=1,wi=5,ri=3,hi=2,ci=2时，做这件事第1次，消耗体力值5，得到RP值3；做这件事第2次，消耗体力值5，得到RP值3；做这件事第3次，消耗体力值5，得到RP值1；做这件事第4次，消耗体力值5，得到RP值-1；做这件事第5次，消耗体力值5，得到RP值-3；……
题目输入：
第一行输入t(1<=t<=200)，代表有t组测试数据。接下来每组测试数据第一行输入N ( 1 <= N <= 50)、Q( 3000 <= Q<= 10000)，表示有N件事，体力值为Q，接下来N行每行输入wi,ri,hi,ci。(0<=wi<=Q),(0<=ri<=50),(0<=hi<=10),
(0<=ci<=30) 
题目输出：
对于每组测试数据输出huangc能获得的最大RP值。
输入样例：
3
3 20
3 5 2 4
2 4 4 6
6 10 1 2
5 50
20 30 10 1
10 5 5 5
5 4 7 2
10 20 2 5
10 20 2 4
2 30
10 20 2 3
8 12 5 4
输出样例：
36
96
57

提示：




题目：XiaoQian’sProblem(1045)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Xiao Qian is a beautiful and clever girl in our ACM team.So many boys fall in love with her.They are all handsome.Now Xiao Qian wants to choose one from them.She wanted to choose the one who can make much money in the future.She designs a problem as follow.
   In the N*N(0≤N≤20) grids,she puts some money in some grids.Xiao Qian is not rich.So she will put at most 100 in every grid.Boys should start from the left-up grid and leave from the right-down grid.And boys can only walk down or walk right.When someone gets one grid,he will get all the money.After that, Xiao Qian will put some money in it.Xiao Qian want her girlfriend a patient one.So she asks the boys walk from left-up to right-down 3 times.
   Can you calculate the maximum money one can get?

题目输入：
One integer N
N*N integers are the initial money in every grid.
N*N integers are the money Xiao Qian put after the money be taken in every grid.
End of file

题目输出：
Output the maximum money one can get.
输入样例：
4
1 2 3 4
2 1 3 4
1 2 3 4
1 3 2 4
1 1 1 1 
1 1 1 1
1 1 1 1
1 1 1 1

输出样例：
43
提示：
My English is so poor.It’s not easy for me to write in English.This problem is not so hard.Please AC it.



题目：TheGame(1808)
时间限制：1000 ms
空间限制：65535 KB
题目描述：
Over centuries ago, mankind faced a new enemy, the Titans. The difference of power between mankind and their newfound enemy was overwhelming. Soon, mankind was driven to the brink of extinction. Luckily, the surviving humans managed to build three walls: Wall Maria, Wall Rose and Wall Sina. Owing to the protection of the walls, they lived in peace for more than one hundred years.

But not for long, a colossal Titan appeared out of nowhere. Instantly, the walls were shattered, along with the illusory peace of everyday life. Wall Maria was abandoned and human activity was pushed back to Wall Rose. Then mankind began to realize, hiding behind the walls equaled to death and they should manage an attack on the Titans.

While commander Pixis think intelligence is the key of winning the war. So,he chooses the very clever soldiers Armin to play a game with him with the purpose of training him.And the game’s rules are: Pixis and Armin play the game on a white board with many grids.The board has f(n) rows and f(m) columns, so it contains f(n)*f(m) grids. The two people play the game in turn and Pixis let Armin start first and then he plays. In every turn the man who plays need to choose a quadrilateral with the sizes of 1*k or k*1 and the area he choose has to be completely white, then fill the area in black.(The positive integer k(1<=k<=max(f(n),f(m))) is decided by the player in every turn). So, the man who fills the last grid in black is the winner.

Now,we let f(n) be a sum of digits for positive integer n. If f(n) is one-digit number then f(n) is n and otherwise f(n) is equal to f(f(n)). For example, f(987) is 6,because f(987)=f(24)=f(6)=6. 

And now we assume the two man are both clever enough,so they can both take the best strategy. Can you predict who is the winner just according the size of board ?
题目输入：
The first line has two numbers n and m (1<=n,m<=1e9) which means the size of board.
题目输出：
Please print the name of winner, Pixis or Armin.
输入样例：
1 22 2
输出样例：
ArminPixis
提示：




题目：fishhead的游戏(1694)
时间限制：10000MS
空间限制：65535KB
题目描述：
	 	Fishhead做土财主的日子很是无趣，于是便想到了扔色子玩比大小的游戏。他创造了2枚n面体的色子，两个色子每个面上都是不同的数，且每个色子n个面被扔到的概率一样大。每人扔一次，谁大谁赢。但是由于玩的时间长了，一个色子的某些面已经被磨损了。Fishhead想请人帮忙把色子修复。	修复的规则是	将磨损的面填上某个数字或不填。	填完后所有有数字的面的值都不一样。	不填的面数字=0。	所有数字的范围都在1-x之间。	显然色子有很多种修复的方法。但是为了能进行游戏，鱼头想在修好之后2个人赢的概率尽量的接近，即abs(a赢的概率-b赢得概率)最小。输出abs(a赢的概率-b赢得概率)最小的值。	
题目输入：
	第一行是Case数	每组case之间有空行	对于每个case第一行是2个整数，n，x。0<n<=50  n*2<=X<=1000000000第二行 每行n个数,表示可能磨损的色子某一面的值，0代表磨损了。0<=每个面上的值<=x第三行 每行n个数,表示没有磨损的色子某一面的值。0<每个面上的值<=x	
题目输出：
	返回2人赢得概率的最小的差值，精确到0.000001
输入样例：
2
4 12
0 2 7 0
6 3 8 10
10 10000
6371 0 6256 1852 0 0 6317 3004 5218 9012
1557 6318 1560 4519 2012 6316 6315 1559 8215 1561
输出样例：
0.125000
0.020000
提示：
None



题目：UrbanElevations (1592)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	An elevation of a collection of buildings is an orthogonal projection of the buildings onto a vertical plane. An external elevation of a city would show the skyline and the faces of the ``visible" buildings of the city as viewed from outside the city from a certain direction. A southern elevation shows no sides; it shows the perfectly rectangular faces of buildings or parts of faces of buildings not obstructed on the south by taller buildings. For this problem, you must write a program that determines which buildings of a city are visible in a southern elevation.	For simplicity, assume all the buildings for the elevation are perfect rectangular solids, each with two sides that run directly east-west and two running directly north-south. Your program will find the buildings that appear in a southern elevation based on knowing the positions and heights of each city building. That data can be illustrated by a map of the city as in the diagram on the left below. The southern elevation for that city is illustrated in the diagram on the right.						(The shadow buildings are visible in a southern elevation)	
题目输入：
	Input for your program consists of the numeric description of maps of several cities. The first line of each map contains the number of buildings in the city (a non-negative integer less than 101). Each subsequent line of a map contains data for a single building - 5 real numbers separated by spaces in the following order:		x-coordinate of the southwest corner		y-coordinate of the southwest corner		width of the building (length of the south side)		depth of the building (length of the west side)		height of the building		Each map is oriented on a rectangular coordinate system so that the positive x-axis points east and the positive y-axis points north. Assume that all input for each map corresponds to a legitimate map (the number of buildings is the same as the number of subsequent lines of input for the map; no two buildings in a single map overlap). Input is terminated by the number 0 representing a map with no buildings.	
题目输出：
	Buildings are numbered according to where their data lines appear in the map's input data - building #1 corresponding to the first line of building data, building #2 data to the next line, and building #n to thenth line of building data for that map. (Buildings on subsequent maps also begin their numbering with 1.)	For each map, output begins with line identifying the map (map #1, map #2, etc.) On the next line the numbers of the visible buildings as they appear in the southern elevation, ordered south-to-north, west-to-east. This means that if building n and building m are visible buildings and if the southwest corner of building nis west of the southwest corner of building m, then number n is printed before number m. If building n and building m have the same x-coordinate for their southwest corners and if building n is south of building m, then the number n is printed before the number m.	For this program, a building is considered visible whenever the part of its southern face that appears in the elevation has strictly positive area. One blank line must separate output from consecutive input records.	
输入样例：
14
160 0 30 60 30
125 0 32 28 60
95 0 27 28 40
70 35 19 55 90
0 0 60 35 80
0 40 29 20 60
35 40 25 45 80
0 67 25 20 50
0 92 90 20 80
95 38 55 12 50
95 60 60 13 30
95 80 45 25 50
165 65 15 15 25
165 85 10 15 35
0
输出样例：
For map #1, the visible buildings are numbered as follows:
5 9 4 3 10 2 1 14
提示：
None



题目：Max(1249)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
有一列数，你找其中的最大值就行了，但数字会发生“随机”改变 ，因而最大值也有可能发生变化。
题目输入：
单case
第一行一个整数n(从0开始编号)(4< n < 1000000)
第二行n个整数
第三行一个整数m
之后又m行，每行一个数对“i a”，表示第i个数变成a
题目输出：
对于每一次改变，输出改变后数列的最大值
输入样例：
5
12 23 456 567 3245
5
1 32
3 345
2 3465
0 4246
4 2345
输出样例：
3245
3245
3465
4246
4246
提示：




题目：RaucousRockers(1495)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
You just inherited the rights to N (1 <= N <= 20) previously unreleased songs recorded by the popular group Raucous Rockers. You plan to release a set of M (1 <= M <= 20) compact disks with a selection of these songs. Each disk can hold a maximum of T (1 <= T <= 20) minutes of music, and a song can not overlap from one disk to another. Since you are a classical music fan and have no way to judge the artistic merits of these songs, you decide on the following criteria for making the selection: The songs on the set of disks must appear in the order of the dates that they were written. The total number of songs included will be maximized.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1: Three integers: N, T, and M.  Line 2: N integers that are the lengths of the songs ordered by the date they were written.
题目输出：
A single line with an integer that is the number of songs that will fit on M disks.
输入样例：
4 5 2
4 3 4 2
输出样例：
3
提示：




题目：古剑奇谭之分虫子(1146)
时间限制：1000 ms
空间限制：10000 ms
题目描述：
古剑奇谭里的天气姐“风晴雪”很喜欢收集小虫子，百里屠苏知道之后，每天偷偷地给晴雪送一只虫子，晴雪玩的了此不疲，但从不会丢失一只虫子，也不会让它们死掉。每一天，晴雪会用不同的方法把已有的虫子平均分为若干份，比如晴雪有4只虫子的时候，她要分3次，第一次分1份，有4只，第二次分2份，每份2只，第三次分4分，每份1只。n天之后，晴雪数不清自己那么一共分了多少次虫子，便去请教饱肚诗书的方兰生。兰生很囧，因为他数学不好，于是他向你请教。
题目输入：
每行输入一个整数n，表示晴雪数了n天的虫子(0<n<999999999)。输入以文件未结束。
题目输出：
输出晴雪分虫子次数的奇偶性（除以2的余数）
输入样例：
1
2
5

输出样例：
1
1
0
提示：




题目：ArtificialIntelligence?(1393)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Physics teachers in high school often think that problems given as text are more demanding than pure computations. After all, the pupils have to read and understand the problem first! So they don't state a problem like "U=10V, I=5A, P=?" but rather like "You have an electrical circuit that contains a battery with a voltage of U=10V and a light-bulb. There's an electrical current of I=5A through the bulb. Which power is generated in the bulb?". However, half of the pupils just don't pay attention to the text anyway. They just extract from the text what is given: U=10V, I=5A. Then they think: "Which formulae do I know? Ah yes, P=U*I. Therefore P=10V*5A=500W. Finished." OK, this doesn't always work, so these pupils are usually not the top scorers in physics tests. But at least this simple algorithm is usually good enough to pass the class. (Sad but true.) Today we will check if a computer can pass a high school physics test. We will concentrate on the P-U-I type problems first. That means, problems in which two of power, voltage and current are given and the third is wanted. 
Your job is to write a program that reads such a text problem and solves it according to the simple algorithm given above. 
题目输入：
The first line of the input file will contain the number of test cases.
Each test case will consist of one line containing exactly two data fields and some additional arbitrary words. A data field will be of the form I=xA, U=xV or P=xW, where x is a real number. Directly before the unit (A,V or W) one of the prefixes m (milli), k (kilo) and M (Mega) may also occur. To summarize it: Data fields adhere to the following grammar:

DataField ::= Concept '=' RealNumber [Prefix] Unit
Concept   ::= 'P' | 'U' | 'I'
Prefix    ::= 'm' | 'k' | 'M'
Unit      ::= 'W' | 'V' | 'A'

Additional assertions:

    * The equal sign ('=') will never occur in an other context than within a data field.
    * There is no whitespace (tabs,blanks) inside a data field.
    * Either P and U, P and I, or U and I will be given. 
题目输出：
For each test case, print three lines:

    * a line saying "Problem #k" where k is the number of the test case
    * a line giving the solution (voltage, power or current, dependent on what was given), written without a prefix and with two decimal places as shown in the sample output
    * a blank line 
输入样例：
3
If the voltage is U=200V and the current is I=4.5A, which power is generated?
A light-bulb yields P=100W and the voltage is U=220V. Compute the current, please.
bla bla bla lightning strike I=2A bla bla bla P=2.5MW bla bla voltage?

输出样例：
Problem #1
P=900.00W

Problem #2
I=0.45A

Problem #3
U=1250000.00V

提示：




题目：TaoxiangNumber(1046)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Taoxiang is an ACMer in NJUST. He wants his name remembered in ACM team forever. One boring day, when he was writing some prime numbers on the blackboard, suddenly an amazing mind came up to his head. Given an integer N (2< N <=45), there are always several prime numbers which are not larger than N. So is there an integer S which can always obey the formula: S mod P= [sqrt (P)]? (P is all the prime numbers less than N; [Q] means the largest integer which is not larger than Q). If S exists, than Taoxiang will name this number: Taoxiang number!

For example, if N=5, than the prime numbers not larger than 5 are 2, 3, 5. And the Taoxiang number of 5 will be 7.because 7%2=1, 7%3=1, 7%5=2. Taoxiang is so excited about this discovery, but he is puzzling how to find this number. Since you are kind enough, now, it’s your time to help him.

题目输入：
The input will consist of several cases. In each case, just input one integer N, which means the given number. Pay attention! The integer N will bigger than 2 and not lager than 45
题目输出：
In each case, just output the Taoxiang number in a single line. If there are several numbers which can obey the formula, only the smallest one will be Taoxiang number.
If Taoxiang number doesn’t exist, just output “Impossible!”

输入样例：
5
输出样例：
7
提示：




题目：Borrowers(1593)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	I mean your borrowers of books - those mutilators of collections, spoilers of the symmetry of shelves, and creators of odd volumes.			- (Charles Lamb, Essays of Elia (1823) `The Two Races of Men')		Like Mr. Lamb, librarians have their problems with borrowers too. People don't put books back where they should. Instead, returned books are kept at the main desk until a librarian is free to replace them in the right places on the shelves. Even for librarians, putting the right book in the right place can be very time-consuming. But since many libraries are now computerized, you can write a program to help.		When a borrower takes out or returns a book, the computer keeps a record of the title. Periodically, the librarians will ask your program for a list of books that have been returned so the books can be returned to their correct places on the shelves. Before they are returned to the shelves, the returned books are sorted by author and then title using the ASCII collating sequence. Your program should output the list of returned books in the same order as they should appear on the shelves. For each book, your program should tell the librarian which book (including those previously shelved) is already on the shelf before which the returned book should go.
题目输入：
			First, the stock of the library will be listed, one book per line, in no particular order. Initially, they are all on the shelves. No two books have the same title. The format of each line will be:				``title" by author				The end of the stock listing will be marked by a line containing only the word:				END				Following the stock list will be a series of records of books borrowed and returned, and requests from librarians for assistance in restocking the shelves. Each record will appear on a single line, in one of the following formats:				BORROW ``title"				RETURN ``title"				SHELVE				The list will be terminated by a line containing only the word:				END		
题目输出：
	Each time the SHELVE command appears, your program should output a series of instructions for the librarian, one per line, in the format:	Put ``  " after ``  "	or, for the special case of the book being the first in the collection:	Put ``title" first	After the set of instructions for each SHELVE, output a line containing only the word:	END			Assumptions & Limitations:	1. A title is at most 80 characters long.	2. An author is at most 80 characters long.	3. A title will not contain the double quote (") character.
输入样例：
"The Canterbury Tales" by Chaucer, G.
"Algorithms" by Sedgewick, R.
"The C Programming Language" by Kernighan, B. and Ritchie, D.
END
BORROW "Algorithms"
BORROW "The C Programming Language"
RETURN "Algorithms"
RETURN "The C Programming Language"
SHELVE
END
输出样例：
Put "The C Programming Language" after "The Canterbury Tales"
Put "Algorithms" after "The C Programming Language"
END
提示：
None



题目：三角形(1809)
时间限制：2000/1000 MS (Java/Others)
空间限制：65536/32768 K (Java/Others)
题目描述：
如果凸N变形的任何三条对角线在形内都不共点，请问它的边和对角线一共可以构成多少个三角形？
题目输入：
题目包含多组输入数据,对于每一组仅一个整数N（<=100）。
题目输出：
一个整数，即一共可以构成多少个三角形
输入样例：
3
4
5
输出样例：
1
8
35
提示：




题目：种地(1695)
时间限制：2000MS
空间限制：65535KB
题目描述：
Fishead退休回家后，为了发财致富，打起了种地的注意。他承包了一块n*m大小的地，可以看做一个网格，每个格子用一个字母表示它的土壤特性。Fishhead买了些很赚钱的农作物的种子，这些种子需要x*y大小的地去种。但是由于农作物很精贵，对土地要求很高。所以鱼头想知道他有多少种不同的方法来种这些农作物。由于这是些精贵的农作物，答案不会超过1000。
题目输入：
第一行是Case数对于每个case第一行是4个整数，n，m，x，y。0<x<=n<=1000  0<y<=m<=1000下面n行每行m个小写字母表示土壤特性。下面x行每行y个小写字母表示农作物需要的土壤特性。
题目输出：
返回方法数
输入样例：
2
2 2 2 2
aa
aa
aa
aa
2 3 2 2
aaa
aba
aa
ba
输出样例：
1
1

提示：
None



题目：Marmots’Transfer(1250)
时间限制：30000 ms
空间限制：524287 ms
题目描述：
There are many marmots live on the grasslands and they build many holes under the ground. There are N*N holes and they are arranged in a square, there may be an UNDIRECTED path between two adjacent holes. All those marmots are living in the northwest hole, now the rainy season coming and they have to transfer to the southeast hole, because it is the highest.Unfortunately, there is a bug in this underground system;these paths are unsubstantial, so that if too many marmots pass one path the path will be destroyed. We call the max marmots can pass a path as p-value. Now give you the p-value of each path, white a program to calculate how many marmots can transfer to the safe place.

题目输入：
There are multiply test cases, end by EOF. Each test cases begin with an integer N (2<=N<=2000), means there are N*N holes, then 2*N-1 lines next, the odd line has N-1 integers describe the west-east path; the even line has N integers describe the north-south path. Each integer is no more than 2000 and no less than 0; describe the corresponding p-value of each path, 0 means there is no way between the two holes.
题目输出：
One integer for each case: the number of marmots can transfer to the safe place.
输入样例：
3
2 2
9 0 2
4 0
4 3 2
3 5
4
0 1 2
3 4 5 6
7 8 9
10 1 2 3
4 5 6
7 8 9 0
1 2 0
输出样例：
7
0

提示：




题目：Falsediamond(1147)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
NewFarKing has bought N diamonds for NewFarQueen.Because NewFarQueen was always tricky ,  NewFarQueen  doubted  one diamond was false.
The  false diamond differs in weight from other diamonds (while all other diamonds are equal in weight). 
NewFarQueen is very poor. She has only a simple balance available . Using this balance, one is able to determine if the weight of objects in the left pan is less than, greater than, or equal to the weight of objects in the right pan. 
In order to detect the false diamond NewFarQueen numbered all diamonds by the integers from 1 to N, thus assigning each diamond a unique integer identifier. After that they began to weight various groups of diamonds by placing equal numbers of diamonds in the left pan and in the right pan. The identifiers of diamonds and the results of the weightings were carefully recorded. 
You are to write a program that will help NewFarQueen to determine the identifier of the false diamond using the results of these weightings.
题目输入：
The first line of the input file contains one integer T, where T is the number of cases.
The second line of the input file contains two integers N and K, separated by spaces, where N is the number of diamonds ( 2 <= N <= 1000 ) and K is the number of weightings fulfilled ( 1 <= K <= 100). The following 2K lines describe all weightings. Two consecutive lines describe each weighting. The first of them starts with a number Pi ( 1 <= Pi <= N/2), representing the number of diamonds placed in the left and in the right pans, followed by Pi identifiers of diamonds placed in the left pan and Pi identifiers of diamonds placed in the right pan. All numbers are separated by spaces. The second line contains one of the following characters: '', or '='. It represents the result of the weighting: 
'' means that the weight of diamonds in the left pan is greater than the weight of diamonds in the right pan, 
'=' means that the weight of diamonds in the left pan is equal to the weight of diamonds in the right pan. 

题目输出：
Write to the output file the identifier of the false diamond or 0, if it cannot be found by the results of the given weightings.
输入样例：
1
5 3
2 1 2 3 4
<
1 1 4
=
1 2 5
=

输出样例：
3

提示：




题目：BeefMcNuggets(1496)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer Brown's cows are up in arms, having heard that McDonalds is considering the introduction of a new product: Beef McNuggets. The cows are trying to find any possible way to put such a product in a negative light. One strategy the cows are pursuing is that of `inferior packaging'. ``Look,'' say the cows, ``if you have Beef McNuggets in boxes of 3, 6, and 10, you can not satisfy a customer who wants 1, 2, 4, 5, 7, 8, 11, 14, or 17 McNuggets. Bad packaging: bad product.'' Help the cows. Given N (the number of packaging options, 1 <= N <= 10), and a set of N positive integers (1 <= i <= 256) that represent the number of nuggets in the various packages, output the largest number of nuggets that can not be purchased by buying nuggets in the given sizes. Print 0 if all possible purchases can be made or if there is no bound to the largest number. The largest impossible number (if it exists) will be no larger than 2,000,000,000.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  N, the number of packaging options Line 2..N+1:  The number of nuggets in one kind of box
题目输出：
The output file should contain a single line containing a single integer that represents the largest number of nuggets that can not be represented or 0 if all possible purchases can be made or if there is no bound to the largest number.
输入样例：
3
3
6
10
输出样例：
17
提示：




题目：距离的平方(1810)
时间限制：1000 ms
空间限制：128 MB
题目描述：
这是一道灰常简单的题目～我们给出平面上两个点，求出他们距离的平方。
题目输入：
一个整数T，表示有T组case。
接下来，每行都有4个正整数 x1 y1 x2 y2，表示（x1，y1）和（x2，y2）这两个点。
所有正整数不超过1000。
题目输出：
输出这两个点距离的平方。
输入样例：
2
1 1 0 0
0 0 0 0
输出样例：
2
0
提示：




题目：TestingtheCATCHER(1594)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	A military contractor for the Department of Defense has just completed a series of preliminary tests for a new defensive missile called the CATCHER which is capable of intercepting multiple incoming offensive missiles. The CATCHER is supposed to be a remarkable defensive missile. It can move forward, laterally, and downward at very fast speeds, and it can intercept an offensive missile without being damaged. But it does have one major flaw. Although it can be fired to reach any initial elevation, it has no power to move higher than the last missile that it has intercepted.		The tests which the contractor completed were computer simulations of battlefield and hostile attack conditions. Since they were only preliminary, the simulations tested only the CATCHER's vertical movement capability. In each simulation, the CATCHER was fired at a sequence of offensive missiles which were incoming at fixed time intervals. The only information available to the CATCHER for each incoming missile was its height at the point it could be intercepted and where it appeared in the sequence of missiles. Each incoming missile for a test run is represented in the sequence only once.		The result of each test is reported as the sequence of incoming missiles and the total number of those missiles that are intercepted by the CATCHER in that test.		The General Accounting Office wants to be sure that the simulation test results submitted by the military contractor are attainable, given the constraints of the CATCHER. You must write a program that takes input data representing the pattern of incoming missiles for several different tests and outputs the maximum numbers of missiles that the CATCHER can intercept for those tests. For any incoming missile in a test, the CATCHER is able to intercept it if and only if it satisfies one of these two conditions:						The incoming missile is the first missile to be intercepted in this test.				-or-								The missile was fired after the last missile that was intercepted and it is not higher than the last missile which was intercepted.	
题目输入：
The input data for any test consists of a sequence of one or more non-negative integers, all of which are less than or equal to 32,767, representing the heights of the incoming missiles (the test pattern). The last number in each sequence is -1, which signifies the end of data for that particular test and is not considered to represent a missile height. The end of data for the entire input is the number -1 as the first value in a test; it is not considered to be a separate test.
题目输出：
	Output for each test consists of a test number (Test #1, Test #2, etc.) and the maximum number of incoming missiles that the CATCHER could possibly intercept for the test. That maximum number appears after an identifying message. There must be at least one blank line between output for successive data sets.			Note: The number of missiles for any given test is not limited. If your solution is based on an inefficient algorithm, it may not execute in the allotted time.
输入样例：
389
207
155
300
299
170
158
65
-1
23
34
21
-1
-1
输出样例：
Test #1:
  maximum possible interceptions: 6

Test #2:
  maximum possible interceptions: 2
提示：
None



题目：BalancingBankAccounts(1394)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Once upon a time there was a large team coming home from the ACM World Finals. The fifteen travellers were confronted with a big problem: In the previous weeks, there had been many money transactions between them: Sometimes somebody paid the entrance fees of a theme park for the others, somebody else paid the hotel room, another one the rental car, and so on. 
So now the big calculation started. Some people had paid more than others, thus the individual bank accounts had to be balanced again. "Who has to pay whom how much?", that was the question. 
As such a calculation is a lot of work, we need a program now that will solve this problem next year. 
题目输入：
The input file will contain one or more test cases.
Each test case starts with a line containing two integers: the number of travellers n (2<=n<=20) and the number of transactions t (1<=t<=1000). On the next n lines the names of the travellers are given, one per line. The names only consist of alphabetic characters and contain no whitespace. On the following t lines, the transactions are given in the format name1 name2 amount where name1 is the person who gave amount dollars to name2. The amount will always be a non-negative integer less than 10000.
Input will be terminated by two values of 0 for n and t. 
题目输出：
For each test case, first print a line saying "Case #i" where i is the number of the test case.
Then, on the following lines, print a list of transactions that reverses the transactions given in the input, i.e. balances the accounts again. Use the same format as in the input. Print a blank line after each test case, even after the last one.

Additional restrictions:

    * Your solution must consist of at most n-1 transactions.
    * Amounts may not be negative, i.e. never output "A B -20", output "B A 20" instead. 

If there is more than one solution satisfying these restrictions, anyone is fine. 
输入样例：
2 1
Donald
Dagobert
Donald Dagobert 15
4 4
John
Mary
Cindy
Arnold 
John Mary 100
John Cindy 200
Cindy Mary 40
Cindy Arnold 150
0 0

输出样例：
Case #1
Dagobert Donald 15

Case #2
Mary John 140
Cindy John 10
Arnold John 150

提示：




题目：无聊的函数(1047)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
定义：无聊的函数F是定义在欧拉函数Euler（k）上的一个函数， F(i, j) =Π Euler(x)(i<=x<=j)。
题目输入：
多case，文件尾结束。每行输入2个数i，j(1 < i  <= j < 100000)。
题目输出：
每个case输出一行，即F(i, j)mod99991的值。
输入样例：
4 7
输出样例：
96
提示：
None



题目：煮鱼(1696)
时间限制：2000MS
空间限制：65535KB
题目描述：
Fishead非常喜欢吃鱼，这个大家都知道。有天他买了很多很多的鱼回来，鱼有m条，想煮着吃。鱼头家的锅都是长条形的，专门煮鱼吃的。由于他家里只有n个锅，并且每个锅形状都不太一样，所以一些锅只能煮某些形状的鱼，并且同时一个锅只能煮一条鱼，规则下面描述。由于鱼头非常的想吃鱼，所以他想知道他同时能煮多少条鱼为了简化问题，把每个锅和每条鱼都看做一个len*1的矩形，矩形的每格上是个int。只有锅和鱼的编辑距离不大于2，这个锅才能煮这条鱼。
题目输入：
第一行是Case数对于每个case第一行是2个整数，n，m。1<=n<=200  1<=m<=500下面n行每行一个整数len(1<=len<=1000)，表示锅的长度，接下来len个int 下面m行每行一个整数len(1<=len<=1000)，表示鱼的长度，接下来len个int
题目输出：
返回最多同时能煮多少条鱼
输入样例：
2
2 2
1 10 
1 11 
3 11 10 11 
3 11 10 11 
2 2
1 10 
1 11 
3 11 10 9 
3 8 7 6 

输出样例：
2
1

提示：
编辑距离：是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。 
例如将kitten一字转成sitting：
sitten（k→s）
sittin（e→i）
sitting（→g）



题目：zlly长了一张包子脸(1251)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
zlly长了一张包子脸，他特别喜欢吃糖果，现在他手头有若干种糖果，每种糖果有个口味值，每种糖果有无数多个。然后娄童鞋也非常喜欢吃糖果，他的口味特别广泛，他喜欢各种各样的口味值，他要求zlly用现有的口味值拼出新的口味值。现在，娄童鞋想知道他不能吃到的口味值最大是多少？你能帮他的忙吗？举个例子，现在zlly手头有3,6,10三种糖果，他拼不出口味值为1、2、4、5、7…17的糖果，所以结果就是17。另外，糖果种类数<=10，每种糖果的口味值<=265，可以保证最大的结果不超过2,000,000,000。如果都可以拼出或最大值不存在，输出0。
题目输入：
Line 1：糖果的数目n
Line 2..n+1:各种糖果的口味值;
输入文件有多case
题目输出：
最大拼不出的口味数
输入样例：
3
3
6
10
输出样例：
17
提示：




题目：ATestinLove(1148)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
NewFarKing, a little boy in acm team, fell in love with NewFarQueen. So he bought up a proposal of marriage to Queen’s father. Queen’s father is a clever elder, of course he didn’t want to merry her girl to a silly boy and he set a test to King, the test is as follow:
Queen’s father develops a simple encoding scheme that encodes particular types of words with ten or fewer (lower case) letters as integers. 
Consider the English alphabet {a,b,c,...,z}. Using this alphabet, a set of valid words are to be formed that are in a strict lexicographic order. In this set of valid words, the successive letters of a word are in a strictly ascending order; that is, later letters in a valid word are always after previous letters with respect to their positions in the alphabet list {a,b,c,...,z}. For example, “abc” “ aep” “ gwz “are all valid three-letter words, whereas “aab”  ” are”  “ cat “are not.
For each valid word associate an integer which gives the position of the word in the alphabetized list of words. That is: a -> 1         b -> 2      z -> 26      ab -> 27      ac -> 28   
az -> 51       bc -> 52    lv -> 256       vwxyz -> 83681
Now, Queen’s father will told the word to King, and King should answer the number immediately to show he is very clever. If  the word is not in ascending order ,King should answer 0. Unfortunately King is not that clever, so he need you make a program to help him.
题目输入：
The input consists of a series of single words, one per line. The words are at least one letter long and no more that ten letters. Only the lower case alphabetic {a,b,...,z} characters will be used as input. 
题目输出：
The output is a single integer, greater than or equal to zero (0) and less than or equal 999999999. There is one line of output for each input line.
输入样例：
newfarking
love
lv
you

输出样例：
0
0
256
0

提示：




题目：FenceRails(1497)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer John is trying to erect a fence around part of his field. He has decided on the shape of the fence and has even already installed the posts, but he's having a problem with the rails. The local lumber store has dropped off boards of varying lengths; Farmer John must create as many of the rails he needs from the supplied boards. Of course, Farmer John can cut the boards, so a 9 foot board can be cut into a 5 foot rail and a 4 foot rail (or three 3 foot rails, etc.). Farmer John has an `ideal saw', so ignore the `kerf' (distance lost during sawing); presume that perfect cuts can be made. The lengths required for the rails might or might not include duplicates (e.g., a three foot rail and also another three foot rail might both be required). There is no need to manufacture more rails (or more of any kind of rail) than called for the list of required rails.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  N (1 <= N <= 50), the number of boards  Line 2..N+1:  N lines, each containing a single integer that represents the length of one supplied board  Line N+2:  R (1 <= R <= 1023), the number of rails  Line N+3..N+R+1:  R lines, each containing a single integer (1 <= ri <= 128) that represents the length of a single required fence rail
题目输出：
A single integer on a line that is the total number of fence rails that can be cut from the supplied boards. Of course, it might not be possible to cut all the possible rails from the given boards.
输入样例：
4
30
40
50
25
10
15
16
17
18
19
20
21
25
24
30
输出样例：
7
提示：
This is a high dimensionality multiple knapsack problem, so we just have to test the cases. Given that the search space has a high out-degree, we will use depth first search with iterative deepening in order to limit the depth of the tree. However, straight DFSID will be too slow, so some tree-pruning is necessary.



题目：CrosswordAnswers(1595)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	A crossword puzzle consists of a rectangular grid of black and white squares and two lists of definitions (or descriptions).	One list of definitions is for ``words" to be written left to right across white squares in the rows and the other list is for words to be written down white squares in the columns. (A word is a sequence of alphabetic characters.)	To solve a crossword puzzle, one writes the words corresponding to the definitions on the white squares of the grid.		The definitions correspond to the rectangular grid by means of sequential integers on ``eligible" white squares. White squares with black squares immediately to the left or above them are ``eligible." White squares with no squares either immediately to the left or above are also ``eligible." No other squares are numbered. All of the squares on the first row are numbered.	The numbering starts with 1 and continues consecutively across white squares of the first row, then across the eligible white squares of the second row, then across the eligible white squares of the third row and so on across all of the rest of the rows of the puzzle. The picture below illustrates a rectangular crossword puzzle grid with appropriate numbering.				An ``across" word for a definition is written on a sequence of white squares in a row starting on a numbered square that does not follow another white square in the same row.				The sequence of white squares for that word goes across the row of the numbered square, ending immediately before the next black square in the row or in the rightmost square of the row.								A ``down" word for a definition is written on a sequence of white squares in a column starting on a numbered square that does not follow another white square in the same column.				The sequence of white squares for that word goes down the column of the numbered square, ending immediately before the next black square in the column or in the bottom square of the column.				Every white square in a correctly solved puzzle contains a letter.								You must write a program that takes several solved crossword puzzles as input and outputs the lists of across and down words which constitute the solutions.	
题目输入：
	Each puzzle solution in the input starts with a line containing two integers r and c (  and ), where r (the first number) is the number of rows in the puzzle and c (the second number) is the number of columns.	The r rows of input which follow each contain c characters (excluding the end-of-line) which describe the solution. Each of those c characters is an alphabetic character which is part of a word or the character ``*", which indicates a black square.	The end of input is indicated by a line consisting of the single number 0.
题目输出：
	Output for each puzzle consists of an identifier for the puzzle (puzzle #1:, puzzle #2:, etc.) and the list of across words followed by the list of down words. Words in each list must be output one-per-line in increasing order of the number of their corresponding definitions.	The heading for the list of across words is ``Across". The heading for the list of down words is ``Down".	In the case where the lists are empty (all squares in the grid are black), the Across and Down headings should still appear.	Separate output for successive input puzzles by a blank line.
输入样例：
2 2
AT
*O
6 7
AIM*DEN
*ME*ONE
UPON*TO
SO*ERIN
*SA*OR*
IES*DEA
0
输出样例：
puzzle #1:
Across
  1.AT
  3.O
Down
  1.A
  2.TO

puzzle #2:
Across
  1.AIM
  4.DEN
  7.ME
  8.ONE
  9.UPON
 11.TO
 12.SO
 13.ERIN
 15.SA
 17.OR
 18.IES
 19.DEA
Down
  1.A
  2.IMPOSE
  3.MEO
  4.DO
  5.ENTIRE
  6.NEON
  9.US
 10.NE
 14.ROD
 16.AS
 18.I
 20.A
提示：
None



题目：挑卡片(1048)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
训练快要结束了，鱼儿子想考考大家，小孩想的问题一般是比较简单的，但毕竟是鱼头的儿子，问题看似简单，但其实还是要动动脑子的，他搬来一些塑料卡片，每个卡片上有红，蓝两部分，每部分都标有一个数字，这些卡片随意的散落在地上，现在鱼头的儿子让队员们随意挑几张卡片，但有一些要求，挑得的所有卡片的红色部分数字总和S(-1000 <= S<= 1000)与所有卡片的蓝色部分数字总和F(-1000 <= F<= 1000)必须都大于0，而且希望挑得的卡片的红蓝数字总和最大，现在你接受了鱼头儿子的挑战，来解决这个问题！
题目输入：
第一行：一个整数 N(0 < N <= 1000), 代表卡片的数量； 
第 2---N+1行：每行有两个整数 Si和 Fi, 分别代表每个卡片上红蓝两部分的数字。
题目输出：
第一行: 一个整数，在保证S和F非负的情况下的卡片上数字的总和最大值，如果不能保证S和F非负则输出0；
输入样例：
5
-5 7
8 -6
6 -3
2 1
-8 -5

输出样例：
8
提示：




题目：TheSettlersofCatan(1395)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Within Settlers of Catan, the 1995 German game of the year, players attempt to dominate an island by building roads, settlements and cities across its uncharted wilderness. You are employed by a software company that just has decided to develop a computer version of this game, and you are chosen to implement one of the game's special rules: 
When the game ends, the player who built the longest road gains two extra victory points. The problem here is that the players usually build complex road networks and not just one linear path. Therefore, determining the longest road is not trivial (although human players usually see it immediately). 
Compared to the original game, we will solve a simplified problem here: You are given a set of nodes (cities) and a set of edges (road segments) of length 1 connecting the nodes. The longest road is defined as the longest path within the network that doesn't use an edge twice. Nodes may be visited more than once, though. 
Example: The following network contains a road of length 12. o      o--o      o
 \    /    \    /
  o--o      o--o
 /    \    /    \
o      o--o      o--o
           \    /
            o--o

题目输入：
The input file will contain one or more test cases.
The first line of each test case contains two integers: the number of nodes n (2<=n<=25) and the number of edges m (1<=m<=25). The next m lines describe the m edges. Each edge is given by the numbers of the two nodes connected by it. Nodes are numbered from 0 to n-1. Edges are undirected. Nodes have degrees of three or less. The network is not neccessarily connected.
Input will be terminated by two values of 0 for n and m. 
题目输出：
For each test case, print the length of the longest road on a single line. 
输入样例：
3 2
0 1
1 2
15 16
0 2
1 2
2 3
3 4
3 5
4 6
5 7
6 8
7 8
7 9
8 10
9 11
10 12
11 12
10 13
12 14
0 0

输出样例：
2
12

提示：




题目：一道水题(1811)
时间限制：1000 ms
空间限制：65535 KB
题目描述：
王大锤给王小可出一道水题：给出m个数组，每个数组有n个非负数。现在从每个数组里面各选出一个数，相加得到一个和s。可想而知，一共有n^m种结果，但问题的关键是求出最小的n个s。面对这道水题，王小可顿时晕菜了，万能的程序员啊，帮帮他吧。
题目输入：
第一行有一个整数T，代表T组数据，第二行有两个整数m，n（0<m<=100，0<n<=2000），接下来的m行，为m个含有n个元素的数组，数组里面的每个元素都不大于50000000。
题目输出：
输出数据只有一行，包括n个最小的s，并且结果按升序排序，每两个s间由一个空格隔开，输出以回车换行符结束。
输入样例：
1
2 2
1 2
3 2
输出样例：
3 4
提示：
样例中m=2，n=2，所以有2个含有2个元素的数组 1 2 和 3 2，分别从这两个数组中各选出一个数 1 和 3，然后得到一个s=1+3，很容易地也得到剩下的s=1+2，s=2+3，s=2+2，然后从中选出最小的2个输出，即 3 4。



题目：取石子游戏(1149)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
2        Newfarking 和他的心上人Newfarqueen玩游戏，现有n（0 < n <= 10000）堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏的规则如下：
Ø       每一步应取走至少一枚石子；
Ø       每一步只能从某一堆中取走部分或全部石子；
Ø       如果谁无法按规则取子，谁就是输家。
现在给出初始的任意堆石子的数目，如果轮到Newfarking 先取，假设双方都采取最好的策略，问最后你Newfarking是胜者还是败者。
题目输入：
输入包含若干行，其中第一行是游戏的次数K，接下来的K行，第一个数据是石子的堆数n，其后的n个数据是每堆石子的个数（毎堆石子不多于10个）。
题目输出：
对于每次游戏，如果Newfarking是胜者，则输出“Newfarking is a man”，否则输出“Newfarking is not a man”。
输入样例：
3
2 2 2
2 4 7
5 9 2 3 5 8

输出样例：
Newfarking is not a man
Newfarking is a man
Newfarking is a man

提示：




题目：FenceLoops(1498)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The fences that surround Farmer Brown's collection of pastures have gotten out of control. They are made up of straight segments from 1 through 200 feet long that join together only at their endpoints though sometimes more than two fences join together at a given endpoint. The result is a web of fences enclosing his pastures. Farmer Brown wants to start to straighten things out. In particular, he wants to know which of the pastures has the smallest perimeter. Farmer Brown has numbered his fence segments from 1 to N (N = the total number of segments). He knows the following about each fence segment: the length of the segment the segments which connect to it at one end the segments which connect to it at the other end. Happily, no fence connects to itself. Given a list of fence segments that represents a set of surrounded pastures, write a program to compute the smallest perimeter of any pasture. As an example, consider a pasture arrangement, with fences numbered 1 to 10 that looks like this one (the numbers are fence ID numbers):            1   +---------------+   |             /|  2| 7          / |   |           /  |   +---+       /   |6   | 8       /10  |  3|     9  /     |   |       /      |   +-------+-------+       4       5The pasture with the smallest perimeter is the one that is enclosed by fence segments 2, 7, and 8.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  N (1 <= N <= 100) Line 2..3*N+1:  N sets of three line records: The first line of each record contains four integers: s, the segment number (1 <= s <= N); Ls, the length of the segment (1 <= Ls <= 255); N1s (1 <= N1s <= 8) the number of items on the subsequent line; and N2sthe number of items on the line after that (1 <= N2s <= 8). The second line of the record contains N1 integers, each representing a connected line segment on one end of the fence. The third line of the record contains N2 integers, each representing a connected line segment on the other end of the fence.
题目输出：
The output file should contain a single line with a single integer that represents the shortest surrounded perimeter.
输入样例：
10
1 16 2 2
2 7
10 6
2 3 2 2
1 7
8 3
3 3 2 1
8 2
4
4 8 1 3
3
9 10 5
5 8 3 1
9 10 4
6
6 6 1 2 
5 
1 10
7 5 2 2 
1 2
8 9
8 4 2 2
2 3
7 9
9 5 2 3
7 8
4 5 10
10 10 2 3
1 6
4 9 5
输出样例：
12
提示：




题目：雇佣工人(1697)
时间限制：1000MS
空间限制：65535KB
题目描述：
	20年后，fishhead退休回家做了一个土财主，他想盖一栋超级大的房子来显示他的富有。	盖房子是个大工程，fishhead预计这个工程需要T个单位的工作量。现在有n个工人可以共选择。现在已知每个工人每小时能完成a[i]个单位的工作，他们每完成一个单位的工作酬劳是p[i]。现在fishhead想雇佣恰好k个工人帮忙盖房子。为了不让雇佣的工人闲着，现已知每个工人都是从开始一直工作到房子盖完成，即他们的工作时间是一样的。	问题是fishhead还要租用1个搅拌机来搅拌水泥，租金是每秒k元。	鱼头想知道最少花多少钱才能盖起这栋房子。
题目输入：
	第一行是Case数	对于每个case	每组case之间有空行	第一行是3个整数，n，k，T。0<k<=n<=60  0<=T<=100000	下面n行每行2个整数	a[i],p[i]  0<a[i],p[i]<=100000
题目输出：
	返回最小花费，精确到0.01
输入样例：
2

2 1 100
50 1000
60 2000

10 4 1000
1 20
2 30
3 40
4 58
5 60
6 70
7 80
8 90
9 100
10 150
输出样例：
107200.00
531764.71
提示：

	所有的时间都可以是小数，对于的价格也按比例付。比如租用0.5秒的搅拌机，租金是0.5k元。




题目：仙剑奇侠传五-------百年重逢(1252)
时间限制：2000 ms
空间限制：65535 ms
题目描述：

自从神魔之井被封，人魔相隔，永世不得相见。但，百余年后，神魔之井再次出现神魔之隙，小蛮和龙幽终于有了见面的机会。小蛮找到看守神魔之井的姜云凡，询问进入魔界之法，可惜小凡对此也只是略知。
神魔之井有一道封印，只要解除了这道封印便可进入魔界。神魔之井有N个站点，每个站点均可进入魔界，只需使用咒语解除封印。小凡不知咒语具体散落在哪个站点，只知一个大致的范围，他提供给小蛮一个区间[L,R],表示站点编号为L~R的站点中的某个有此咒语。
关于神魔之井的连接方式： 神魔之井的路都是由气流所构成，它的路和一般静态的路有所不同。小蛮可以从N点中任选一个站点降落，称这个站点为基地。则其余任意每个点均和基地形成一条路，除了这些路，站点中没有其他的路。

神魔之井中有很多鬼怪，每个站点写有一个数Ci，两个站点路径上的鬼怪数目恰好是两点的数之差（绝对值）。仙剑的刷怪频率是很低的，为简单起见，这里我们假设不刷怪。
当然小蛮想尽快见到龙幽，当她得知了区间[L,R]后，她应该选择哪个点降落，使得最坏情况下找到咒语遇到的鬼怪最少，输出遇到的最少鬼怪数。
题目输入：
第一行一个整数T，表示case数
每个case第一行一个整数N，表示站点的数目（N<=100000）
接下来N个整数，表示每个站点上写的数 （0~1000）

一个整数Q，表示Q次询问（Q<=100000）
接下来Q行，每行两个整数L,R  (1<=L<=R<=N),表示云凡知道的区间
题目输出：
小蛮在最坏情况下找到咒语所需遇到的最少鬼怪数。
输入样例：
1
5
1  2  3  4  5
3
1   5
2   4
3   3
输出样例：
6
2
0

提示：




题目：Jill'sBike(1596)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	Jill Bates hates climbing hills. Jill rides a bicycle everywhere she goes, but she always wants to go the easiest and shortest way possible. The good news is that she lives in Greenhills, which has all its roads laid out in a strictly rectangular grid - east-west roads are streets; north-south roads are avenues and the distance between any two adjacent grid points is the same. The bad news is that Greenhills is very hilly and has many one-way roads.		In choosing a route between where she starts and where she ends, Jill has three rules:			Avoid any travel of more than 10 meters between adjacent grid points.				Never go the wrong way on a one-way road.				Always travel the shortest possible route.		Your program should help Jill find an acceptable route.
题目输入：
	The input file contains less than 50 data sets in the following form:				The first line of each set contains two integers, separated by one or more spaces. The first integer nrepresents the number of streets, and the second integer m represents the number of avenues, ,  .				The next n lines contain the altitudes of grid points. Each line represents a street and contains a sequence of m integers separated by one or more spaces. These integers represent the altitude in meters of the grid points along that street. Even if a particular street and avenue have no intersection, the altitude is still given for that grid point.				One or more lines follow that define the one-way roads. Each road is represented by two pairs of integers, separated by one or more spaces, in the form:					street avenue street avenue 							The first street and avenue define the starting point of the road and the second pair define the ending point. Since Greenhills is a strict grid, if the two points are not adjacent in the grid, the road passes through all the intervening grid points. For example,							5 7 5 10 							represents roads 5-7 to 5-8, 5-8 to 5-9, and 5-9 to 5-10. Road definitions are terminated by a line containing four zeroes in the above format.						Finally, one or more lines will follow that contain pairs of grid points between which Jill wants to find an optimal path, in the form:					street avenue street avenue 							As before, the integer pairs are separated by one or more spaces. The end of the input set is defined by a line containing four zeroes, formatted as before.				You may assume that all street and avenue numbers are within the bounds defined by the first line of set, and that all road definitions are strictly north-south or east-west. The end of input file is defined by EOF.
题目输出：
For each path query in the input file, output a sequence of grid points, from the starting grid point to the ending grid point, which meets Jill's three rules. Output grid points as `street-avenue' separated by the word `to'. If there is more than one path that meets Jill's criteria, any such path will be acceptable. If no route satisfies all the criteria, or if the starting and ending grid points are the same, output an appropriate message to that effect. Output a blank line between each output for query.
输入样例：
3 4 
10 15 20 25 
19 30 35 30 
10 19 26 20 
1 1 1 4 
2 1 2 4 
3 4 3 3 
3 3 1 3 
1 4 3 4 
2 4 2 1 
1 1 2 1 
0 0 0 0 
1 1 2 2 
2 3 2 3 
2 2 1 1 
0 0 0 0
输出样例：
1-1 to 1-2 to 1-3 to 1-4 to 2-4 to 2-3 to 2-2

To get from 2-3 to 2-3, stay put!

There is no acceptable route from 2-2 to 1-1.
提示：

	Diagram of the Sample Input 


	


	 




题目：大胡子的烦恼(1049)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
大胡子是一位非常有激情的旅行家，他经常一个人开着卡车到处跑，但他更喜欢和一群人开着几辆卡车到处跑，于是他创办了卡车联盟。这个联盟经常举办长途卡车旅行，而大胡子则担当队长。
每次旅行，大胡子都要想方设法使所有人的卡车跑的总里程数最且因为景点能停的车位n是有限的，于是他倡议大家能拼车就拼车。当然，一定要确保所有的人都是坐车去的（开车坐车无所谓）。卡车容积不限。
因为每个成员都有辆卡车，且成员家里能停的车位不限，所以他们可以先开车到某个成员家里，再和他同乘一辆车到下一个地点。也可以在家里等人接自己。当然，也可以和其他车辆汇合在某一个地点，在同乘一辆车。请你帮抓狂的大胡子计算一下把所有人送到景点（设景点为Park）所有人的卡车所需要行驶的最小里程。注意：所有的道路都是无向的！且人数小于五十，每个人的住址都不相同.
题目输入：
第一行输入测试数据个数t
下面每一组测试数据中第一行输入n,代表连接各个成员（包括景点）的道路条数。
下面n行中
先输入道路的起点，终点，道路的长度。中间用空格隔开。
最后输入景点能够停车的数目。

题目输出：
最小里程数，一行一个数。
输入样例：
1
10
Zhangke Berk 32
zhangke Park 57
zhangke Eduardo 43
Berk Park 19
Berk Clemenzi 82
Clemenzi Park 65
Clemenzi Herb 90
Clemenzi Eduardo 109
Park Herb 24
Herb Eduardo 79
3

输出样例：
183
提示：




题目：Cryptcowgraphy(1499)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The cows of Farmer Brown and Farmer John are planning a coordinated escape from their respective farms and have devised a method of encryption to protect their written communications. Specifically, if one cow has a message, say, "International Olympiad in Informatics", it is altered by inserting the letters C, O, and W, in random location in the message, such that C appears before O, which appears before W. Then the cows take the part of the message between C and O, and the part between O and W, and swap them. Here are two examples:             International Olympiad in Informatics                              ->             CnOIWternational Olympiad in Informatics                        International Olympiad in Informatics                              ->             International Cin InformaticsOOlympiad WTo make matters more difficult, the cows can apply their encryption scheme several times, by again encrypting the string that results from the previous encryption. One night, Farmer John's cows receive such a multiply-encrypted message. Write a program to compute whether or not the non-encrypted original message could have been the string:             Begin the Escape execution at the Break of Dawn
题目输入：
There are several test cases, end by EOF, for each test case:A single line (with both upper and lower case) with no more than 75 characters that represents the encrypted message.
题目输出：
Two integers on a single line. The first integer is 1 if the message decodes as an escape message; 0 otherwise. The second integer specifies the number of encryptions that were applied (or 0 if the first integer was 0).
输入样例：
Begin the EscCution at the BreOape execWak of Dawn
输出样例：
1 1
提示：




题目：TeamQueue(1396)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Queues and Priority Queues are data structures which are known to most computer scientists. The Team Queue, however, is not so well known, though it occurs often in everyday life. At lunch time the queue in front of the Mensa is a team queue, for example. 
In a team queue each element belongs to a team. If an element enters the queue, it first searches the queue from head to tail to check if some of its teammates (elements of the same team) are already in the queue. If yes, it enters the queue right behind them. If not, it enters the queue at the tail and becomes the new last element (bad luck). Dequeuing is done like in normal queues: elements are processed from head to tail in the order they appear in the team queue. 
Your task is to write a program that simulates such a team queue. 
题目输入：
The input file will contain one or more test cases. Each test case begins with the number of teams t (1<=t<=1000). Then t team descriptions follow, each one consisting of the number of elements belonging to the team and the elements themselves. Elements are integers in the range 0 - 999999. A team may consist of up to 1000 elements.

Finally, a list of commands follows. There are three different kinds of commands:

    * ENQUEUE x - enter element x into the team queue
    * DEQUEUE - process the first element and remove it from the queue
    * STOP - end of test case 

The input will be terminated by a value of 0 for t. 
Warning: A test case may contain up to 200000 (two hundred thousand) commands, so the implementation of the team queue should be efficient: both enqueing and dequeuing of an element should only take constant time. 
题目输出：
For each test case, first print a line saying "Scenario #k", where k is the number of the test case. Then, for each DEQUEUE command, print the element which is dequeued on a single line. Print a blank line after each test case, even after the last one. 
输入样例：
2
3 101 102 103
3 201 202 203
ENQUEUE 101
ENQUEUE 201
ENQUEUE 102
ENQUEUE 202
ENQUEUE 103
ENQUEUE 203
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
STOP
2
5 259001 259002 259003 259004 259005
6 260001 260002 260003 260004 260005 260006
ENQUEUE 259001
ENQUEUE 260001
ENQUEUE 259002
ENQUEUE 259003
ENQUEUE 259004
ENQUEUE 259005
DEQUEUE
DEQUEUE
ENQUEUE 260002
ENQUEUE 260003
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
STOP
0

输出样例：
Scenario #1
101
102
103
201
202
203

Scenario #2
259001
259002
259003
259004
259005
260001

提示：




题目：IntegerRootsofEquations(1150)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Look at this equation: x^2+Ax+B=167y; 0<a,b<=2004. There are several groups of certain As and Bs that can make the equation have integer roots (x,y).
Assume an equation x^2+Ax+B=py; 0<a,b<=p*q. The number p is an odd prime number and is given. The number q is also given. It's easy, for certain, to find a group of A and B, to make the equation have integer roots (x,y). But the question is:How many groups of As and Bs can you find to make the equation have integer roots (x,y)?
题目输入：
The input has n groups of test data. The first line includes an integer n( 0 < n <= 1000 ). Then come n lines, each line contains two integers p( 0 < p <= 10000 ) and q(0 < q <= 10^3).
题目输出：
The output have n lines, each have only an integer showing the number of groups of As and Bs.
输入样例：
1
167 12
输出样例：
2020032
提示：




题目：火车票问题(1698)
时间限制：1000MS
空间限制：65535KB
题目描述：
Fishead的算法可是非常nb的。某天，他被铁道部请去解决一个棘手的问题。总所周知铁道部一向很坑，买票不易。但是铁道部想赚更多的钱。现在有一条很长的铁路，从a向b开，途径n个站台（包含ab）。每个站台都有乘客要买票到下游的另一个站台。不同的乘客买不同的站点间的票价格是不同的（有优惠票），但是火车座位就m个，不可能满足所有的乘客，铁道部想要票的总价钱最多(不是满足的乘客最多哦)，请输出最多多少钱。
题目输入：
	第一行是Case数对于每个case第一行是3个整数，n，m，p。2<=n<=50，1<=m<=50，1<=p<=500接下来p行每行3个数s,t,c，表示某个乘客的起点，终点，和价格。1<=s<t<=n,1<=c<=100	输入case之间有一个空行
题目输出：
返回最多多少钱。
输入样例：
2
5 1 3
1 3 1
3 5 1
2 4 3

5 1 5
1 3 2
3 5 3
1 5 10
1 4 4
4 5 2

输出样例：
3
10

提示：
None



题目：Matrixof0&1(1812)
时间限制：4000 ms
空间限制：256 MB
题目描述：
若存在一个X*X的矩阵，满足矩阵中任意元素都不等于其相邻元素（上下左右四个方向为相邻），我们则认为它是一个优雅的矩阵。
现在有很多个N*M的01矩阵，我们想知道对于每个矩阵，它所包含的最大的优雅矩阵的X值是多少。
题目输入：
多组输入数据
每组数据第一行为两个整数N, M（0 <= N,M <= 3000）
接下来N行表示矩阵中的元素，每行M个数字（0或1）
题目输出：
每组数据输出一行，表示最大的X值
输入样例：
3 3
101
111
101
3 3
010
101
010
5 5
11010
10101
01011
10100
01010
输出样例：
1
3
4
提示：




题目：Spacejump(1253)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
There is a war between Star X and Star Y. As the general of Star X, you need to send your soldiers to Star Y by spaceship. The only way to get there quickly is by doing spacejump through windows built in space (directed). Doing spacejump once costs one unit of source. As the space windows are unstable, there is a factor W, which means no more than W people can pass through the window together. The source for the spaceship is limited, but the number of people carried is unlimited. Since the war has been started for some time, you urge to send more soldiers to Star Y, can you calculate the number of soldiers?
题目输入：
There is a single integer T (0<T<=5) in the first line, indicating the case number.
For each case, there are to integers N (0<N<=200) and M (30000<M<=39800), E (50<E<=100), indicating the number of stars, space windows and the amount of source which a spaceship can carry. Following M lines, each line contains three integers U, V, W, meaning there is a space window between Star U and Star V, and stability factor is W. (Promise that Star X is numbered 1, and Star Y is numbered N, the number of spaceship is unlimited).

题目输出：
For each case, print the number of the most soldiers sent to Star Y.
输入样例：
2

5 7 3
1 2 5
1 3 2
2 3 3
2 4 2
4 3 1
3 5 1
4 5 2

5 7 2
1 2 5
1 3 2
2 3 3
2 4 2
4 3 1
3 5 1
4 5 2

输出样例：
3
1

提示：




题目：Tempusetmobilius.Timeandmotion(1597)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
																																							Unfortunately, most commercially available ball clocks do not incorporate a date indication, although this would be simple to do with the addition of further carry and indicator tracks. However, all is not lost! As the balls migrate through the mechanism of the clock, they change their relative ordering in a predictable way. Careful study of these orderings will therefore yield the time elapsed since the clock had some specific ordering. The length of time which can be measured is limited because the orderings of the balls eventually begin to repeat. Your program must compute the time before repetition, which varies according to the total number of balls present.			Operation of the Ball Clock				Every minute, the least recently used ball is removed from the queue of balls at the bottom of the clock, elevated, then deposited on the minute indicator track, which is able to hold four balls. When a fifth ball rolls on to the minute indicator track, its weight causes the track to tilt. The four balls already on the track run back down to join the queue of balls waiting at the bottom in reverse order of their original addition to the minutes track. The fifth ball, which caused the tilt, rolls on down to the five-minute indicator track. This track holds eleven balls. The twelfth ball carried over from the minutes causes the five-minute track to tilt, returning the eleven balls to the queue, again in reverse order of their addition. The twelfth ball rolls down to the hour indicator. The hour indicator also holds eleven balls, but has one extra fixed ball which is always present so that counting the balls in the hour indicator will yield an hour in the range one to twelve. The twelfth ball carried over from the five-minute indicator causes the hour indicator to tilt, returning the eleven free balls to the queue, in reverse order, before the twelfth ball itself also returns to the queue.	
题目输入：
The input defines a succession of ball clocks. Each clock operates as described above. The clocks differ only in the number of balls present in the queue at one o'clock when all the clocks start. This number is given for each clock, one per line and does not include the fixed ball on the hours indicator. Valid numbers are in the range 27 to 7000. A zero signifies the end of input.
题目输出：
For each clock described in the input, your program should report the number of balls given in the input and the number of days (24-hour periods) which elapse before the clock returns to its initial ordering. Output will always fit in a 64-bit integer.
输入样例：
30
45
0
输出样例：
30 balls cycle after 15 days.
45 balls cycle after 378 days.
提示：
None



题目：Quxiao`sflowers(1050)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Quxiao 和 xiao bai 是南京理工大学ACM集训队的老队员。他们之间的关系想必是世人都知道的。随着日子一天一天的过去，小白就要出国留学了，留给quxiao的机会也不多了 。quxiao想抓住最后的机会给小白送一束鲜花。由于quxiao和xiaobai一起相处多年，quxiao对小白喜欢的鲜花类型了如指掌。我们用一个整数值v来表示xiaobai对鲜花的喜欢程度（v <= 100）。Quxiao来到花店，花店里有n（0< n < 1001）种鲜花。由于小白不喜欢重复的东西，因此每种鲜花只能选一朵。花店的老板又告诉quxiao，有些花放到一起后，两种花香产生化学反应会使人昏迷，因此有些花是不能一起选的。现在quxiao看着眼花缭乱的花很头疼，为了毕其功于一役，他想买尽可能多的花又要使xiaobai的喜欢程度（总的喜欢程度等于每朵花的喜欢程度之和）最高。但是花太多了，你能编一个程序帮quxiao吗？
注意：不存在这样n种花：c1，c2，c3……cn，ci与ci+1不能放在一起，且cn与c1不能放在一起。

题目输入：
多组输入数据，每组第一行输入两个整数，n和m，分别表示花的种类和不能放在一起的花的对数。
接下来n行中，第i行输入一个数v，表示xiaobai对第i种花的喜欢程度。再接下来m行，每行输入两个数A和B，表示第A种花和第B种花不能放在一起。

题目输出：
每组输出一个整数占一行，为quxiao所能买到的花的xiaobai所喜欢的程度的总和。
输入样例：
3   1
1
1
1
1 2
输出样例：
2
提示：




题目：lcs(1254)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
This problem seems a little easy. Because the two given sequences p1 p2 are just  permutations of 1~n. So try it and tell me the answer what the length of longest common subsequence is.
题目输入：
There are some cases following.
In each case , containing a positive integer n. 1<=n<=100000. 
Following are two permutations of 1~n.
题目输出：
Output the length of longest common subsequence
输入样例：
5
1 5 3 2 4
5 3 4 2 1
输出样例：
3
提示：




题目：ErrorCorrection(1397)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A boolean matrix has the parity property when each row and each column has an even sum, i.e. contains an even number of bits which are set. Here's a 4 x 4 matrix which has the parity property: 1 0 1 0
0 0 0 0
1 1 1 1
0 1 0 1
The sums of the rows are 2, 0, 4 and 2. The sums of the columns are 2, 2, 2 and 2. 
Your job is to write a program that reads in a matrix and checks if it has the parity property. If not, your program should check if the parity property can be established by changing only one bit. If this is not possible either, the matrix should be classified as corrupt. 
题目输入：
The input file will contain one or more test cases. The first line of each test case contains one integer n (n<100), representing the size of the matrix. On the next n lines, there will be n integers per line. No other integers than 0 and 1 will occur in the matrix. Input will be terminated by a value of 0 for n. 
题目输出：
For each matrix in the input file, print one line. If the matrix already has the parity property, print "OK". If the parity property can be established by changing one bit, print "Change bit (i,j)" where i is the row and j the column of the bit to be changed. Otherwise, print "Corrupt". 
输入样例：
4
1 0 1 0
0 0 0 0
1 1 1 1
0 1 0 1
4
1 0 1 0
0 0 1 0
1 1 1 1
0 1 0 1
4
1 0 1 0
0 1 1 0
1 1 1 1
0 1 0 1
0

输出样例：
OK
Change bit (2,3)
Corrupt

提示：




题目：VariableRadixHuffmanEncoding(1598)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	Huffman encoding is a method of developing an optimal encoding of the symbols in a source alphabet using symbols from a target alphabet when the frequencies of each of the symbols in the source alphabet are known. Optimal means the average length of an encoded message will be minimized. In this problem you are to determine an encoding of the first N uppercase letters (the source alphabet,  through  , with frequencies  through  ) into the first R decimal digits (the target alphabet,  through  ).		Consider determining the encoding when R=2. Encoding proceeds in several passes. In each pass the two source symbols with the lowest frequencies, say  and  , are grouped to form a new ``combination letter" whose frequency is the sum of  and  . If there is a tie for the lowest or second lowest frequency, the letter occurring earlier in the alphabet is selected. After some number of passes only two letters remain to be combined. The letters combined in each pass are assigned one of the symbols from the target alphabet.		The letter with the lower frequency is assigned the code 0, and the other letter is assigned the code 1. (If each letter in a combined group has the same frequency, then 0 is assigned to the one earliest in the alphabet. For the purpose of comparisons, the value of a ``combination letter" is the value of the earliest letter in the combination.) The final code sequence for a source symbol is formed by concatenating the target alphabet symbols assigned as each combination letter using the source symbol is formed.	The target symbols are concatenated in the reverse order that they are assigned so that the first symbol in the final code sequence is the last target symbol assigned to a combination letter.		The two illustrations below demonstrate the process for R=2.				When R is larger than 2, R symbols are grouped in each pass. Since each pass effectively replaces R letters or combination letters by 1 combination letter, and the last pass must combine R letters or combination letters, the source alphabet must contain k*(R-1)+R letters, for some integer k.	Since N may not be this large, an appropriate number of fictitious letters with zero frequencies must be included. These fictitious letters are not to be included in the output. In making comparisons, the fictitious letters are later than any of the letters in the alphabet.		Now the basic process of determining the Huffman encoding is the same as for the R=2 case. In each pass, theR letters with the lowest frequencies are grouped, forming a new combination letter with a frequency equal to the sum of the letters included in the group. The letters that were grouped are assigned the target alphabet symbols 0 through R-1. 0 is assigned to the letter in the combination with the lowest frequency, 1 to the next lowest frequency, and so forth. If several of the letters in the group have the same frequency, the one earliest in the alphabet is assigned the smaller target symbol, and so forth.		The illustration below demonstrates the process for R=3.		
题目输入：
	The input will contain one or more data sets, one per line. Each data set consists of an integer value for R(between 2 and 10), an integer value for N (between 2 and 26), and the integer frequencies  through  , each of which is between 1 and 999.	The end of data for the entire input is the number 0 for R; it is not considered to be a separate data set.
题目输出：
For each data set, display its number (numbering is sequential starting with 1) and the average target symbol length (rounded to two decimal places) on one line. Then display the N letters of the source alphabet and the corresponding Huffman codes, one letter and code per line. Print a blank line after each test case. The examples below illustrate the required output format.
输入样例：
2 5 5 10 20 25 40
2 5 4 2 2 1 1
3 7 20 5 8 5 12 6 9
4 6 10 23 18 25 9 12
0
输出样例：
Set 1; average length 2.10
    A: 1100
    B: 1101
    C: 111
    D: 10
    E: 0

Set 2; average length 2.20
    A: 11
    B: 00
    C: 01
    D: 100
    E: 101

Set 3; average length 1.69
    A: 1
    B: 00
    C: 20
    D: 01
    E: 22
    F: 02
    G: 21

Set 4; average length 1.32
    A: 32
    B: 1
    C: 0
    D: 2
    E: 31
    F: 33
提示：
None



题目：英雄无敌(1699)
时间限制：6000MS
空间限制：65535KB
题目描述：
	英雄无敌是个很经典的游戏。Snow一直很好奇他的自动战斗功能是怎么实现的。	将问题简单化，现在规定	双方如果发生自动战斗，那么双方的士兵数是一样的。	A先手和b先手的概率都是0.5，之后轮流出手。	每次出手，随机的选取己方的一名士兵，随机攻击对方一名士兵，有一定概率杀死，否则攻击无效（即不会造成对方伤亡）。	请输出双方各自赢得比赛的概率。
题目输入：
	第一行是Case数	对于每个case	第一行是1个整数，0<n<=4，一方的士兵数	下面n行每行n个数,表示a的第i个士兵一次能杀死b的第j个士兵的概率。	下面n行每行n个数,表示b的第i个士兵一次能杀死a的第j个士兵的概率。	 
题目输出：
	返回2人赢得概率,保留6位小数。
输入样例：
1
1
0.5
0.5

输出样例：
0.500000 0.500000
提示：
None



题目：小兵过年(1813)
时间限制：4000 ms
空间限制：65535 KB
题目描述：
万万没想到，王大锤竟然当上了小队长。眼看快过年了，王大锤想给手下们发点年货。每一个年货都有两种属性一种是开心值h（1<=h<=200000）（年货好差的评定标准，越大越好）和另一种是价钱p（1<=p<=200000）。大锤哥心想：在分年货的时候，手下们一定会让自己先挑，但为了以德服人，决定挑中间的（开心值为中位数的）。所以他在买年货的时候，想让年货的开心值的中位数最大。现在已知王大锤要买N（N是奇数，1<=N<=19999）个年货，商店里年货的个数C（N<=C<=100000）及每种年货的开心值和价钱，和王大锤的预算F（0<=F<2^30）。求王大锤最后得到的年货的开心值的最大值。
题目输入：
第一行有一个整数T，代表T组测试数据。第二行有三个整数N C F，接下来有C行，每一行有两个整数，分别代表年货的开心值和价钱。
题目输出：
输出只有一个整数，王大锤最后得到的年货的开心值的最大值，如果不存在这个数，则输出-1。
输入样例：
1
3 5 70
30 25
50 21
20 20
5 18
35 30
输出样例：
35
提示：
显然，从5种年货中挑出3种，分别为5 18，35 30，50 21。因为18+30+21=69<=70 且中位数35为所有可能中最大的，所以输出35。



题目：DrainageDitches(1500)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Every time it rains on Farmer John's fields, a pond forms over Bessie's favorite clover patch. This means that the clover is covered by water for awhile and takes quite a long time to regrow. Thus, Farmer John has built a set of drainage ditches so that Bessie's clover patch is never covered in water. Instead, the water is drained to a nearby stream. Being an ace engineer, Farmer John has also installed regulators at the beginning of each ditch, so he can control at what rate water flows into that ditch. Farmer John knows not only how many gallons of water each ditch can transport per minute but also the exact layout of the ditches, which feed out of the pond and into each other and stream in a potentially complex network. Note however, that there can be more than one ditch between two intersections. Given all this information, determine the maximum rate at which water can be transported out of the pond and into the stream. For any given ditch, water flows in only one direction, but there might be a way that water can flow in a circle.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  Two space-separated integers, N (0 <= N <= 200) and M (2 <= M <= 200). N is the number of ditches that Farmer John has dug. M is the number of intersections points for those ditches. Intersection 1 is the pond. Intersection point M is the stream.  Line 2..N+1:  Each of N lines contains three integers, Si, Ei, and Ci. Si and Ei (1 <= Si, Ei <= M) designate the intersections between which this ditch flows. Water will flow through this ditch from Si to Ei. Ci (0 <= Ci <= 10,000,000) is the maximum rate at which water will flow through the ditch.
题目输出：
One line with a single integer, the maximum rate at which water may emptied from the pond.
输入样例：
5 4
1 2 40
1 4 20
2 4 20
2 3 30
3 4 10
输出样例：
50
提示：




题目：Newfarkingandlion(1151)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
我们亲爱的newfarking大神非常喜欢旅游，赞了一年的钱，终于在世界杯前夕攒够了钱，如愿以偿的去了非洲旅游，但是在南非，还有一场噩梦在等着他……
相传，这天，我们的farking大神，和往常一样在草原上漫步，突然发现了一只小狮子，由于人品，他决定要好好欺负这只小狮子，就在他准备行凶时，一只硕大无比的母老虎出现了，他于是失去了刚刚勇气，扔了所有东西，拔腿就跑，老虎最喜欢活动的猎物，特别是母老虎，而且遇见farking大神，所以就一直再追，但是farking是神啊，他可以跑的很快，但是不幸的是，他一直在绕着一个圈圈。
设farking神的初始位置为X，老虎初始位置为Y，由于他们体力有限，所以他们每次会跑固定长的时间t，在这段时间内farking神的能跑M（m），老虎为N（m），现在我们约定，只有他们同时跑到同一点farking神才会悲剧（给他留一条活路吧），而且他们绕的圈圈的长度为L 。（而且他们都很笨，始终顺时针在跑，并且即使擦肩而过也不会发生什么）
求经过S个这样的一个固定时间t以后，farking神会悲剧，如果他永远不会悲剧，则输出
“Impossible”。

题目输入：
X、Y、M、N、L
题目输出：
如果会悲剧，输出S, 如果永远不会，则输出”Impossible”
输入样例：
100 100 100 100 100
输出样例：
0
提示：




题目：缓解运输压力(1255)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
为了缓解A市到B市的运输压力，政府决定重修一些村镇之间的主要交通干道。这个时候，不少承包商蠢蠢欲动。因为每修一条路，都能获得大量利润。 为了过滤掉一批无脑的承包商，政府提出，重修的道路必须要做到，如果修这一条就能提高A市到B市整个的交通运输量，才支付给承包商钱，否则一切费用由承包商自理。不但如此，因为修路会给道路所连的两个村镇带来不便，所以承包商必须给道路两边的村镇支付一定补偿金。（对于每个村镇，补偿金只发一次）。 承包商L知道你是搞ACM的，这个对你来说一定不是难题，所以想要你帮他挑选一些道路来修以获得最大利润。
题目输入：
第一行，N，M，P，L．
N表示A市到B市可能经过的N个村镇，其中1表示A市，运输起点，N表示B市，运输终点。
M表示整个运输网络有M条有向公路。
P代表修建道路要给道路关联的每个村镇补偿金。
L是如果一条路修建成功，能获得的利润。
下面M行，每行三个参数a,b,c，代表一条有向的道路连接的村镇编号a和b，和由a村镇运至b村镇的现有运输量c。(保证没有重边，但存在b,a,c’，表示由b到a的运输量c’)
数据范围：
0&ltN&lt1000;0&ltM&lt1000000;0&ltP&ltL&lt100;0&ltc&lt100
题目输出：
能获得的最大利润S。
输入样例：
4 4 2 10
1 2 3
1 3 2 
2 4 1
3 4 4

6 7 1 3
1 2 10
2 3 4
3 4 2
3 5 1
2 4 1
4 5 5
5 6 10
输出样例：
12
5
提示：




题目：SailRace(1599)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	The Atlantic Coastal Mariners (ACM) sailing club is building a race planning tool to estimate durations of sailboat races with various race courses, wind directions, and types of sailboats. You must write a program to help with that task.		A race course is defined by marks with up to 10 marks per race course. A sailboat must sail to all marks in the specified order. The marks are identified as x- and y-coordinates on a hypothetical grid with a single unit equal to one nautical mile (nm). The positive y-axis is oriented due north and the positive x-axis is oriented due east. The race course is in open waters without any navigational limitations.		For purposes of this planning tool, the only driving force controlling a sailboat is the wind. The wind determines the sailboat's speed of advance and limits its direction of travel. The wind is constant for the duration of each race and is specified in terms of the direction from which the wind is blowing and its speed in nautical miles per hour (kts). Wind direction is specified as a compass bearing in degrees measured clockwise from 000.0  as north.		Sailboats cannot steer any closer to the wind than a given ``point angle" off the wind direction. In order to make progress closer to the wind direction, the sailboat must tack back and forth across the wind, steering no closer to the wind than its point angle. Each time the sailboat tacks or passes a mark it incurs a tack penalty. For this simulation, each sailboat will travel each leg of a race (the portion of a race between successive marks) with the minimum number of tacks and the minimum possible distance. If tacking back and forth is necessary, the first tack will be to the right of the straight direction. Courses and directions are specified as compass bearings in degrees measured clockwise from 000.0  as north.		The speed of a sailboat is determined by the sailboat design, wind speed, and direction steered relative to the wind. In the figure, the wind direction is 45  and the point angle is 40  . This means then that this sailboat cannot steer between 5  and 85  because it cannot point that closely into the wind.															 													 											For this problem, the ratio of sailboat speed to wind speed is one of three ratios, selected as shown in the table below according to the angle off the wind :				For instance, if the boat is steering at an angle off the wind which is between the reach angle and downwind angle then	boat speed = reach speed ratio  wind speed
题目输入：
	Your solution must accept multiple input data sets. Each data set represents a different race course to be evaluated for a single sailboat. The data set begins with a line with 4 numbers: wind direction (real), wind speed (real), tack penalty (real), and number of marks n (integer). The next line contains six real numbers: point angle, point speed ratio, reach angle, reach speed ratio, downwind angle, downwind speed ratio.		The subsequent n lines of the data set represent the n race marks in the order in which they must be reached. Each line begins with a 2-character mark id followed by the x-coordinate then y-coordinate of the mark.		The end of input is denoted by a line of four 0's.
题目输出：
	The output for your program consists of various data calculated for each input data set. Values should be presented with the following precisions and units.				Output for each race begins with a header containing the number of the data set (1 for the first, 2 for the second, etc.) and the number of legs. The next line is the total length of the race course, measured as the sum of distances between successive marks.		For each leg of the course, the leg number, beginning and ending mark id's, course from the beginning to end marks of the leg, and the leg distance is presented. This is followed by a listing of the tacks necessary to complete the leg. The tacks for each race are numbered sequentially, with tack numbers beginning with 1 for each race. For each tack, the tack number, the projected sailboat speed, the course steered, and the length of that tack are presented.		The summary output for each data set includes the total number of tacks, the total distance traveled for the race, the estimated race duration, and the total tack penalty time incurred by the sailboat after leaving the first mark.		The exact format of the output is shown below. Print a blank line after each input data set.
输入样例：
45 10 .1 6
45 0.5 90 0.75 135 0.67
M1 15 10
M2 25 20
M3 22 30
M4 5 25
M5 10 15
M6 10 10
0 0 0 0
输出样例：
Race 1 has 5 legs
The race layout is 58.48 nm long

Leg 1 from Mark M1 to M2: direction = 45.0, distance = 14.14 nm
Tack 1: speed = 5.0, direction = 90.0, distance = 10.00 nm
Tack 2: speed = 5.0, direction = 0.0, distance = 10.00 nm 

Leg 2 from Mark M2 to M3: direction = 343.3, distance = 10.44 nm
Tack 3: speed = 5.0, direction = 343.3, distance = 10.44 nm

Leg 3 from Mark M3 to M4: direction = 253.6, distance = 17.72 nm
Tack 4: speed = 6.7, direction = 253.6, distance = 17.72 nm

Leg 4 from Mark M4 to M5: direction = 153.4, distance = 11.18 nm
Tack 5: speed = 7.5, direction = 153.4, distance = 11.18 nm

Leg 5 from Mark M5 to M6: direction = 180.0, distance = 5.00 nm
Tack 6: speed = 6.7, direction = 180.0, distance = 5.00 nm

Race 1 was 64.34 nm long with 6 tack legs 
Estimated Race Duration is 11.47 hours with 0.50 hours of Tack Penalty

提示：
None



题目：不想生成树(1814)
时间限制：2000/1000 MS (Java/Others)
空间限制：65536/32768 K (Java/Others)
题目描述：
树是一种优美的数据结构，对于一个有N个节点的树，它恰好有N-1条边，每个点相互之间可达并且只有一条简单路径。
现在你有两颗带权无根树A和B，我们想知道，如果在A树的u节点和B树的v节点之间连一条长度为w的边，形成的新树上任意两点之间的最大距离是多少。 
题目输入：
题目包含多组输入数据,对于每一组输入数据 :
第一行两个整数NA,NB（<=10000）表示A树和B树的节点数。
接下来NA-1行，描述A树的信息。每行三个整数u,v,w，表示A树上u节点到v节点有一条长度为w的边。
接下来NB-1行，描述B树的信息。输入与A树一致。
之后给出一个整数Q(<=10000)，表示询问的个数。
接下来Q行，每行三个整数u,v,w，表示A树上的u节点到B树上的v节点有一条长度为w的边。
任意边的边长不超过1000
题目输出：
对于每组输入数据：
输出每个询问中形成的新树上任意两点之间的最大距离是多少。
输入样例：
7 5
3 6 10
3 2 20
2 5 70
2 7 100
2 4 90
4 1 30
1 2 80
2 5 60
3 4 20
3 2 50
3
7 1 10
2 2 10
2 2 90
输出样例：
380
220
290
提示：
 



题目：抢修南理工水道(1051)
时间限制：10000 ms
空间限制：65535 ms
题目描述：
由于7.7那次大雨，数量巨大的污泥把南理工的大部分下水道给堵塞了，现在，理工大物业要抢修下水道，临时决定，将喷泉广场的积水及时疏通到友谊河里，来解燃眉之急！从喷泉广场（含）到友谊河（含）中间有N（2<=N<=1000）个下水道疏通点，方便的标号为1.。。N，Dij为i到j的距离，物业现在有多年的经验，对于i至j两个疏通点，疏通1单位距离需要花费Cij。值得提醒的是，i到j之间可能出现两条或多条不同的路径。由于最近资金的紧缺，物业需要你帮他们安排一条1-N的疏通线路，使得花费最小！
题目输入：
有多个case，一文件EO有多个case，一文件EOF结束，第一行输入M ,N（M表示有多少条线路，1<=M<=10000）接下来的M行，输入i，j, Dij，Cij，
题目输出：
输出最小花费值，只占一行。
输入样例：
5 5
1 2 10 2
2 3 15 2
3 4 10 2
4 5 2 10
1 5 10 10

输出样例：
90
提示：




题目：Radiation(1700)
时间限制：2000ms
空间限制：65535kb
题目描述：
	Nuclear power plants (NPP) are a blessing and curse of modern civilization. NPPs have some risks but still it is one of the cheapest ways to produce electricity in the developed world. In this problem we will discuss a situation related to two nuclear plants, which are not far away from each other.	We will describe the entire scenario in a flat land, so two-dimensional Cartesian coordinate system is used to denote each location. Lets assume that the coordinate of the two nuclear power plants are (ax, ay) and (bx, by). Houses that are located within distance R1 (inclusive) of the power plant at (ax, ay) are under high risk of radiation. Similarly, houses that are located within distance R2 (inclusive) of the power plant at (bx, by) are under high risk of radiation. So the authorities of power plant 1 and power plant 2 distribute special protective equipments to the houses that are within radius (inclusive) R1 and R2 of the respective power plants. As a result each of the houses that are endangered by both the plants actually receive two sets of equipments to protect their house, however only one set is enough for full protection. Houses that are outside the high-risk area are under low risk of radiation but they do not receive any protective equipment due to budget constraints. However, each owner of the houses that have two sets of protective equipments gives away one set of equipment to the owner of a house that has none. Still, some houses in the low-risk area remain un-protected. Given the location of the houses and the values of ax, ay, bx, by and possible values of R1 and R2 your job is to find out the number of houses that are without protective equipments for each pair of values of R1 and R2.
题目输入：
	The input file contains at most 3 test cases. The description of each test case is given below:	A test case starts with a line containing a positive integer N (0 < N ≤ 200000) that denotes the number of houses that are under either low risk or high risk of radiation. Each of the next N lines contains two integers xi, yi (0 ≤ xi, yi ≤ 20000) that denotes the coordinate of the i-th house. No two houses are at the same location. The next line contains five integers ax, ay, bx, by and q (0 ≤ ax, ay, bx, by ≤ 20000, 0 <q ≤ 20000). The meaning of ax, ay, bx and by are given in the	problem statement. Here q denotes the total number of query. Each of the next q lines contains two integers, which denote the values of R1 and R2 (0 < R1, R2 ≤ 13000) respectively.	A line containing a single zero terminates input. This line should not be processed.
题目输出：
	For each test case produce q+1 lines of output. The first line is the serial of output. For each query (given value of R1 and R2) determine how many houses in the low risk region remains without protective equipment. You may consider using faster IO as judge input file is large.
输入样例：
11
95 75
27 6
93 5
124 13
34 49
65 61
81 49
77 33
110 50
91 22
110 25
57 42 97 36 2
31 25
25 25
0

输出样例：
Case 1:
2
2

提示：
First query in the sample input corresponds to Figure 1.



题目：France'98(1398)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Today the first round of the Soccer World Championship in France is coming to an end. 16 countries are remaining now, among which the winner is determined by the following tournament:  1 Brazil -----+	
   	       +-- ? --+
 2 Chile ------+       |
		       +-- ? --+
 3 Nigeria ----+       |       |
	       +-- ? --+       |
 4 Denmark ----+	       |
	                       +-- ? --+
 5 Holland ----+	       |       |
	       +-- ? --+       |       |
 6 Yugoslavia -+       |       |       |
		       +-- ? --+       |
 7 Argentina --+       |	       |
	       +-- ? --+	       |
 8 England ----+		       |
				       +-- World Champion
 9 Italy ------+		       |
	       +-- ? --+	       |
10 Norway -----+       |               |
		       +-- ? --+       |
11 France -----+       |       |       |
	       +-- ? --+       |       |
12 Paraguay ---+	       |       |
			       +-- ? --+
13 Germany ----+	       |
	       +-- ? --+       |
14 Mexico -----+       |       |
		       +-- ? --+
15 Romania ----+       |
	       +-- ? --+
16 Croatia ----+
For each possible match A vs. B between these 16 nations, you are given the probability that team A wins against B. This (together with the tournament mode displayed above) is sufficient to compute the probability that a given nation wins the World Cup. For example, if Germany wins against Mexico with 80%, Romania against Croatia with 60%, Germany against Romania with 70% and Germany against Croatia with 90%, then the probability that Germany reaches the semi-finals is 80% * (70% * 60% + 90% * 40%) = 62.4%. 
Your task is to write a program that computes the chances of the 16 nations to become the World Champion '98. 
题目输入：
The input file will contain just one test case.
The first 16 lines of the input file give the names of the 16 countries, from top to bottom according to the picture given above.
Next, there will follow a 16 x 16 integer matrix P where element pijgives the probability in percent that country #i defeats country #j in a direct match. Country #i means the i-th country from top to bottom given in the list of countries. In the picture above Brazil is #1 and Germany is #13, so p1,13=55 would mean that in a match between Brazil and Germany, Brazil wins with a probability of 55%.
Note that matches may not end with a draw, i.e. pij + pji = 100 for all i,j. 
题目输出：
Output 16 lines of the form "XXXXXXXXXX p=Y.YY%", where XXXXXXXXXX is the country's name, left-justified in a field of 10 characters, and Y.YY is their chance in percent to win the cup, written to two decimal places. Use the same order of countries like in the input file. 
输入样例：
Brazil
Chile
Nigeria
Denmark
Holland
Yugoslavia
Argentina
England
Italy
Norway
France
Paraguay
Germany
Mexico
Romania
Croatia
50 65 50 60 55 50 50 65 45 55 40 55 40 55 50 50 
35 50 35 45 40 35 35 50 30 40 25 40 25 40 35 35 
50 65 50 60 55 50 50 65 45 55 40 55 40 55 50 50 
40 55 40 50 45 40 40 55 35 45 30 45 30 45 40 40 
45 60 45 55 50 45 45 60 40 50 35 50 35 50 45 45 
50 65 50 60 55 50 50 65 45 55 40 55 40 55 50 50 
50 65 50 60 55 50 50 65 45 55 40 55 40 55 50 50 
35 50 35 45 40 35 35 50 30 40 25 40 25 40 35 35 
55 70 55 65 60 55 55 70 50 60 45 60 45 60 55 55 
45 60 45 55 50 45 45 60 40 50 35 50 35 50 45 45 
60 75 60 70 65 60 60 75 55 65 50 65 50 65 60 60 
45 60 45 55 50 45 45 60 40 50 35 50 35 50 45 45 
60 75 60 70 65 60 60 75 55 65 50 65 50 65 60 60 
45 60 45 55 50 45 45 60 40 50 35 50 35 50 45 45 
50 65 50 60 55 50 50 65 45 55 40 55 40 55 50 50 
50 65 50 60 55 50 50 65 45 55 40 55 40 55 50 50 

输出样例：
Brazil     p=8.54%
Chile      p=1.60%
Nigeria    p=8.06%
Denmark    p=2.79%
Holland    p=4.51%
Yugoslavia p=7.50%
Argentina  p=8.38%
England    p=1.56%
Italy      p=9.05%
Norway     p=3.23%
France     p=13.72%
Paraguay   p=3.09%
Germany    p=13.79%
Mexico     p=3.11%
Romania    p=5.53%
Croatia    p=5.53%

提示：




题目：ThePerfectStall(1501)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer John completed his new barn just last week, complete with all the latest milking technology. Unfortunately, due to engineering problems, all the stalls in the new barn are different. For the first week, Farmer John randomly assigned cows to stalls, but it quickly became clear that any given cow was only willing to produce milk in certain stalls. For the last week, Farmer John has been collecting data on which cows are willing to produce milk in which stalls. A stall may be only assigned to one cow, and, of course, a cow may be only assigned to one stall. Given the preferences of the cows, compute the maximum number of milk-producing assignments of cows to stalls that is possible.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  One line with two integers, N (0 <= N <= 200) and M (0 <= M <= 200). N is the number of cows that Farmer John has and M is the number of stalls in the new barn.  Line 2..N+1:  N lines, each corresponding to a single cow. The first integer (Si) on the line is the number of stalls that the cow is willing to produce milk in (0 <= Si <= M). The subsequent Si integers on that line are the stalls in which that cow is willing to produce milk. The stall numbers will be integers in the range (1..M), and no stall will be listed twice for a given cow.
题目输出：
A single line with a single integer, the maximum number of milk-producing stall assignments that can be made.
输入样例：
5 5
2 2 5
3 2 3 4
2 1 5
3 1 2 5
1 2
输出样例：
4
提示：




题目：Sorting(1152)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
In this problem, you have to analyze two particular sorting algorithms.One: The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence (相邻)elements until the sequence is sorted in ascending order. Two: The algorithm processes a sequence of n distinct integers by swapping any two sequence elements（不一定相邻） until the sequence is sorted in ascending order. For the input sequence5 2 1 4 3,
After sorting, produces the output1 2 3 4 5.
Your task is to determine how many swap operations the two ways need to perform in order to sort a given input sequence.
题目输入：
The input contains several test cases. Every test case begins with a line that contains a single integer n < 100,000 -- the length of the input sequence. The following line contains n integers and 0 < a[i] <= n (each element is different). Input is terminated by a sequence of length n = 0. This sequence must not be processed.
题目输出：
For every input sequence, your program prints a single line containing two integer numbers op, the minimum number of each way to swap operations necessary to sort the given input sequence.
输入样例：
10
7 5 9 8 4 2 6 1 10 3
5
5 2 1 4 3
3
1 2 3
0
输出样例：
28 8
6 2
0 0
提示：
e.g  (5 2 1 4 3) 
①(5 2 1 4 3)->(2 5 1 4 3)->(2 1 5 4 3) ->(1 2 5 4 3) ->(1 2 5 3 4) ->(1 2 3 5 4) ->(1 2 3 4 5)
②(5 2 1 4 3)->(1 2 5 4 3)->(1 2 3 4 5)  



题目：保卫萝卜(1815)
时间限制：2000/1000 MS (Java/Others)
空间限制：65536/32768 K (Java/Others)
题目描述：
《保卫萝卜》是一款超萌的塔防小游戏，玩家在游戏中可以修建各种防御塔保卫萝卜战怪兽，游戏的目的就是防止怪兽吃掉我们的萝卜。
为了收集游戏中的金萝卜奖杯，我们的任务是“保卫一个完整的萝卜”。保卫成功一个萝卜，也就是说没有怪物碰到过这个萝卜，这就需要用金币修防御塔来消灭在地图中从刷怪点冲向萝卜的怪物。如果给出游戏的地图，请问：至少需要多少花多少金币才能确保完成任务？
题目输入：
题目包含多组输入数据,对于每一组输入数据 :
第一行两个整数N,M(<500)。N表示地图上的顶点数，M表示边数。
第二行包含N个int 类型的整数，A1 ~An。若Ai =0，表示第i个顶点是萝卜；若Ai<0，表示第i个顶点是刷怪点;若Ai>0，表示不依靠别的防御消灭最强的一波经过第i个顶点的怪物需要花费Ai个金币。
之后的M行各有两个整数，u,v（<500）表示第u个顶点到第v个顶点之间有一条怪物可以任意通行的边。
题目输出：
对于每组输入数据：
如果能完成任务，输出至少需要花多少金币才能确保我们能保卫一个萝卜;如果不能完成任务，输出“Poor Carrot”。
输入样例：
3 2
0 2 -1
1 2
2 3
5 5
-1 2 3 0 -1
1 2
2 3
3 4
2 4
4 5
5 5
-1 2 3 0 2
1 2
2 3
3 4
2 4
4 5
输出样例：
Case 1: 2
Case 2: Poor Carrot
Case 3: 2
提示：
萝卜所在的点是无法进行防御的，所以不要在有萝卜的地方浪费金币啦。



题目：Triple(1256)
时间限制：1000 ms
空间限制：32768 ms
题目描述：
Once upon a time there is an ancient kingdom, The emperor of the kingdom has a so strong mind to manage his land that he divide the kongdom to n(0<n<10^9) states! And he likes to go on a tour of inspection very much. He plans to travel everyday, and for each tour, he chooses a different combination of states to visit.
People in this kingdom, strangely enough, use the ternary system to count numbers, and the emperor prefer 1 to be the last digit of a number. So the number of states he choose would only be 3k+1 while k is an integer. Then, he would like to know how many combinations he can choose from to travel. As is known to all, emperors should study more of policy than maths and programming. So he turns to you, the most excellent mathematician and programmer, to give him the answer.
题目输入：
First line contain an integer t(t<=100), which means t cases follow.

Then comes t lines, each contains an integer n, which means the emperor has divided the kingdom to n states.
题目输出：
For each case, output one line showing the number of combinations according to the emperor's request. As the answer may be very large, you should print it after module 1000000007(i.e. 10^9+7).
输入样例：
2
1
5
输出样例：
1
10
提示：




题目：树的遍历转化(1052)
时间限制：1000 ms
空间限制：65535 ms
题目描述：



题目输入：
按从前序到后序的顺序输入数（字母不可重复）；
题目输出：
输出树的后序遍历。
输入样例：
ABDC
DBAC

ABDEHICFG
DBHEIAFCG

输出样例：
DBCA
DHIEBFGCA

提示：




题目：Goldbach'sConjecture(1399)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
In 1742, Christian Goldbach, a German amateur mathematician, sent a letter to Leonhard Euler in which he made the following conjecture: 
Every even number greater than 4 can bewritten as the sum of two odd prime numbers. For example: 

8 = 3 + 5. Both 3 and 5 are odd prime numbers. 
20 = 3 + 17 = 7 + 13. 
42 = 5 + 37 = 11 + 31 = 13 + 29 = 19 + 23. Today it is still unproven whether the conjecture is right. (Oh wait, I have the proof of course, but it is too long to write it on the margin of this page.) 
Anyway, your task is now to verify Goldbach's conjecture for all even numbers less than a million. 
题目输入：
The input file will contain one or more test cases.
Each test case consists of one even integer n with 6 <= n < 1000000.
Input will be terminated by a value of 0 for n. 
题目输出：
For each test case, print one line of the form n = a + b, where a and b are odd primes. Numbers and operators should be separated by exactly one blank like in the sample output below. If there is more than one pair of odd primes adding up to n, choose the pair where the difference b - a is maximized. If there is no such pair, print a line saying "Goldbach's conjecture is wrong." 
输入样例：
8
20
42
0

输出样例：
8 = 3 + 5
20 = 3 + 17
42 = 5 + 37

提示：




题目：OptimalSpaceWay(1701)
时间限制：5000ms
空间限制：65535kb
题目描述：
	It is 2180 AD, the human race has just started to abandon the earth and spread the civilization in space. ACM (Association for Cosmic Machinism) is in charge of this whole relocation process and this process is funded mostly by IBM (Inter-planet Ballistic Machines). Thousands of space cities are built in the outer space and to maintain universal business hour (Sunrises and sets at the same time in all space cities) they are built on the same imaginary plane. So the location of the cities can be expressed as two-dimensional Cartesian coordinates.	The cities are located far away from one another and the only way of going from one city to another is by using shuttle rockets. But from previous experience ACM knows that traveling by roads is a lot cheaper than traveling by rockets. So they have decided to build some roads. But building roads between every pair of cities is very expensive. So they are planning to build a super space-way (SSW) that will be a straight road. When someone needs to travel from a city c1 to city c2, he first travels from c1 to the nearest point of SSW with a rocket, and moves along the SSW to the point, which is nearest to c2. Then from there he goes to c2 using another rocket.	The cost of moving along the road is proportional to the distance but cost of flying on rockets is proportional to the square of the distance. So you have to build the SSW in such a position so that total cost of traveling in a calendar year by rockets is minimized. You can assume that:	1. The cities are so small compared to the distance between them that they can be considered as points on a two dimensional Cartesian coordinate system.	2. The SSW is so narrow compared to the distance between the cities that it can be considered as a straight line. The length of the SSW can be increased indefinitely in both directions if total cost of traveling by rocket decreases by doing so.	3. For simplicity you can assume that total number of incoming and outgoing rockets from each city is the same.	4. Sometimes exactly one city can be marked as the super city, which is the center of all activities. In that case the total of incoming and outgoing flights of that city is M times higher than an ordinary city.	5. Assume that all rockets travel in straight line.	Given the location of all the cities, you will have to find a location for the SSW for which the total cost of traveling by rockets is minimum. And you have to produce the minimum average cost per rocket flight assuming that cost of flying v unit distance is v2.
题目输入：
	The input file contains less than 50 test cases. The description of each test case is given below:	Each test case starts with two integers N (0 < N ≤ 10000) and Q (0 < Q ≤ 100). Here N is the total number cities built in outer space and Q is the total number of query. Each of the next N lines contains two floating-point numbers, i i x , y (0.0 ≤ i i x , y ≤ 1000.0) which denotes the coordinate of the i-th city. Cities are numbered from 0 to N-1 in the order they appear in the input file. Each of the next Q lines contains two integers S (0 ≤ S ≤ N-1) and M (1 < M ≤ 10000). ACM-ICPC Asia Hatyai Regional Programming Contest – November 16, 2012 – PSU, Hatyai 5	Here S denotes the id of the super city and M denotes that its total number of incoming andoutgoing flights in the super city is M times higher than an ordinary city.	A line containing two zeroes terminates the input. This line should not be processed.
题目输出：
	For each test case produce Q+2 lines of output. The first line contains the case number followed by a colon. The second line contains a floating-point number which denotes the minimum average cost per rocket flight for the optimal super space way (Assuming all cities are ordinary).This line is followed by Q lines, one line for each query. This line contains the serial of query followed by a floating-point number. This number denotes the minimum average cost for the optimal super space way assuming that S th city is a super city and all other cities are ordinary. All floating-point numbers in the output should have five digits after the decimal point. Look at the output for sample input for details. You can assume that for all floating-point outputs an absolute error less than 10-5 will be ignored.
输入样例：
5 2
464.9900 243.2652
463.9409 772.4632
201.9822 561.6255
695.8948 933.4567
226.0628 93.1435
3 2
4 3
4 2
27.1679 304.2512
27.7639 16.2479
921.9150 863.0064
167.6203 929.5471
2 2
2 3
0 0

输出样例：
Case 1:
16172.49971
1: 14289.23473
2: 11558.37654
Case 2:
53198.72595
1: 47995.33546
2: 41543.27604

提示：
None



题目：StampsandEnvelopeSize(1600)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	Philatelists have collected stamps since long before postal workers were disgruntled. An excess of stamps may be bad news to a country's postal service, but good news to those that collect the excess stamps. The postal service works to minimize the number of stamps needed to provide seamless postage coverage. To this end you have been asked to write a program to assist the postal service.		Envelope size restricts the number of stamps that can be used on one envelope. For example, if 1 cent and 3 cent stamps are available and an envelope can accommodate 5 stamps, all postage from 1 to 13 cents can be ``covered":				Although five 3 cent stamps yields an envelope with 15 cents postage, it is not possible to cover an envelope with 14 cents of stamps using at most five 1 and 3 cent stamps. Since the postal service wants maximal coverage without gaps, the maximal coverage is 13 cents.
题目输入：
	The first line of each data set contains the integer S, representing the maximum of stamps that an envelope can accommodate. The second line contains the integer N, representing the number of sets of stamp denominations in the data set. Each of the next N lines contains a set of stamp denominations. The first integer on each line is the number of denominations in the set, followed by a list of stamp denominations, in order from smallest to largest, with each denomination separated from the others by one or more spaces. There will be at most S denominations on each of the N lines. The maximum value of S is 10, the largest stamp denomination is 100, the maximum value of N is 10.		The input is terminated by a data set beginning with zero (S is zero).
题目输出：
	Output one line for each data set giving the maximal no-gap coverage followed by the stamp denominations that yield that coverage in the following format:			max coverage = <value> : <denominations>		If more than one set of denominations in a set yields the same maximal no-gap coverage, the set with the fewest number of denominations should be printed (this saves on stamp printing costs). If two sets with the same number of denominations yield the same maximal no-gap coverage, then the set with the lower maximum stamp denomination should be printed. For example, if five stamps fit on an envelope, then stamp sets of 1, 4, 12, 21 and 1, 5, 12, 28 both yield maximal no-gap coverage of 71 cents. The first set would be printed because both sets have the same number of denominations but the first set's largest denomination (21) is lower than that of the second set (28). If multiple sets in a sequence yield the same maximal no-gap coverage, have the same number of denominations, and have equal largest denominations, then print the set with the lewer second-maximum stamp denomination, and so on.
输入样例：
5
2
4 1 4 12 21
4 1 5 12 28
10
2
5 1 7 16 31 88
5 1 15 52 67 99
6
2
3 1 5 8
4 1 5 7 8
0
输出样例：
max coverage =  71 :  1  4 12 21
max coverage = 409 :  1  7 16 31 88
max coverage =  48 :  1  5  7  8
提示：
None



题目：JobProcessing(1502)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A factory is running a production line that requires two operations to be performed on each job: first operation "A" then operation "B". Only a certain number of machines are capable of performing each operation. Figure 1 shows the organization of the production line that works as follows. A type "A" machine takes a job from the input container, performs operation "A" and puts the job into the intermediate container. A type "B" machine takes a job from the intermediate container, performs operation "B" and puts the job into the output container. All machines can work in parallel and independently of each other, and the size of each container is unlimited. The machines have different performance characteristics, a given machine requires a given processing time for its operation. Give the earliest time operation "A" can be completed for all N jobs provided that the jobs are available at time 0. Compute the minimal amount of time that is necessary to perform both operations (successively, of course) on all N jobs.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  Three space-separated integers:            N, the number of jobs (1<=N<=1000).            M1, the number of type "A" machines (1<=M1<=30)            M2, the number of type "B" machines (1<=M2<=30)  Line 2..etc:  M1 integers that are the job processing times of each type "A" machine (1..20) followed by M2 integers, the job processing times of each type "B" machine (1..20).
题目输出：
A single line containing two integers: the minimum time to perform all "A" tasks and the minimum time to perform all "B" tasks (which require "A" tasks, of course).
输入样例：
5 2 3
1 1 3 1 4
输出样例：
3 5
提示：




题目：King&Queen’sTravelling(1153)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
多年以后，newfarking终于找到了他心爱的newfarqueen，并成功追到了手，所以他马上要做的下一件事就是去旅游，完成多年来的心愿。
但是newfarking意识到自己是个路痴，如果一起在森林里游玩的时候迷路了怎么办，那岂不是很没面子。作为徒弟的BOBO发现师父有麻烦，立马想到要做一个能显示当前师父坐标的装置。在制作到最后一步的时候，BOBO由于一些极特殊的原因有事离开了。现在只能靠你完成了。
这个装置已经做好的部分是这样的，当你到达某处景点时，将集合地设为原点，之后你可以选择性的输入2个标志性建筑的坐标（x，y）。这个装置已经可以感应出以持有装置的人为中心的，正北方向到在设定的标志性建筑的方向，也就是说你知道一个角度w，w是标志性建筑物在你的什么方位，即建筑在你的正北方时w=0，建筑在你的正南方时w=180。
你所要完成的最后一步就是做一个小程序，使你能通过装置得出newfarking夫妇的坐标。
题目输入：
先是单个的一个整数，表示测试数据的个数。每次测试的输入都有两行，分别是第一个标志性建筑以集合地为原点的坐标（x1，y1）和在你的方位w1，以及第二个标志性建筑的（x2，y2）和w2.
(0 <= x <= 100,0 <= y <= 100,0 <= w <= 360)

题目输出：
两个，即你的坐标x和y，中间用空格隔开，精确到小数点后四位。
输入样例：
3
30 50 90
20 40 180
20 15 75
19 33 87
12 13 14
15 16 17

输出样例：
20.0000 50.0000103.7538 37.44182.7929 -23.9275
提示：




题目：Min酱要旅行(1816)
时间限制：8000 ms
空间限制：65535 KB
题目描述：
从前有个富帅叫做Min酱，他很喜欢出门旅行，每次出门旅行，他会准备很大一个包裹以及一大堆东西，然后尝试各种方案去塞满它。
然而每次出门前，Min酱都会有个小小的烦恼。众所周知，富帅是很讨妹子喜欢的，所以Min酱也是有大把大把的妹子，每次出门都会有一只妹子随行。然而这些妹子总是会非常排斥Min酱准备的众多东西中的一件（也许是因为这件东西是其它妹子送给Min酱的），这件东西Min酱是万万不敢带上的，否则的话……嘿嘿嘿。另外，妹子们嫌Min酱的包裹太丑了，会自带一个包裹去换掉Min酱的包裹。
Min酱是个控制欲很强的人，然而这样一来，Min酱就不知道可以用多少种方案去填充包裹了，所以Min酱很郁闷。
于是Min酱找到了聪明的你，希望你能帮助他解决这些问题。
另外，Min酱是个典型的懒人，他不希望每次带不同的妹子出去都麻烦你，所以他希望你能给出有K1..Kn件物品，第i件不能带并且包裹大小为1..M的所有方案数。
题目输入：
可能有多组数据。对于每一组数据：
第一行，两个整数n,m，分别表示物品数量和妹子带的包裹的最大容积。
第二行，n个整数，分别表示物品ki的体积。1<=n,m<=2300，ki<=1000
题目输出：
对于每一组数据，输出一个n*m的矩阵，第i行j列表示包裹容积为j，不能带i号物品时，装满包裹的方案总数。
为了美观起见，我们只保留方案数的个位。
输入样例：
3 2
1 1 2
输出样例：
11
11
21
提示：




题目：Pre&in=>ptr(1053)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
输入树的前中序遍历；
写出其后序遍历；

题目输入：

题目输出：

输入样例：
abc
bac
abdehicfg
dbheiafcg
#
输出样例：
bca
dhiebfgca

提示：




题目：MagicalPoint(1257)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
In STSky World, there is no euclidean but magical space, every point P(a,b,c) in original world represents (M(a) ,M(b) ,M(c)) in magical world. Here, the value of function M(n) is difined as the number of prime-factors of n. For example, M(3)=1, M(12)=M(2*2*3)=3, M(22)=M(2*11)=2...You task is very simple. Given n original points,the ith of which is Qi(xi,yi,zi). You are only needed to find a best point P(x,y,z) and calculate the value of Ans which satisfies:
We assure that every elements of Qi (indicating xi,yi and zi) is a certain positive integer, while p.x, p.y and p.z are not necessarily all integers.
题目输入：
The input will consist of multiple test cases(T<=10).For each test case,the first line is a positive interger n(n<=20).As the following n lines, the ith line contains three integers: xi,yi and zi (2<=xi,yi,zi<=10^6).
The input will be terminated by end-of-file.
题目输出：
For each test case, you should print only one demical number on one line.
The answer should be written with precision of two decimal places.

输入样例：
2
2 3 5
7 11 12
输出样例：
2.00
提示：
In the sample, Q1=(M(2),M(3),M(5))=(1,1,1),Q2=(M(7),M(11),M(12))=(1,1,3).
So we choose P=(1.0,1.0,2.0) as the best point because it make the formula above minimum.
And the answer is distance(Q1,P)+distance(Q2,P)=1+1=2.00




题目：HeavyCargo(1400)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Big Johnsson Trucks Inc. is a company specialized in manufacturing big trucks. Their latest model, the Godzilla V12, is so big that the amount of cargo you can transport with it is never limited by the truck itself. It is only limited by the weight restrictions that apply for the roads along the path you want to drive. 
Given start and destination city, your job is to determine the maximum load of the Godzilla V12 so that there still exists a path between the two specified cities. 
题目输入：
The input file will contain one or more test cases. The first line of each test case will contain two integers: the number of cities n (2<=n<=200) and the number of road segments r (1<=r<=19900) making up the street network.
Then r lines will follow, each one describing one road segment by naming the two cities connected by the segment and giving the weight limit for trucks that use this segment. Names are not longer than 30 characters and do not contain white-space characters. Weight limits are integers in the range 0 - 10000. Roads can always be travelled in both directions.
The last line of the test case contains two city names: start and destination.
Input will be terminated by two values of 0 for n and r. 
题目输出：
For each test case, print three lines:

    * a line saying "Scenario #x" where x is the number of the test case
    * a line saying "y tons" where y is the maximum possible load
    * a blank line 
输入样例：
4 3
Karlsruhe Stuttgart 100
Stuttgart Ulm 80
Ulm Muenchen 120
Karlsruhe Muenchen
5 5
Karlsruhe Stuttgart 100
Stuttgart Ulm 80
Ulm Muenchen 120
Karlsruhe Hamburg 220
Hamburg Muenchen 170
Muenchen Karlsruhe
0 0

输出样例：
Scenario #1
80 tons
 
Scenario #2
170 tons

提示：




题目：整数的划分(1154)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
将一个整数n表示成一系列的正整数之和：        n = n1 + n2 + n3……+nk(n1 >= n2 >= n3 >= …… >= nk >= 1 ,k >= 1)被称做正整数n的一个划分。一个正整数n可能存在着不同的划分，例如正整数6的全部划分为：       6=6；       6=5+1；       6=4+2   6=4+1+1；       6=3+3   6=3+2+1  6=3+1+1+1；       6=2+2+2 6=2+2+1+1  6=2+1+1+1+1；       6=1+1+1+1+1+1则6的划分数为11.
题目输入：
第一行输入N，N为总测试数的个数(N <= 50)；
接下来有N行，每行输入一个测试数n,(1 =< n <= 50)。
题目输出：
输出N行，每行为n的划分数。
输入样例：
5
1
5
6
20
25
输出样例：
1
7
11
627
1958
提示：




题目：Uncompress(1601)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	A simple scheme for creating a compressed version of a text file can be used for files which contain no digit characters. The compression scheme requires making a list of the words in the uncompressed file. When a non-alphabetic character is encountered in the uncompressed file, it is copied directly into the compressed file. When a word is encountered in the uncompressed file, it is copied directly into the compressed file only if this is the first occurrence of the word. In that case, the word is put at the front of the list. If it is not the first occurrence, the word is not copied to the compressed file. Instead, its position in the list is copied into the compressed file and the word is moved to the front of the list. The numbering of list positions begins at 1.		Write a program that takes a compressed file as input and generates a reproduction of the original uncompressed file as output. You can assume that no word contains more than 50 characters and that the original uncompressed file contains no digit characters.		For the purposes of this problem, a word is defined to be a maximal sequence of upper- and lower-case letters. Words are case-sensitive - the word abc is not the same as the word Abc. For example,					There is no upper limit on the number of different words in the input file. The end of the input file is signified by the number 0 on a line by itself. The terminating 0 merely indicates the end of the input and should not be part of the output produced by your program.
题目输入：

题目输出：

输入样例：
Dear Sally,

   Please, please do it--1 would 4
Mary very, 1 much.  And 4 6
8 everything in 5's power to make
14 pay off for you.

   -- Thank 2 18 18--
0
输出样例：
Dear Sally,

   Please, please do it--it would please
Mary very, very much.  And Mary would
do everything in Mary's power to make
it pay off for you.

   -- Thank you very much--
提示：
None



题目：UltimateDevice(1702)
时间限制：10000ms
空间限制：65535kb
题目描述：
	Mr Tomisu Ghost is planning to build the ultimate device. He shared the idea with me but asked me to keep it secret. So, I am not going through the functionalities of this great device and I also do not want to describe the mechanisms to build it. However, Mr Tomisu has planned to buy some circuits for this device from a local store and for	that he went to the store. He found that there were n types of circuits and each of the ith circuits has the burning cycle of ti seconds. burning cycle of a circuit means that if it’s used in the device, it will enter to its burning state at every ti seconds. If there is any other circuit in the device that is not in its burning state, then every circuit will survive and no damage will happen. But if every circuit is at its burning state at that time, all will be burned out together and the	device will be malfunctioned.	For example, consider two circuits have the burning cycle of 3 and 5 seconds respectively and let both of them are used in the device together. At 3rd second, circuit 1 will be in its burning state, but since the other one is not in its burning state, it will survive. At 5th second, circuit 2 will be in burning state while circuit 1 will not be in its burning state, thus circuit 2 will also survive. At 6th second circuit 1 will be in its burning state again, but survive for the same reason. Thus at 15th second both circuits will be in their burning state and burn out. If there are three circuits with the burning cycle of 3, 4 and 5 seconds respectively and all of them are used together, they will burn out at 60th second. But if the first two circuits are used only, then they will burn out at 12th second.	Now, Mr. Tomisu wants to go through all the circuits one by one. In front of every circuit, he will flip a coin (assume that it's a fair coin). If it's a head he will select the circuit, otherwise he will reject it. After visiting the nth circuit he will have some selected circuits for his device. You have to help him by calculating the expected lifetime of his device. If no circuit is selected, then the lifetime of the machine is 0.
题目输入：
	Input starts with an integer T (≤ 100), denoting the number of test cases.	Each case starts with an integer n (1 ≤ n ≤ 100), where n denotes the number of circuits. Thenext line contains n space separated integers, where the ith integer denotes the burning cycle of the ith circuit, ti (1 ≤ ti ≤ 500). You may assume that all the burning cycles for a test case will be distinct.
题目输出：
	For each case, print the case number first. Then print (r * 2n) modulo 10007, where r is the expected lifetime of the device. If (r * 2n) is not an integer print "not integer" without the quotes.
输入样例：
2
3
3 4 5
2
2 7

输出样例：
Case 1: 119
Case 2: 23

提示：
None



题目：Cowcycles(1503)
时间限制：4000 ms
空间限制：65535 ms
题目描述：
[International readers should note that some words are puns on cows.] Having made a fortune on Playbov magazine, Hugh Heifer has moved from his original field in the country to a fashionable yard in the suburbs. To visit fond pastoral memories, he wishes to cowmmute back to his old stomping grounds. Being environmentally minded, Hugh wishes to transport himself using his own power on a Cowcycle (a bicycle specially fitted for his neatly manicured hooves). Hugh weighs over a ton; as such, getting smoothly up to speed on traditional cowcycle gear sets is a bit challenging. Changing among some of the widely spaced gear ratios causes exertion that's hard on Hugh's heart. Help Hugh outfit his Cowcycle by choosing F (1 <= F <= 5) gears (sprockets) in the front and R (1 <= R <= 10) gears in the rear of his F*R speed cowcycle subject to these rules: The possible sizes (number of teeth) for the F front gears are specified. The possible sizes (number of teeth) for the R rear gears are specified. At any given gear setting, the gear ratio is the quotient of the number of teeth on the front gear and the number of teeth on the rear gear (i.e., number of front gear teeth divided by number of rear gear teeth) The largest gear ratio must be at least three times the smallest. The variance (see below) of the set of DIFFERENCES between successive (i.e., after sorting) gear ratios should be minimized. Calculate the mean and variance of a set of differences (xi in this formula) by the following formulae:                        1    n               mean = ---  SUM xi                       n   i=1                          1    n               variance = ---  SUM (xi - mean)2                       n   i=1    Deduce and print the optimal sets of F front gears and R rear gears so that the variance is minimized (and the ratios span a factor of at least 3x).
题目输入：
There are several test cases, end by EOF, for each test case:The first line contains F and R, the numbers of front and rear gears. The second line contains four numbers: F1, F2 (25 <= F1 < F2 <= 80), R1, and R2 (5 <= R1 < R2 <= 40). All front gears from F1 through F2 are available; all rear gears from R1 through R2 are available. There will exist at least one legal set of gears.
题目输出：
Display the number of teeth on the set of F chosen front gears, from smallest to largest, on the first line of output (separated by spaces). Display the number of teeth on the set of R chosen rear gears, from smallest to largest, on the second line of output. All gears have an integer number of teeth, of course. If multiple optimal answers exist, output the answer with the smallest front gear set (smallest first gear, or smallest second gear if first gears match, etc.). Likewise, if all first gears match, output the answer with the smallest rear gear set (similar rules to the front gear set).
输入样例：
2 5
39 62 12 28
输出样例：
39 53
12 13 15 23 27
提示：
The challenge in this problem is "reading the problem". Don't read further if you are working on that level of challenge. If the problem is just completely unclear to you, read in. The problem wants you to find "an optimal set of gear ratios" such that the spacing between the ratios is most uniform. Consider the test case above: 2 539 62 12 28This specifies two front gears from the set 39..62; five rear gears from the set 12..28. The program must examine all possible pairs of 62-39+1=24 front gears and all possible quintuples from 28-12+1=17 rear gears. Combinatorically, The total number of possibilities is (24 take 2) times (17 take 5), which is 24!/22!/2! x 17!/5!/12! which is 656,880 possibilities (I think). For each of these possibilities, calculations like the following. This example considers in some sense the "first" case: front gears of 39 and 40, rear gears of 12, 13, 14, 15, and 16. First, calculate all the possible ratios: 39/12 = 3.2500000000000000000039/13 = 3.0000000000000000000039/14 = 2.7857142857142857142839/15 = 2.6000000000000000000039/16 = 2.4375000000000000000040/12 = 3.3333333333333333333340/13 = 3.0769230769230769230740/14 = 2.8571428571428571428540/15 = 2.6666666666666666666640/16 = 2.50000000000000000000Then, sort them: 39/16 = 2.4375000000000000000040/16 = 2.5000000000000000000039/15 = 2.6000000000000000000040/15 = 2.6666666666666666666639/14 = 2.7857142857142857142840/14 = 2.8571428571428571428539/13 = 3.0000000000000000000040/13 = 3.0769230769230769230739/12 = 3.2500000000000000000040/12 = 3.33333333333333333333Then, calculate the absolute value of the differences: 2.43750000000000000000 - 2.50000000000000000000 = 0.062500000000000000002.50000000000000000000 - 2.60000000000000000000 = 0.100000000000000000002.60000000000000000000 - 2.66666666666666666666 = 0.066666666666666666662.66666666666666666666 - 2.78571428571428571428 = 0.119047619047619047622.78571428571428571428 - 2.85714285714285714285 = 0.071428571428571428572.85714285714285714285 - 3.00000000000000000000 = 0.142857142857142857153.00000000000000000000 - 3.07692307692307692307 = 0.076923076923076923073.07692307692307692307 - 3.25000000000000000000 = 0.173076923076923076933.25000000000000000000 - 3.33333333333333333333 = 0.08333333333333333333Then, calculate the mean and variance of the set of numbers on the right, above. The mean is (I think): 0.0995370370370370370366666. The variance is approximately 0.00129798488416722. Of course this set of gears is not valid, since it does not have a 3x span from highest gear to lowest. Find the set of gears that minimizes the variance and has a 3x or greater span.



题目：王大锤捡肥皂(1817)
时间限制：1000 ms
空间限制：65536 KB
题目描述：
我们WanWanMeiXiangDao的王先森也友情加入了我们的题目描述。
王先森在神的指引下，发现每次shower的时候pickup满一定的数量的soap，不用多久，就会升职加薪、当上总经理、出任CEO、迎娶白富美、走上人生巅峰，他想想觉得十分的激动，于是他来到了浴室。
浴室是长条型的，为了简化问题，我们把浴室看做一个2*n矩形图，有些地方没有人，我们用"."表示，有些地方是有障碍的，人不能在那个点，我们用"#"表示，还有些地方是有人的，用"P"来表示，当然只有在人的位置那里的地上才可能有肥皂，不过凑巧的是这一次所有人脚下都有一块肥皂，每个点可以同时站多个人，同时王大锤他不仅能够朝上下左右4个方向走，而且还能够朝斜对角走，前提自然是到达的位置不能有障碍物，现在王大锤想知道，他能否捡满足够的肥皂呢？
题目输入：
第一行输入一个正整数T(T <= 500)，表示有T组测试数据。
每组测试数据首先输入两个整数n, m(1 <= n <= 512, 1 <= m <= n * 2)，表示浴室是2*n的矩形图和王大锤需要捡的肥皂的数目。
接下来输入2行字符串，仅含有"P"，"."和"#"三种字符，表示这个浴室。
王大锤一开始在最左上角的点，当然也就是最左上角的点不可能是"#"。
题目输出：
对于每组测试数据，如果王大锤不能捡满足够的肥皂，那么输出一行“Bad Luck”，否则输出王大锤至少需要走的步数。
输入样例：
2
3 2
.#P
#P.
5 3
.P##P
..P#.
输出样例：
2
Bad Luck
提示：
对于第一组样例，他需要捡2个肥皂，先右下斜对角走到第一个P，然后右上斜对角又有一个P，所以只需要走2步。
对于第二组样例，一共要捡3个肥皂，王大锤不能到达最右端上面的点，所以不能达到自己的期望。



题目：输出后续遍历(1054)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
已知一个序列的前序和中序遍历，输出他的后序遍历 先输入前序遍历，再输入中序遍历，计算后输出后续遍历。
题目输入：
abc
bac

题目输出：
acb
输入样例：

输出样例：

提示：




题目：Tree-最短点对(1258)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Give a tree with n vertices,each edge has a length(positive integer less than 1001). Define cost(u,v)=The min edge in the path which from node u to node v . Give an integer k,for every pair (u,v) of vertices is called valid if and only if cost (u,v) not exceed k. Write a program that will count how many pairs which are valid for a given tree.
题目输入：
The input contains several test cases. The first line of each test case contains two integers n, q. (n<=10000,q<= 100) The following n-1 lines each contains three integers u,v,l, which means there is an edge between node u and v of length l. Then following q lines each contains one integer k(k>=0).
End of by EOF. 

题目输出：
For each k output the answer on a single line.
输入样例：
5 2
1 2 3
1 3 1
1 4 2
3 5 1
4
0
输出样例：
10
0
提示：




题目：JillRidesAgain(1602)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	Jill likes to ride her bicycle, but since the pretty city of Greenhills where she lives has grown, Jill often uses the excellent public bus system for part of her journey. She has a folding bicycle which she carries with her when she uses the bus for the first part of her trip. When the bus reaches some pleasant part of the city, Jill gets off and rides her bicycle. She follows the bus route until she reaches her destination or she comes to a part of the city she does not like. In the latter event she will board the bus to finish her trip.		Through years of experience, Jill has rated each road on an integer scale of ``niceness.'' Positive niceness values indicate roads Jill likes; negative values are used for roads she does not like. There are not zero values. Jill plans where to leave the bus and start bicycling, as well as where to stop bicycling and re-join the bus, so that the sum of niceness values of the roads she bicycles on is maximized. This means that she will sometimes cycle along a road she does not like, provided that it joins up two other parts of her journey involving roads she likes enough to compensate. It may be that no part of the route is suitable for cycling so that Jill takes the bus for its entire route. Conversely, it may be that the whole route is so nice Jill will not use the bus at all.		Since there are many different bus routes, each with several stops at which Jill could leave or enter the bus, she feels that a computer program could help her identify the best part to cycle for each bus route.
题目输入：
The input file contains information on several bus routes. The first line of the file is a single integer brepresenting the number of route descriptions in the file. The identifier for each route (r) is the sequence number within the data file, . Each route description begins with the number of stops on the route: an integer s,  on a line by itself. The number of stops is followed by s - 1 lines, each line i ( ) is an integer ni representing Jill's assessment of the niceness of the road between the two stops i and i+1.
题目输出：
For each route r in the input file, your program should identify the beginning bus stop i and the ending bus stop j that identify the segment of the route which yields the maximal sum of niceness, m= ni+ni+1+...+nj-1. If more than one segment is maximally nice, choose the one with the longest cycle ride (largest j-i). To break ties in longest maximal segments, choose the segment that begins with the earliest stop (lowest i). For each route r in the input file, print a line in the form:		The nicest part of route r is between stops i and j		However, if the maximal sum is not positive, your program should print:		Route r has no nice parts
输入样例：
3
3
  -1
   6
10
   4
  -5
   4
  -3
   4
   4
  -4
   4
  -5
4
  -2
  -3
  -4
输出样例：
The nicest part of route 1 is between stops 2 and 3
The nicest part of route 2 is between stops 3 and 9
Route 3 has no nice parts
提示：
None



题目：BuyLow,BuyLower(1504)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The advice to "buy low" is half the formula to success in the stock market. But to be considered a great investor you must also follow this problems' advice: "Buy low, buy lower" That is, each time you buy a stock, you must purchase more at a lower price than the previous time you bought it. The more times you buy at a lower price than before, the better! Your goal is to see how many times you can continue purchasing at ever lower prices. You will be given the daily selling prices of a stock over a period of time. You can choose to buy stock on any of the days. Each time you choose to buy, the price must be lower than the previous time you bought stock. Write a program which identifies which days you should buy stock in order to maximize the number of times you buy. By way of example, suppose on successive days stock is selling like this:  Day   1  2  3  4  5  6  7  8  9 10 11 12Price 68 69 54 64 68 64 70 67 78 62 98 87In the example above, the best investor (by this problem, anyway) can buy at most four times if they purchase at a lower price each time. One four day sequence (there might be others) of acceptable buys is: Day    2  5  6 10Price 69 68 64 62
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  N (1 <= N <= 5000), the number of days for which stock prices are available. Line 2..etc:  A series of N positive space-separated integers (which may require more than one line of data) that tell the price for that day. The integers will fit into 32 bits quite nicely.
题目输出：
Two integers on a single line: the length of the longest sequence of decreasing prices the number of sequences that have this length In counting the number of solutions, two potential solutions are considered the same (and would only count as one solution) if they repeat the same string of decreasing prices, that is, if they "look the same" when the successive prices are compared. Thus, two different sequence of "buy" days could produce the same string of decreasing prices and be counted as only a single solution.
输入样例：
12
68 69 54 64 68 64 70 67
78 62 98 87
输出样例：
4 2
提示：




题目：AdvancedFruits(1401)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The company "21st Century Fruits" has specialized in creating new sorts of fruits by transferring genes from one fruit into the genome of another one. Most times this method doesn't work, but sometimes, in very rare cases, a new fruit emerges that tastes like a mixture between both of them. 
A big topic of discussion inside the company is "How should the new creations be called?" A mixture between an apple and a pear could be called an apple-pear, of course, but this doesn't sound very interesting. The boss finally decides to use the shortest string that contains both names of the original fruits as sub-strings as the new name. For instance, "applear" contains "apple" and "pear" (APPLEar and apPlEAR), and there is no shorter string that has the same property. A combination of a cranberry and a boysenberry would therefore be called a "boysecranberry" or a "craboysenberry", for example. 
Your job is to write a program that computes such a shortest name for a combination of two given fruits. Your algorithm should be efficient, otherwise it is unlikely that it will execute in the alloted time for long fruit names.
题目输入：
The company "21st Century Fruits" has specialized in creating new sorts of fruits by transferring genes from one fruit into the genome of another one. Most times this method doesn't work, but sometimes, in very rare cases, a new fruit emerges that tastes like a mixture between both of them. 

A big topic of discussion inside the company is "How should the new creations be called?" A mixture between an apple and a pear could be called an apple-pear, of course, but this doesn't sound very interesting. The boss finally decides to use the shortest string that contains both names of the original fruits as sub-strings as the new name. For instance, "applear" contains "apple" and "pear" (APPLEar and apPlEAR), and there is no shorter string that has the same property. 
A combination of a cranberry and a boysenberry would therefore be called a "boysecranberry" or a "craboysenberry", for example. 

Your job is to write a program that computes such a shortest name for a combination of two given fruits. Your algorithm should be efficient, otherwise it is unlikely that it will execute in the alloted time for long fruit names.

题目输出：
For each test case, output the shortest name of the resulting fruit on one line. If more than one shortest name is possible, any one is acceptable. 
输入样例：
apple peach
ananas banana
pear peach


输出样例：
appleach
bananas
pearch


提示：




题目：Digitgames(1155)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Newfarking and fishhead enjoy playing a mental game. They write down the numbers from 1 to N (1 <= N <= 10) in a certain order and then sum adjacent numbers to produce a new list with one fewer number. They repeat this until only a single number is left. For example, one instance of the game (when N = 4) might go like this: 
    1    2     3     4
      3    5     7
        8     12
           20
Behind Newfarking 's back, fishhead have started playing a more difficult game, in which they try to determine the starting sequence from only the final total and the number N. Unfortunately, the game is a bit above Newfarking 's mental arithmetic capabilities. Write a program to help Newfarking  play the game and keep up with fishhead.
题目输入：
多组数据，文件尾EOF结束。每个样例 Two space-separated integers: N and the final sum
题目输出：
Line 1: An ordering of the integers 1..N that leads to the given sum. If there are multiple solutions, choose the one that is lexicographically least, i.e., that puts smaller numbers first
输入样例：
4 20
输出样例：
1 2 3 4（输出按字典序最小的一组）
提示：




题目：奔跑(1818)
时间限制：5000 ms
空间限制：65536 KB
题目描述：
操场上，王大锤他们班级哒同学正在四处热身，准备接下来哒跑步比赛。万万没想到，这个跑步比赛十分奇怪，大家都知道终点线是一条直线，并且通过坐标原点，但是它哒方向是由裁判员随机决定哒。而且，经过王大锤哒明察暗访，他知道了所有人跑步哒固定速度（假定大家跑步时候都是匀速哒），每个人哒固定速度正好等于他现在所处位置哒x坐标(每个人哒坐标都是正整数)。请问，每当裁判给出终点线方向向量v，并吹哨赛跑，所有童鞋按照自己哒速度尽可能快地往终点线跑，最慢哒那个童鞋耗时多少？
题目输入：
多组样例，以EOF结尾。
第一行，两个整数n m，表示n（1 <= n <= 100000）个童鞋和裁判员哒m (1 <= m <= 100000) 种口令。
下面n行，每行两个正整数，x0 y0，表示n个童鞋热身时候哒坐标。
下面m行，每行两个整数，x1 y1，表示裁判员选择了v向量即（x1，y1）这个方向作为终点线时候。数据保证所有整数的绝对值不大于 100000000
题目输出：
输出在当前终点线确定哒情况下，所有童鞋按照自己哒速度尽可能快地到达终点线，最慢哒那个童鞋所需要哒时间。结果保留2位小数，结果误差在0.01范围之内均可被接受。如果v为零向量，则输出0即可。
输入样例：
2 3
1 1
2 3
1 0
0 1
1 1
输出样例：
1.50
1.00
0.35
提示：
大量输入输出，建议使用scanf和printf。



题目：WarpSpeedII(1703)
时间限制：16000ms
空间限制：65535kb
题目描述：
	In the not-so-distance future, space engineers can inventa new technology for traveling through space and name it as “warp-drive”. Thiswarp-drive can make a spaceship travel faster than light speed. It works bybending an amount of distance in space and make a ship travel through that bendedspace in a single “hop”. To travel through space, a spaceship (that is equippedwith this warp-drive) may have to perform more than one hop between thebeginning and the endingpoints. The amount of energy/power to hop depends on the currentstate/configuration of the warp-drive. And some amount of energy is alsoconsumed in order to prepare or switch to any warp-drive state.	Goal	Suppose that you are an engineer on a battle spaceship.Your duty is to control/configure the warp-drive so that it will consume asless energy as possible for any traveling. For each traveling, you will beprovided with a sequence of hops, which you have to find a corresponding sequenceof warp-drive configurations that use the lowest energy. 	In order to accomplish your duty, you have to build acomputer program to find the lowest energy of warp-drive configuration sequencefor any given hop sequence based on two tables of warp-driver energyconsumptions. The first table shows the energy for switching between any twostates. The second table shows the energy consumption related to warp-drive statesand hops.
题目输入：
	Input is a standard input which consists of 4 parts, separated by a blankline. 	The first part defines the sizes of warp-drive states and hop types. 	l  It contains ofonly one line. This line contains 2 numbers separated by a space. These 2 numberare 	o Size of warp-drivestates(N), which is between 1 and 100. 	²  The state id isstarting from 0 to N-1. 	²  The first state(id #0) is the idle state. At this and only this state, the warp-drive can'tperform any hop. (It is the default starting and ending state for any outputstate sequence.) 	o Size of differenttypes of hops(H), which is between 1 and 1,000. 	²  The hop id from 0 to H-1. 	The second part is a table showing the energy for switching warp-drivestates. The table size is N rows and N columns, which contains N2 energy values. 	l  There are N lines.Each line contains N energy values. These values are between 1 and 100. 	l  Each energy valuecan be indexed by its row and column. The row and column indexes are the stateids of the current and next warp-drive states respectively. Please be notifiedthat these two indexes are starting from 0. 	²  For example, thevalue at (row index, column index) = (5,0) is the energy for witchingwarp-drive state from number 5 to 0. (This value is the first number in the sixthline.) 	The third part is a table showing the energy consumption in performinghops for each state drive.ACM-ICPC Asia Hatyai Regional Programming Contest –November 16, 2012 – PSU, Hatyai 13 	The table size is N rows and H columns, which contains N by H values. 	l  There are N lines. Each line contains H energy values.These values are between 1 and 100. 	l  Each energy valuecan be indexed by its row and its column. The row index is the id of thecurrent warp-drive state. The column index is the id of the hop. Please benotified that these two indexes are starting from 0. 	o For example, thevalue at (row index, column index) = (1,9) is the energy for warp-driveat state #1 to perform hop #9 . (This value is the tenth number in the secondline.) 	o Please be notifiedthat in the very first line of this part, which corresponds to the state #0 orthe idle state, all numbers are zeros. This rather means that it can't performany hop in this state. 	The fourth part is a set of hop sequences. The number of sequences in thisset is between 1 and 1,000. 	l  The number oflines is 1 up to 1,000. 	l  Each line in thispart contains one hop sequences. 	l  The number of hopsin a sequence is between 1 and 1,000. 	l  Each hop is anumber (starting from 0 to H-1) and is separated with space. 	The blank line after the fourth part is the termination of the input. 
题目输出：
	For each hop sequence in the fourth part of the input, write 2 parts ofoutput as follows	l  In the first line,write the total amount of energy which must be minimum.	l  In the followingline, write the solution. The solution contains a sequence of warp-drive statescorresponds to the given hop sequence. (The size of input and output sequence mustbe equal.) If there are two or more possible solutions which consumes the same amountof energy, write only the sequence which contains the lowest states comparing fromleft to right.
输入样例：
4 5
1 2 6 1
3 4 3 17
2 3 9 3
1 21 1 8
0 0 0 0 0
3 3 2 4 3
2 2 4 3 1
4 2 2 7 7
0 4
1 2 3 2

输出样例：
9
3 2
23
1 1 2 3

提示：

	There are 15 lines in the sample input and 4 lines in the sample output. 


	In the first sample output (solution for input line #13), the minimum
total energy is 9. The warp-drive state sequence is [3 2] or [0- 3 2 -0]. There
are 3 state switchings from 0 → 3, 3 → 2, and 2 → 0, which consumes 1 + 1 + 2 =
4. And two hops (0 and 4) at state 3 and 2 respectively, which consumes 4 +1 =
5. So the total energy is 4 + 5 = 9. 


	In the last sample output, the minimum energy is 23. The solution is [0- 1
1 2 3 -0] which draws 23 energy in total. 




题目：洗牌问题(1259)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
When I was in a interview , the interviewer ask me a question : there are n cards(count from 1 to n) , your task is to disorganize these cards as randomly as possible && no card can stay in its original position .Now my problem is if I give out a sequence randomly , what’s probability I can pass the interview.
题目输入：
The input contains several test cases. The first line of each test case contains one integers ct. The following ct lines each contains one integers n (0<=n<=1000000), which means there are n cards.
题目输出：
The output should be one real number per line, shows the probability for each case, round to four decimal places.
输入样例：
2
2
3
输出样例：
0.5000
0.3333
提示：




题目：已知前序和中序求后序(1055)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
鱼头布置了已知前序和中序求后序的作业，可是hp太笨了，所以请你帮他设计一个程序来完成作业。
题目输入：
输入包括两行。
第一行是前序遍历。
第二行是中序遍历。

题目输出：
输入只有一行:后序遍历。
输入样例：
abdhiecfjgklnm
hdibeajfcgnlkm

输出样例：
hidebjfnlmkgca
提示：




题目：CrystalClear(1603)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	A new high technology company hasdeveloped a material that it hopes to market as an insulator. The materialconsists of crystals and the square lattice on which the crystals are grown.The points on the lattice are at 1 centimeter intervals. The crystals areformed from seeds that are planted at the lattice points. Each crystal growsinto a circle of diameter 1 centimeter.	Using this material in applications willrequire cutting the lattice into pieces. One of the problems in cutting the latticeis that some crystals will be sliced in the process. Slicing a crystal otherthan through the center completely destroys that crystal's insulationproperties. (A cut touching a crystal tangentially does not destroy thatcrystal's insulation property.)		The insulation capacity of a piece isdirectly proportional to the total area of the insulating crystals (or parts ofcrystals) that are on the piece. The following figure shows a polygonal piecewith its insulating crystals shaded.		Your job is to determine the insulatingcapacity of such polygonal pieces by computing the total area of the insulatingcrystals in it.
题目输入：
	The input consists of asequence of polygon descriptions. Each description consists of a positiveinteger n ( 3	Vertices of each polygon are given inclockwise order. No polygon will be degenerate. No coordinate will be largerthan 250 in absolute value.	The input is terminated by zero for thevalue of n.
题目输出：
	For each polygon, firstprint its number (`Shape 1', `Shape 2', etc.) and then thearea of the insulating crystals in cm^2, exact to three digits tothe right of the decimal point.	The following sample corresponds to theprevious illustration.
输入样例：
5
0 2
3 5
6 3
6 0
1 0
0

输出样例：
Shape 1
Insulating area = 15.315 cm^2

提示：
None



题目：ThePrimes(1505)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
In the square below, each row, each column and the two diagonals can be read as a five digit prime number. The rows are read from left to right. The columns are read from top to bottom. Both diagonals are read from left to right. +---+---+---+---+---+| 1 | 1 | 3 | 5 | 1 |+---+---+---+---+---+| 3 | 3 | 2 | 0 | 3 |+---+---+---+---+---+| 3 | 0 | 3 | 2 | 3 |+---+---+---+---+---+| 1 | 4 | 0 | 3 | 3 |+---+---+---+---+---+| 3 | 3 | 3 | 1 | 1 |+---+---+---+---+---+ The prime numbers' digits must sum to the same number. The digit in the top left-hand corner of the square is pre-determined (1 in the example). A prime number may be used more than once in the same square. If there are several solutions, all must be presented (sorted in numerical order as if the 25 digits were all one long number). A five digit prime number cannot begin with a zero (e.g., 00003 is NOT a five digit prime number).
题目输入：
There are several test cases, end by EOF, for each test case:A single line with two space-separated integers: the sum of the digits and the digit in the upper left hand corner of the square.
题目输出：
Five lines of five characters each for each solution found, where each line in turn consists of a five digit prime number. Print a blank line between solutions. If there are no prime squares for the input data, output a single line containing "NONE".
输入样例：
11 1
输出样例：
11351
14033
30323
53201
13313
提示：




题目：Quadtree(1402)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
While searching for treasures in an ancient Aztec ruin, Florida Jones (the brother of famous Indiana Jones) stumbles across a papyrus roll lettered with a long string of symbols. There are three different symbols occuring in the string which we will call B, W and Q here.Being somewhat experienced in cryptography, Florida Jones recognizes the code immediately as the famous Quadtree Encoding Scheme that has been invented 3000 years ago. 
With the Quadtree system, secret pictures (like treasure maps) were encoded in the following way: If the whole picture was black, it was encoded by the letter B. If it was completely white, it was encoded by W. If both colors were used (what was usually the case), it was encoded by Qxxxx where each x was a string that recursively encoded one quarter of the picture (in the order top left, top right, bottom left, bottom right). As the Aztecs always used quadratic pictures with n*n pixels where n was a power of two, this method always worked perfectly. A 2*2 chess board, for instance, would be encoded as QWBBW, a 4*4 chess board as QQWBBWQWBBWQWBBWQWBBW. 
Your job is to decode the quadtree string and output the picture in the XBM format (see output specification). 
题目输入：
The input file contains an integer n (8 <= n <= 512) on the first line, giving the size of the picture in pixels per row/column. n will always be a power of two. 
On the second line, a string consisting of the letters B, W and Q follows. The string encodes a picture with n*n pixels with the quadtree scheme. 
题目输出：
On the first line, print "#define quadtree_width n" where n is the picture size given in the input file. 
On the second line, print "#define quadtree_height n" accordingly. 
On the third line, print "static char quadtree_bits[] = {". 
Then, print n lines (each one encoding one pixel row of the picture) with n/8 hexadecimal numbers per line.
Each hexadecimal number is composed of 8 bits that encode 8 pixels from left to right (where the leftmost bit has the value 1 and the rightmost bit has the value 128). The hexadecimal numbers should be printed in the form 0xdd where d is one character of the set { 0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f }. 
Example: The 8 pixels WBBBBWWB would be written as 0x9e. (2+4+8+16+128 = 158 = 0x9e) 
Print a comma after each hexadecimal number. 
On the last line, print "};". 

输入样例：
16
QQWBBWQWBBWQWBBWQWBBW

输出样例：
Note: The comments (enclosed by /* and */) are not part of the output. They should help to explain the XBM format. 
#define quadtree_width 16
#define quadtree_height 16
static char quadtree_bits[] = {
0xf0,0xf0,                       /* WWWWBBBB WWWWBBBB */
0xf0,0xf0,                       /* WWWWBBBB WWWWBBBB */
0xf0,0xf0,                       /* WWWWBBBB WWWWBBBB */
0xf0,0xf0,                       /* WWWWBBBB WWWWBBBB */
0x0f,0x0f,                       /* BBBBWWWW BBBBWWWW */
0x0f,0x0f,                       /* BBBBWWWW BBBBWWWW */
0x0f,0x0f,                       /* BBBBWWWW BBBBWWWW */
0x0f,0x0f,                       /* BBBBWWWW BBBBWWWW */
0xf0,0xf0,                       /* WWWWBBBB WWWWBBBB */
0xf0,0xf0,                       /* WWWWBBBB WWWWBBBB */
0xf0,0xf0,                       /* WWWWBBBB WWWWBBBB */
0xf0,0xf0,                       /* WWWWBBBB WWWWBBBB */
0x0f,0x0f,                       /* BBBBWWWW BBBBWWWW */
0x0f,0x0f,                       /* BBBBWWWW BBBBWWWW */
0x0f,0x0f,                       /* BBBBWWWW BBBBWWWW */
0x0f,0x0f,                       /* BBBBWWWW BBBBWWWW */
};


提示：
The unix tool xv can display graphics in the XBM format.
So, after you have finished your program, run it with "quadtree | xv -" and have a look at the picture. This may help in debugging. 



题目：BinaryMatrix2(1704)
时间限制：5000ms
空间限制：65535kb
题目描述：
	You are given a matrix of size r x c. Each of the elements can be either 0 or 1. In each operation you can flip any element of this matrix, i.e. convert 0 to 1 or convert 1 to 0. Your goal	is to convert the matrix such that -	1. Each of the rows will have the same number of 1s and	2. Each of the columns will have the same number of 1s.	What is the minimum number of operations required to achieve this?
题目输入：
	Input starts with a positive integer T (~1000) which indicates the number of inputs.	Each case starts with two integers m and n (1 <= r, c <= 40), here r is the number of rows and c is the number of columns of the matrix. Each of the next m lines will have n integers each,	either 0 or 1.
题目输出：
	For each test case, output “Case #: R” in a single line, where # will be replaced by case number and R will be replaced by the minimum number of steps required to achieve the target matrix. Replace R by -1 if it is not possible to reach target matrix.		 
输入样例：
3
2 3
111
111
3 3
011
011
011
2 3
001
000

输出样例：
Case 1: 0
Case 2: 3
Case 3: 1

提示：
None



题目：无聊的游戏(1819)
时间限制：3000 ms
空间限制：65536 KB
题目描述：
生活不是时时刻刻都充满fun，无聊的时候该如何是好呢？Azores选择玩无聊的游戏来打发时间。这个游戏有多无聊呢？让我们来看看：
在一张白纸上随机洒落n个硬币并标号为1...n，选择一些硬币，用铅笔在他们之间划线。
然后进行三种操作：
    1、add_line(u,v)硬币u和硬币v之间划一条线。
    2、del_line(u,v)擦去硬币u和硬币v之间的线并翻转u和v。
    3、count_coin_upside(u)回答与硬币u相连的硬币中有多少个是正面向上的。
Cabbage觉得Azores一直玩这个游戏脑子会瓦塌掉的，想编一个程序秒杀这个游戏，但是他仔细想了想后觉得这个问题并不是很简单，你能帮他搞定么？
题目输入：
多个测试样例，数据以EOF结尾。每个测试样例第一行是三个整数n,m,q(1 <= n <= 50000; 1 <= m <= 150000; 1 <= q <= 250000)分别表示有多少个硬币，开始有多少硬币间有连线，询问的次数。
第二行有n个整数，0表示第i个硬币是反面向上，1表示第i个硬币是正面向上。

接下来m行每行有两个整数u,v(1 <= u, v <= n)表示硬币u和硬币v之间连线。

接下来q行表示q个操作，格式如下：
"A u v"(1 <= u, v <= n)表示add_line(u,v)
"D u v"(1 <= u, v <= n)表示del_line(u,v)
"C u"(1 <= u <= n)表示count_coin_upside(u)
题目输出：
对于每个count_coin_upside(u)操作，输出与硬币u相连的硬币中有多少个是正面向上的。
输入样例：
6 6 5
0 1 0 1 1 1
1 2
2 3
3 4
2 4
3 5
5 6
C 6
D 3 5
C 6
A 4 6
C 4
输出样例：
1
0
3
提示：
大量输入输出，建议使用scanf和printf。



题目：Thebeautifullovestorymustbeaccomplishedbyyou!(1156)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
There,in the dark,damp small house once lived a beautiful girl named Fang.who was trapped by her evil-minded beast.For hundreds of thousands of years,many handsome boys go to her rescue,but with no help.According to some elders,this problem could be solved by a small c++ programme,but they are too old for such a programme,.Now,you handsome boys, I think you have already have the solution for such a problem and can get the beautiful girl out of the mummy.   One of the kind guard of the penetralium draw a M*N square blow(0<M,N<21)to represant the enterance,you are at the start "2",each "1"for a wall,and each "0"for a flexible way out,the number "6"represant the exit.But the bad beast have already think of the condition,so,he made an time bomb for every adventures.Only if you find the shortest way out ,otherwise you will have the risk of being killed by the bomb.   Come on ! go to find you love in accomplishing the beautiful story and get the love ofthe bautiful girl!Wish you guys good luck!
题目输入：
Interger M ,N ,and the map of the penetralium consists of "1"s  and"0"s.
题目输出：
Find the best way out ,and print the step of your path.(But just keep in mind that the path should be the optimal choice in the type "int"!)
if you can't find the path print"Tragedy!"

输入样例：
7   8
2 0 1 0 0 0 1 0
0 0 0 1 1 0 0 0
1 1 0 0 0 1 1 1
1 0 0 1 0 0 0 0
0 1 0 0 0 0 1 1
1 0 0 0 1 0 0 0
1 0 0 1 0 1 0 6
输出样例：
Tragedy!
提示：




题目：Zlly比较懒(1260)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Zlly比较懒，他需要从坐标（0,0）处移动到一个给出的坐标处，他走路姿势很奇怪，他只能走某些固定的步长，然后他有8个方向，就像骑士那个样子跳。假设某种步长为n，他可以从(0, 0)走到 (n, 1), (n, -1), (-n, 1), (-n, -1), (1, n), (-1, n), (1, -n) 或者 (-1, -n)。现在他想确定下他可不可以走到，如果不可以，他就不走了，所以现在这个问题就交给聪明的你了。
题目输入：
Line 1：步子数n（n<=100）
Line 2：每种步子步长（ai<=1,000,000,000）
Line 3：横坐标x和纵坐标y（-1,000,000,000<=x,y<=1,000,000,000）;
输入文件有多case
题目输出：
Yes or No
输入样例：
10
1 2 3 4 5 6 7 8 9 10
-30 27
输出样例：
Yes
提示：




题目：前序、中序转变为后序遍历(1056)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
二叉树是一个使用且有趣的数据结构，在其应用中，常要求在在树种查找没肿特征的结点，或逐个进行处理，这就提出了遍历二叉树的问题，其中遍历又可以分为前序、中序和后序遍历，于是在学习过程中，我遇到了一个问题，我们能否根据所给出的前序和中序遍历，将其转换为后序遍历呢？烦请那位高手帮我解决这个问题。
题目输入：
第一行输入一个整数t，表示cases ；对于每个case ，包括2行，分别输入前序，中序遍历(字符串长度在1到1000000之间)。
题目输出：
输出后序遍历
输入样例：
2
FCADBEGHP
ACBDFEHGP
	
HDACBGFE
ADCBHFEG

输出样例：
ABDCHPGEF
ABCDEFGH


提示：
None



题目：LeadorGold(1604)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	How to make gold from lead has baffled alchemists for centuries. At the last Alchemists Club Meeting (ACM), a sensational breakthrough was announced. By mixing the three chemicals Algolene, Basicine and Cobolase in the correct ratio, one can create a mixture that transforms lead into gold. Since Algolene, Basicine and Cobolase (or A, B, C for short) are generally not sold individually, but rather mixed into solutions, this may not be easy as it seems.	Consider the following example. Two mixtures of Algolene, Basicine and Cobolase are available, in weights 1:2:3 and 3:7:1, respectively. By mixing these solutions in a ratio of 1:2 we obtain a solution of A, B, C with weights 7:16:5. But there is no way to combine these mixtures into a new one with weights 3:4:5. If we additionally had a solution of weights 2:1:2, then a 3:4:5 mixture would be possible by combining eight parts of 1:2:3, one part of 3:7:1 and five parts of 2:1:2. As you see in both examples, weights for each component must be integers.	Determining which mixing weights we can obtain from a given set of solutions is no trivial task. But, as the ACM has shown, it is possibly a very profitable one. You must write a program to find mixing ratios.
题目输入：
The input file contains several test cases. The first line of each test case contains an integer n ( 0n < 100) that represents the number of mixtures in the test case. The next n lines each contain three non-negative integers ai, bi, ci, specifying the weights ai : bi : ci of A, B, C in the i-th mixture. At least one of these integers is not 0 for each mixture, and none of them will be greater than 15000.	Finally, there is one line containing three non-negative integers a, b, c, which specify the weights a : b : cin the desired solution. At least one of these integers is not 0.	The input file is terminated with the integer `0' on a line by itself following the last test case.
题目输出：
For each test case, output the word `Mixture', followed by the ordinal number of the test case. On the next line, if it is possible to obtain the desired solution by mixing the input solutions, output the word `Possible'. Otherwise, output the word `Impossible'. Print a blank line between consecutive test cases.
输入样例：
2
1 2 3
3 7 1
3 4 5
3
1 2 3
3 7 1
2 1 2
3 4 5
0
输出样例：
Mixture 1
Impossible

Mixture 2
Possible
提示：
None



题目：StreetRace(1506)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Figure 1 gives an example of a course for a street race. You see some points, labeled from 0 to N (here, N=9), and some arrows connecting them. Point 0 is the start of the race; point N is the finish. The arrows represent one-way streets. The participants of the race move from point to point via the streets, in the direction of the arrows only. At each point, a participant may choose any outgoing arrow. 
Figure 1: A street course with 10 points A well-formed course has the following properties: Every point in the course can be reached from the start. The finish can be reached from each point in the course. The finish has no outgoing arrows. A participant does not have to visit every point of the course to reach the finish. Some points, however, are unavoidable. In the example, these are points 0, 3, 6, and 9. Given a well-formed course, your program must determine the set of unavoidable points that all participants have to visit, excluding start and finish. Suppose the race has to be held on two consecutive days. For that purpose the course has to be split into two courses, one for each day. On the first day, the start is at point 0 and the finish at some `splitting point'. On the second day, the start is at this splitting point and the finish is at point N. Given a well-formed course, your program must also determine the set of splitting points. A point S is a splitting point for the well-formed course C if S differs from the star t and the finish of C, and the course can be split into two well-formed courses that (1) have no common arrows and (2) have S as their only common point, with S appearing as the finish of one and the start of the other. In the example, only point 3 is a splitting point.
题目输入：
There are several test cases, end by EOF, for each test case:The input file contains a well-formed course with at most 50 points and at most 100 arrows. There are N+2 lines in the file. The first N+1 lines contain the endpoints of the arrows that leave from the points 0 through N respectively. Each of these lines ends with the number -2. The last line contains only the number -1.
题目输出：
Your program should write two lines. The first line should contain the number of unavoidable points in the input course, followed by the labels of these points, in ascending order. The second line should contain the number of splitting points of the input course, followed by the labels of all these points, in ascending order.
输入样例：
1 2 -2
3 -2
3 -2
5 4 -2
6 4 -2
6 -2
7 8 -2
9 -2
5 9 -2
-2
-1
输出样例：
2 3 6
1 3
提示：




题目：DoTheyMatchWell?(1157)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Long long ago,there was a man named Watermelon who was a single man.Once he met a very beatiful girl and fell in love with her in the first sight.Mr.Watermelon's friends were very happy with it.They were eager to see him get rid of single.They were always talking a lot about it around Mr.Watermelon.He felt very troubled.So  he gave them a problem to solve.They wanted to finish it qucikly so that they were abled to  continuing talking around Mr.Watermelon.Could you help them to write a program to solve it?Mr.Watermelon gave them serveral lines of  parentheses.Their job was to find out if the  parentheses match well.Each line starts with a '#',ends with a '#' and includes three kings of  parentheses,which are '{','}','(',')','[',']'.If the lines are "#({(()[]){}()}[])#",they match well,if the lines are "#()[]}))[}{()))[]#",they do not match well.
题目输入：
There are several lines(no more than 50) of the input contains many parentheses which all start with a '#' and end with a '#'.The length of each line is no more than 100.

题目输出：
If the line's parentheses match well,just print:"They match well."If not,print:"They do not match well."
输入样例：
2
#({(()[]){}()}[])#
#()[]}))[}{()))[]#
输出样例：
They match well.
They do not match well.
提示：




题目：FromDusktillDawn(1403)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Vladimir has white skin, very long teeth and is 600 years old, but this is no problem because Vladimir is a vampire. Vladimir has never had any problems with being a vampire. In fact, he is a very successful doctor who always takes the night shift and so has made many friends among his colleagues. He has a very impressive trick which he shows at dinner partys: He can tell tell blood group by taste. Vladimir loves to travel, but being a vampire he has to overcome three problems. 

First, he can only travel by train because he has to take his coffin with him. (On the up side he can always travel first class because he has invested a lot of money in long term stocks.) 
Second, he can only travel from dusk till dawn, namely from 6 pm to 6 am. During the day he has to stay inside a train station. 
Third, he has to take something to eat with him. He needs one litre of blood per day, which he drinks at noon (12:00) inside his coffin. You should help Vladimir to find the shortest route between two given cities, so that he can travel with the minimum amount of blood. (If he takes too much with him, people will ask funny questions like "What do you do with all that blood?") 
题目输入：
The first line of the input will contain a single number telling you the number of test cases. 
Each test case specification begins with a single number telling you how many route specifications follow. 
Each route specification consists of the names of two cities, the departure time from city one and the total travelling time. The times are in hours. Note that Vladimir can't use routes departing earlier than 18:00 or arriving later than 6:00. 
There will be at most 100 cities and less than 1000 connections. No route takes less than one hour and more than 24 hours. (Note that Vladimir can use only routes with a maximum of 12 hours travel time (from dusk till dawn).) All city names are shorter than 32 characters. 
The last line contains two city names. The first is Vladimir's start city, the second is Vladimir's destination. 
题目输出：
For each test case you should output the number of the test case followed by "Vladimir needs # litre(s) of blood." or "There is no route Vladimir can take." 
输入样例：
2
3
Ulm Muenchen 17 2
Ulm Muenchen 19 12
Ulm Muenchen 5 2
Ulm Muenchen
10
Lugoj Sibiu 12 6
Lugoj Sibiu 18 6
Lugoj Sibiu 24 5
Lugoj Medias 22 8
Lugoj Medias 18 8
Lugoj Reghin 17 4
Sibiu Reghin 19 9
Sibiu Medias 20 3
Reghin Medias 20 4
Reghin Bacau 24 6
Lugoj Bacau

输出样例：
Test Case 1.
There is no route Vladimir can take.
Test Case 2.
Vladimir needs 2 litre(s) of blood.

提示：




题目：简单的2048(1820)
时间限制：1000 ms
空间限制：65536 KB
题目描述：
Gabriele Cirulli 最近灵感爆发，写了一款游戏，它的游戏规则是这样的：
  
  1.  在一个4x4的方格内，开始先随机出现两个数字，出现的数字仅可能为2或4。
  2.  玩家可以选择上下左右四个方向，如果方格内的数字出现位移或者合并，我们视为有效移动。
  3.  玩家选择的方向上如果有相同的数字就进行合并, 新数字为原来两数字之和，每次有效移动可以同时合并，但不可以连续合并。
  4.  玩家选择的方向上如果有空格（我们表示为0）则产生位移，由空格后方的非空格元素填补。
  5.  每次有效移动一步，方格的空位处随机出现一个数字，可能为2或4。
  6.  方格被数字填满且无法进行有效移动，玩家失败，游戏结束。
  7.  方格上出现2048，玩家胜利，游戏结束。
  8.  例如，一次左移：
  2 2 2 2     4 4 0 0
  8 2 2 0  => 8 4 0 0
  0 2 2 2     4 2 0 0
  0 4 2 2     4 4 0 0

主程序已经基本完成，可是粗心的Gabriele Cirulli漏写了判定玩家失败的函数，聪明的你想在他上洗手间的时间给他一个惊喜，于是你掏出键盘，默默地完成了判定失败函数。
题目输入：
多Case，以EOF结束。
每个Case是一个4x4的数字矩阵，所有的数字均是2的幂次方或者0，0表示该位没有数字，并且所有数字均小于2048。
此数字矩阵即为玩家游戏过程中可能出现的局面。
题目输出：
使用你刚刚完成的判定函数判断当前局面玩家是否失败。如果失败，输出“Game over!", 否则输出"Continue!"。
输入样例：
2 2 2 2
8 2 2 0
0 2 2 2
0 4 2 2

2 4 8 16
4 8 16 32
8 16 32 64
16 32 64 128
输出样例：
Continue!
Game over!
提示：
如果你不知道如何判断以EOF结束，可以参考下面的代码：// n是你输入的第一个数字
C++
while (cin >> n)
{
...
}

C/C++
while (scanf("%d", &n) != EOF)
{
...
}




题目：ProbabilityThroughexperiment(1705)
时间限制：2000ms
空间限制：65535kb
题目描述：
	Mathematicians have often solved problems by just doing some simulation or experiments. For example, the value of pi (π) can be approximately determined by randomly plotting points in a square that inscribes a circle. Because if the square is a 250x250 square, then its area is 62500 and the area of the inscribed circle is pi*1252=15625pi. As the points are plotted randomly, so it can be assumed that number of points inside the circle and total number points plotted in the square is proportional to their respective area. So, in this way, the value of pi can approximately be determined by counting how many points are inside the circle (Figure 1). The value of pi can even be determined using a more sophisticated experiment like the Buffon’s needle experiment (Figure 2).		The two experiments mentioned above to approximately determine the value of pi could be simulated by writing a computer program very easily. It would have been nice to do this sort of experiment a lot of time (Say 1 billion billion) and get an almost perfect result but for lack of time we cannot do that in real life. In this problem, you will have to write a program that will help Professor Wu to perform a similar sort of experiment but this program may not be that straightforward.	Professor Neal Wu is trying to solve a classic problem using simulation: If three points are randomly plotted on the boundary of a circle, then what is the probability that they will be the three vertex of an acute triangle? Of course, this problem can be solved analytically and the result he gets is 0.25. Now, he wants to verify this result through an experiment. The result can be found approximately by plotting three random points on a circle billions of times and counting how many times these three points form an acute triangle. The beauty of such an experiment (as mentioned above) is that if we increase the number of trials, the result will become even more accurate. But if Dr. Wu wants to repeat this process 1000 billion times, it will take 2 hours of time and if he wants to repeat it a billion billion times, it may take more than 200 years. Dr. Wu has discovered that this process can be sped up by using a different approach – generate n random points on the boundary of a circle and they form 6/n(n −1)(n − 2) triangles as vertices. How many of these triangles are acute triangles? If the number of acute triangle is M and let N = 6/n(n −1)(n − 2) , then the desired probability is N/M . So,given the n points on the boundary, you have to assist Dr. Wu by writing a very efficient program to find the number of acute triangles	.
题目输入：
	The input file contains around 40 test cases. But most of the cases are not extreme, so the size of the input file is around 3 MB. The description of each test case is given below:	Each case starts with two positive integers n (0 < n ≤ 20000) and r (0 < r ≤ 500). Here, n is the total of points on the circle boundary and r is the radius of the circle. The center of the circle is always at the origin (0,0). Each of the next N lines denotes the location of one point on the  oundary of the circle. Each point is P, denoted by a floating-point number θ (0.000 ≤ θ < 360.000). This θ is actually the angle (expressed in degree) the point P creates at the center of the circle with the positive direction of x-axis. So the Cartesian coordinate of P is ( r*cos(θ), r*sin(θ)). Value of θ will always have exactly three digits after the decimal	point. No two points will be at the same location. A line containing two zeroes terminates the input. This line should not be processed.
题目输出：
	Each test case produces one line of output. This line contains the serial of output followed by an integer. This integer denotes how many of the 6/n(n −1)(n − 2) triangles formed by these n points are actually acute triangles.
输入样例：
4 71
234.600
33.576
20.375
84.908
7 7
11.586
114.435
248.411
108.640
287.629
150.224
340.481
0 0

输出样例：
Case 1: 2
Case 2: 12

提示：
None



题目：PageSelectionbyKeywordMatching(1605)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	Anyone who has used the World Wide Web isfamiliar with search engines used to find pages matching a user- generatedquery. Many of these engines are quite sophisticated, using advanced algorithmsand parallel searching techniques to provide fast, accurate responses.	This problem is somewhat simpler. A groupof web pages has been classified by associating a list of keywords, given indecreasing order of relevance, with each page (i.e., the order of keywords isfrom the most specific keyword to the least specific). For example, a page onprogramming in Smalltalk has the keywords Smalltalk, programming, and computersin that order; the most relevant keyword is Smalltalk.	Queries also include a list of keywords,again from most to least relevant. For example, in a query consisting of thekeyword Smalltalk followed by the keyword computers, Smalltalk is moreimportant than computers.	In this problem you are to determine thetop five (or fewer) pages that match each of an arbitrary number of queries. Todetermine the strength of the relationship between a query and a web page,assume the keywords for each page and each query are assigned integer weights,in descending order, starting with N, where N is the maximum number of keywords allowedfor a web page and query. The strength of the relationship is the sum of theproducts of the weights associated with each keyword that appears both in theweb page list and the query list. For example, assume the following web pagesand keyword lists:	Page 1:	Smalltalk, programming, computers	Page 2:	computers, programming	Page 3:	computers, Smalltalk	For N equal 8, a query with keywords Smalltalkand programming in that order yields a strength rating of 113 for Page 1 (8*8 +7*7), 49 for Page 2 (7*7), and 56 for Page 3 (8*7). A query with keywordsSmalltalk and computers yields a strength rating of 106 for Page 1 (8*8 + 7*6),56 for Page 2 (7*8), and 112 for Page 3 (8*7 + 7*8).
题目输入：
	Input data consist of one line for each web page and query. A line consists of a code letter followed by a list of keywords. Code letters P, Q, and E denote a page, a query, and the end of file respectively. Code letters and keywords are separated by at least one space. P's and Q's may occur in any order. Pages are added sequentially starting with one. Each page has at least one but no more than 8 keywords. Each word consists of no more than 20 alphabetic characters. The case of characters in the keywords is not significant. There will be a maximum of 25 pages in the input.Each query also has of a list of between one and eight keywords. Again, a keyword has no more than 20 alphabetic characters, case being insignificant. Number the queries sequentially starting with one.
题目输出：
	For each query, identifythe 5 (or fewer) pages read so far that are most relevant to the query. Print asingle line containing the query identifier, a colon, and the page identifiersof the five most relevant pages in the decreasing order of relevance. Pageidentifiers consist of the letter `P' followed by the page number. Queryidentifiers consist of the letter `Q' followed by the query number. Ifseveral pages have the same relevance, list them by increasing page number. Donot list pages that have no relationship (zero strength), even if fewer thanfive pages are identified.
输入样例：
P Smalltalk programming computers
P computers programming
P computers Smalltalk
P FORTRAN programming
P COBOL programming
P programming
Q Smalltalk
Q programming
Q computers
Q Smalltalk computers
Q Smalltalk programming
Q cooking French
E

输出样例：
Query Pages
Q1:   P1 P3
Q2:   P6 P1 P2 P4 P5
Q3:   P2 P3 P1
Q4:   P3 P1 P2
Q5:   P1 P3 P6 P2 P4
Q6:

提示：
None



题目：Josephus(1261)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The Josephus problem is the following game: N people, numbered 1 to N, are sitting in a circle. Starting at person 1, a hot potato is passed. After M passes, the person holding the hot potato is eliminated, and the game continues with the person who was sitting after the eliminated person picking up the hot potato. The last remaining person wins.    Now, given N and the last remaining person's id, what is M?
题目输入：
Every line has two integers: n(2 <= n <= 200) and id(1 <= id <= n). Input is terminated by EOF.
题目输出：
For each input line, output one line containing M. If there are more than one M satisfying the request, output the smallest.

输入样例：
3 1
3 2
输出样例：
5
3
提示：




题目：ShuttlePuzzle(1507)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The Shuttle Puzzle of size 3 consists of 3 white marbles, 3 black marbles, and a strip of wood with 7 holes. The marbles of the same color are placed in the holes at the opposite ends of the strip, leaving the center hole empty. INITIAL STATE: WWW_BBB GOAL STATE: BBB_WWWTo solve the shuttle puzzle, use only two types of moves. Move 1 marble 1 space (into the empty hole) or jump 1 marble over 1 marble of the opposite color (into the empty hole). You may not back up, and you may not jump over 2 marbles. A Shuttle Puzzle of size N consists of N white marbles and N black marbles and 2N+1 holes. Here's one solution for the problem of size 3 showing the initial, intermediate, and end states: WWW BBBWW WBBBWWBW BBWWBWB BWWB BWBW BWBWB WBWBWBBW WBWBBWBW WBBWBWBW BWBWB WBWB BWWB BWBWWBB WBWWBBBW WWBBB WWWWrite a program that will solve the SHUTTLE PUZZLE for any size N (1 <= N <= 12) in the minimum number of moves and display the successive moves, 20 per line.
题目输入：
There are several test cases, end by EOF, for each test case:A single line with the integer N.
题目输出：
The list of moves expressed as space-separated integers, 20 per line (except possibly the last line). Number the marbles/holes from the left, starting with one. Output the the solution that would appear first among the set of minimal solutions sorted numerically (first by the first number, using the second number for ties, and so on).
输入样例：
3
输出样例：
3 5 6 4 2 1 3 5 7 6 4 2 3 5 4
提示：




题目：前序题目(1057)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
输入一串字符串(个数小于1000)表示一棵树型结构的前序遍历,同时再输入对应的中序.遍历字符串,输出其后续遍历字符串【注，所有编号‘abcd等’是按层排序编号】
题目输入：

题目输出：

输入样例：
abdecfg（前序）	dbeafcg（中序）
输出样例：
debfgca
提示：




题目：N*M-1数码(1821)
时间限制：3000 ms
空间限制：65536 KB
题目描述：
大家都做过8数码和15数码问题吧，今天咱们来个更加高端点的，N*M-1数码。
首先介绍数码移动规则，我们记录X表示空位，其余由1~M*N-1这些不同的数字表示序号，现在给你一个乱序的数码排列，你要移动到一个从上到下、自左向右的一个从小到大的数码排列，并且X最终在右下角。
你有以下的移动方式，我们以一个简单的八数码为例。
	1 2 3     1 2 3
	4 X 5 --> 4 5 X	记为R(Right, 向右)
	7 8 6     7 8 6
	
	1 2 3     1 2 3
	4 X 5 --> X 4 5 记为L(Left, 向左)
	7 8 6     7 8 6

	1 2 3     1 X 3
	4 X 5 --> 4 2 5	记为U(Up, 向上)
	7 8 6     7 8 6

	1 2 3     1 2 3
	4 X 5 --> 4 8 5 记为D(Down, 向下)
	7 8 6     7 X 6

对于上面的情况，需要经过操作“RD”，就到达了我们需要的状态。
题目输入：
第一行一个数字T(T <= 2014)，表示有T组测试数据。
每组测试数据，输入两个整数n和m(1 <= n, m <= 10)，表示有n行m列
下面n行，每行m个数字，分别是1~n*m-1的一种排列，并且，0表示空位。
题目输出：
每组测试数据，第一行输出一个整数，表示转移步数(不超过30000步)。
第二行输出一个只包含“L, R, U, D”的字符串。
数据保证所有的情况都有解，如果一步都不用转移，请输出一个0和一个空行，请不要输出多余的字符和空行。
输入样例：
3
3 4
1 2 3 4
5 6 7 8
0 9 10 11
1 1
0
4 3
1 2 3
4 5 6
7 0 9
10 8 11
输出样例：
3
RRR
0

2
DR
提示：




题目：EuroCup2000(1404)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
As you maybe know, the qualification for the European Soccer Championship 2000 is a tournament where in each group each team plays against each other team twice. Germany is in group 3 together with Turkey, Finland, Moldova and Northern Ireland. 14 games have been played and 6 are still to come. (See attachment.)A quick look at the current standings might make you think that Northern Ireland is already out of the race. But that's wrong! Imagine Northern Ireland wins their three remaining games, Germany plays remis against Turkey and loses against Finland, and Moldova defeats Turkey. Then Northern Ireland is number one! 
For those who are not familiar with the scoring model: In each game a team gains 3 points for a victory, 1 point for a remis or 0 points for a loss. After all games have been played, teams are ranked according to points. In case of a tie, the additional tie breakers are: goal difference (i.e. goals scored - goals against), goals scored, and random choice, in that order. 
The question your program should answer is:Regarding all possibilities of how the remaining games could end, what is the highest and lowest possible rank of each team in the group after the tournament is over? 
题目输入：
The input will consist of one or more test cases. Each test case adheres to the following format: 
On the first line there will be one integer n (1 <= n <= 20), representing the number of teams in the group.

On the next n lines, the names of the teams will follow. Names are always shorter than 30 characters and do not contain whitespace.

On the next line, there will be an integer g, representing the number of completed games.

Finally, g lines will follow, each one describing one completed game in the form team1 team2 goals1 goals2.

You may further assume that at most 10 games will be remaining and each team has at least one remaining game to play. (This simplifies the problem a little.) 
Input will be terminated by a value of zero (0) for n.
题目输出：
For each test case, first print a line saying "Group #x" where x is the number of the test case (counting from 1).
Then, print one line per team in the order they appear in the input. On each line, print the team's name, a blank character, its best possible rank, a minus sign and its worst possible rank. 
Print a blank line after each test case, even after the last one. 
输入样例：
2
A
B
1
A B 1 0
5
Ger
Tur
Fin
Nor
Mol
14
Fin Mol 3 2
Tur Nor 3 0
Tur Ger 1 0
Nor Fin 1 0
Mol Ger 1 3
Tur Fin 1 3
Nor Mol 2 2
Nor Ger 0 3
Tur Mol 2 0
Ger Fin 2 0
Mol Fin 0 0
Ger Mol 6 1
Fin Tur 2 4
Mol Nor 0 0


输出样例：
Group #1
A 1-2
B 1-2

Group #2
Ger 1-3
Tur 1-3
Fin 1-4
Nor 1-5
Mol 4-5

提示：




题目：VersionControlledIDE(1706)
时间限制：8000ms
空间限制：524287 kb
题目描述：
	Programmers use version control systems to manage files in their projects, but in these systems,versions are saved only when you manually submit.	Can you implement an IDE that automatically saves a new version whenever you insert or delete a string?	Positions in the buffer are numbered from 1 from left to right. Initially, the buffer is empty and in version 0. Then you can execute 3 commands (vnow means the version before executing the command, and L[v] means the length of buffer at version v):	1 p s: insert string s after position p(0<=p<=L[vnow], p=0 means insert before the start of the buffer). s contains at most 1 and at most 100 letters.	2 p c: remove c characters starting at position p(p>=1, p+c<=L[vnow]+1). The remaining charactesr (if any) will be shifted left, filling the blank	3 v p c: print c characters starting at position p(p>=1, p+c<=L[v]+1), in version v(1<=v<=vnow).	The first command is guaranteed to be command 1(insert). After executing each command 1 or 2, version is incremented by 1.
题目输入：
	There is only one test case. It begins with a single integer n (1<=n<=50,000), the number of commands.	Each of the following n lines contains a command. The total length of all inserted string will not exceed 1,000,000.
题目输出：
	Print the results of command 3, in order. The total length of all printed strings will not exceed 200,000.
输入样例：
6
1 0 abcdefgh
2 4 3
3 1 2 5
3 2 2 3
1 2 xy
3 3 2 4

输出样例：
bcdef
bcg
bxyc

提示：

	In order to prevent you from preprocessing the command, we adopt the following obfuscation scheme:


	Each type-1 command becomes 1 p+d s


	Each type-2 command becomes 2 p+d c+d


	Each type-3 command becomes 3 v+d p+d c+d


	Where d is the number of lowercase letter 'c' you printed, before processing this command. After the obfuscation, the sample input would be:


	6


	1 0 abcdefgh


	2 4 3


	3 1 2 5


	3 3 3 4


	1 4 xy


	3 5 4 6


	This is the real input that your program will read.




题目：Catvs.Dog(1158)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
The latest reality show has hit the TV: “Cat vs. Dog”. In this show, a bunch of cats and dogs compete for the very prestigious BEST PET EVER title. In each episode, the cats and dogs getto show themselves off, after which the viewers vote on which pets should stay and which should be forced to leave the show. 
	Each viewer gets to cast a vote on two things: one pet which should be kept on the show, and one pet which should be thrown out. Also, based on the universal fact that everyone is either a cat lover (i.e. a dog hater) or a dog lover (i.e. a cat hater), it has been decided that each vote must name exactly one cat and exactly one dog.
	Ingenious as they are, the producers have decided to use an advancement procedure which guarantees that as many viewers as possible will continue watching the show: the pets that get to stay will be chosen so as to maximize the number of viewers who get both their opinions satisfied. Write a program to calculate this maximum number of viewers.
题目输入：
On the first line one positive number: the number of testcases, at most 100. After that per
testcase:
• One line with three integers c, d, v (1 <= c, d <= 100 and 0 <= v <= 500): the number of
cats, dogs, and voters.
• v lines with two pet identifiers each. The first is the pet that this voter wants to keep,
the second is the pet that this voter wants to throw out. A pet identifier starts with one
of the characters ‘C’ or ‘D’, indicating whether the pet is a cat or dog, respectively. The
remaining part of the identifier is an integer giving the number of the pet (between 1
and c for cats, and between 1 and d for dogs). So for instance, “D42” indicates dog
number 42.

题目输出：
Per testcase:
• One line with the maximum possible number of satisfied voters for the show.

输入样例：
2
1 1 2
C1 D1
D1 C1
1 2 4
C1 D1
C1 D1
C1 D2
D2 C1

输出样例：
1
3

提示：




题目：前序中序(1058)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
根据前序和后序 遍历的结果 先建树 再输出后序遍历的结果。
（输入的可以是数字和字母）
题目输入：

题目输出：

输入样例：
24b1a3
b4123a
输出样例：
b 1 4 3 a 2
提示：




题目：PollutantControl(1508)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
It's your first day in Quality Control at Merry Milk Makers, and already there's been a catastrophe: a shipment of bad milk has been sent out. Unfortunately, you didn't discover this until the milk was already into your delivery system on its way to stores. You know which grocer that milk was destined for, but there may be multiple ways for the milk to get to that store. The delivery system is made up of a several warehouses, with trucks running from warehouse to warehouse moving milk. While the milk will be found quickly, it is important that it does not make it to the grocer, so you must shut down enough trucks to ensure that it is impossible for the milk to get to the grocer in question. Every route costs a certain amount to shut down. Find the minimum amount that must be spent to ensure the milk does not reach its destination, along with a set of trucks to shut down that achieves this goal at that cost.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  Two space separated integers, N and M. N (2 <= N <= 32) is the number of warehouses that Merry Milk Makers has, and M (0 <= M <= 1000) is the number of trucks routes run. Warehouse 1 is actually the productional facility, while warehouse N is the grocer to which which the bad milk was destined.  Line 2..M+1:  Truck routes: three space-separated integers, Si, Ei, and Ci. Si and Ei (1 <= Si,Ei <= N) correspond to the pickup warehouse and dropoff warehouse for the truck route. Ci (0 <= Ci <= 2,000,000) is the cost of shutting down the truck route.
题目输出：
The first line of the output should be two integers, C and T. C is the minimum amount which must be spent in order to ensure the our milk never reaches its destination. T is the minimum number of truck routes that you plan to shut down in order to achive this goal. The next T lines sould contain a sorted list of the indexes of the truck routes that you suggest shutting down. If there are multiple sets of truck routes that achieve the goal at minimum cost, choose one that shuts down the minimum number of routes. If there are still multiple sets, choose the one whose initial routes have the smallest index.
输入样例：
4 5
1 3 100
3 2 50
2 4 60
1 2 40
2 3 80
输出样例：
60 1
3
提示：




题目：斯诺克(1262)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
lmm333和ltj是好朋友，他们喜欢一起打斯诺克放松，因为lmm333是个高手，总是能在两杆内清台，所以如果ltj后手，她就只有一次击球机会了。因此，为了避免白打一场，ltj要在击球之前判断台面上最多和最少还有多少分（如果赢不了，她就直接放弃了）。
斯诺克比赛中红，黄，绿，棕，蓝，粉，黑球分别为1分到7分。
红球一共有15个，进洞之后不再拿出来。最后一颗红球进洞之前，彩球打进之后要拿出来。最后一颗红球打进后，还可以任意打一颗彩球并拿出，然后从分数最低的彩球打起（黄球），此时彩球打进不拿出。直到打进黑球结束比赛。
斯诺克击球的顺序为红球→彩球→红球→彩球→红球→。。。。→(最后一颗)红球→彩球→（此时从分数最低的彩球打起，彩球进去之后不再拿出来）→黄球→绿球→棕球→蓝球→粉球→黑球，因此台面上最高有147分。
题目输入：
输入只包含一个整数N（0<=N<=147）,代表lmm333第一杆的分数，当N=-1时输入结束
题目输出：
输出包含两行，第一行输出ltj击球时台面上剩余的最大分值和最小分值（如果最大分值和最小分值相同只输出一个），第二行输出“Yes”或“No”，表示ltj能否赢得这局比赛，如果最大分值和最小分值不存在则只输出-1
输入样例：
147
0
-1
输出样例：
0
No
147 72
Yes
提示：
两人都是高手，不会出现因违反规则而失误罚分情况 O(∩_∩)O



题目：SpatialStructures(1606)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	Computer graphics, image processing, and GIS (geographic information systems) all make use of a data structure called a quadtree. Quadtrees represent regional or block data efficiently and support efficient algorithms for operations like the union and intersection of images.	A quadtree for a black and white image is constructed by successively dividing the image into four equal quadrants. If all the pixels in a quadrant are the same color (all black or all white) the division process for that quadrant stops. Quadrants that contain both black and white pixels are subdivided into four equal quadrants and this process continues until each subquadrant consists of either all black or all white pixels. It is entirely possible that some subquadrants consist of a single pixel.	For example, using 0 for white and 1 for black, the region on the left below is represented by the matrix of zeros and ones in the middle. The matrix is divided into subquadrants as shown on the right where gray squares represent subquadrants that consist entirely of black pixels.			A quadtree is constructed from the block structure of an image. The root of the tree represents the entire array of pixels. Each non-leaf node of a quadtree has four children, corresponding to the four subquadrants of the region represented by the node. Leaf nodes represent regions that consist of pixels of the same color and thus are not subdivided. For example, the image shown above, with the block structure on the right, is represented by the quadtree below.			Leaf nodes are white if they correspond to a block of all white pixels, and black if they correspond to a block of all black pixels. In the tree, each leaf node is numbered corresponding to the block it represents in the diagram above. The branches of a non-leaf node are ordered from left-to-right as shown for the northwest, northeast, southwest, and southeast quadrants (or upper-left, upper-right, lower-left, lower-right).	A tree can be represented by a sequence of numbers representing the root-to-leaf paths of black nodes. Each path is a base five number constructed by labeling branches with 1, 2, 3, or 4 with NW = 1, NE = 2, SW = 3, SE = 4, and with the least significant digit of the base five number corresponding to the branch from the root. For example, the node labeled 4 has path NE, SW which is 325 (base 5) or 1710 (base 10); the node labeled 12 has path SW, SE or 435 = 2310 ; and the node labeled 15 has path SE, SW, NW or 1345 = 4410 . The entire tree is represented by the sequence of numbers (in base 10)		9 14 17 22 23 44 63 69 88 94 113	Write a program that converts images into root-to-leaf paths and converts root-to-leaf paths into images.
题目输入：
The input contains one or more images. Each image is square, and the data for an image starts with an integer n, where | n| is the length of a side of the square (always a power of two, with | n| ≤ 64) followed by a representation of the image. A representation is either a sequence of n2 zeros and ones comprised of | n| lines of | n| digits per line, or the sequence of numbers that represent the root-to-leaf paths of each black node in the quadtree that represents the image.	If n is positive, the zero/one representation follows; if n is negative, the sequence of black node path numbers (in base 10) follows. The sequence is terminated by the number -1. A one-node tree that represents an all-black image is represented by the number 0. A one-node tree that represents an all-white image is represented by an empty sequence (no numbers).	The end of data is signaled by a value of 0 for n.
题目输出：
For each image in the input, first output the number of the image, as shown in the sample output. Then output the alternate form of the image.	If the image is represented by zeros and ones, the output consists of root-to-leaf paths of all black nodes in the quadtree that represents the image. The values should be base 10 representations of the base 5 path numbers, and the values should be printed in sorted order. If there are more than 12 black nodes, print a newline after every 12 nodes. The total number of black nodes should be printed after the path numbers.	If the image is represented by the root-to-leaf paths of black nodes, the output consists of an ASCII representation of the image with the character `.' used for white/zero and the character `*' used for black/one. There should be n characters per line for an n×n image.	Print a blank line between cases.
输入样例：
8
00000000
00000000
00001111
00001111
00011111
00111111
00111100
00111000
-8
9 14 17 22 23 44 63 69 88 94 113 -1
2
00
00
-4
0 -1
0
输出样例：
Image 1
9 14 17 22 23 44 63 69 88 94 113
Total number of black nodes = 11

Image 2
........
........
....****
....****
...*****
..******
..****..
..***...

Image 3
Total number of black nodes = 0

Image 4
****
****
****
****

提示：
None



题目：掼蛋(1822)
时间限制：4000 ms
空间限制：65535 KB
题目描述：
掼蛋成了大家回家聚会常玩的游戏。skt回家聚会也和老朋友们一起玩这个了。不过skt在打牌时突然在想接下来该出什么牌了。
掼蛋是由两付牌组成的，有两张大王，两张小王，4种花色的A，2，3，4，5，6，7，8，9，10，J，Q，K，每个花色两张。
同时数值A，2，3，4，5，6，7，8，9，10，J，Q，K
也分别对应了我打牌的等级k为 1，2，3，4，5，6，7，8，9，10，11，12，13。

规则一：
我们设定规则一为单牌的正常顺序是：（从大到小依次为）
大王，小王，（级牌），A，K，Q，J，10，9，8，7，6，5，4，3，2 
同时，如果我们此次打牌的等级k为11，以k = 11为例，则单张牌实际的大小顺序为：大王>小王>J>A>K>Q>10>9>8>7>6>5>4>3>2

掼蛋主要有以下牌种：
	炸弹：八张同数值牌，七张同数值牌，六张同数值牌，五张同数值牌，四张同数值牌，
	注：当前k等级的两张红桃牌称为逢人配（任意配，除大王小王外可配任何花色任何牌），如和八张相同的牌一起，可变为10张的炸弹。
	四王（四鬼牌），什么牌型都比它小，是最大的牌。
	同花顺：相同花色的五张连续单牌，最大的为同花10-J-Q-K-A，次大的同花为9-10-J-Q-K，依次类推，最小的为A-2-3-4-5, 花色不影响大小。
	顺子：五张连续单牌，花色不是全一样的，最小的顺子为A-2-3-4-5，然后为2-3-4-5-6，依次类推，最大为10-J-Q-K-A。不包括双王，花色不影响大小。
	钢板（又称飞机）：连续的两个三张相同的牌，如：333444、444555，最小的钢板为AAA222、然后222333，依次类推，最大为KKKAAA。
	单牌：单个牌。大小比较参考规则一。
	对牌：数值相同的两张牌。大小比较同样参考规则一，按照单牌的大小来比较。
	三张牌：数值相同的三张牌（如三个10）。参考规则一，按照单牌的大小比较。
	三带两：数值相同的三张牌加一对牌。参考规则一，按照3张相同的那个单牌来比较。
	三连对：三连续对牌，不可超过3对，如：334455、778899，最大的是QQKKAA，最小的是AA2233，依次类推。不包括双王，不分花色。两连对不可出。
掼蛋的规则：
	四王是最大的牌>10张的炸弹>9张的炸弹>8张的炸弹>7张的炸弹>6张的炸弹>同花顺>5张的炸弹>4张的炸弹>其它牌型
	对一般牌型而言，只有当牌型相同的牌，才可比较大小。
	其中像三连对，钢板，顺子，同花顺组合牌型，只要按照单牌的正常顺序（除掉级牌之后）比较其最大数值的牌就行。
	逢人配（任意组合），可变成除了大小王之外的任意花色任意牌。逢人配为当前等级的红桃牌。
skt和对手已经玩了很久，出掉了很多手牌了。现在，他们两个人手上都留有一手牌（数据确保能一次性出完，如果有逢人配导致手牌可能不能一次性出完，我们取能一次性出完的并且使手牌最大的那种情况）。
现在的问题就是：当对手打出牌时，skt想知道自己想打的牌和对方的牌哪个大？
题目输入：
有多个样例，以EOF结束。
每张牌分别用花色和牌的大小表示。A -> K分别用A,2,3,4,5,6,7,8,9,10,J,Q,K表示。红桃用H表示,草花用C表示,黑桃用T表示,方块用F表示。大王用BW表示,小王用SW表示。比如红桃A就是 HA。每个样例:
	第一行,输入n, k。n 表示牌数, k为当前局数的等级(等级为k的红桃牌可以逢人配,而且等级k的牌是仅次于大小王的牌)。1 <= n <= 9, 1 <= k <= 13。
	第二行,输入n张牌。表示对方的牌
	第三行,输入n张牌。表示我方的牌
保证每个输入都是合法的。且我方的牌和对方的牌是可以比较大小的。(为了防止出现类似(2233+逢人配+逢人配)产生了(钢板或者连对)歧义,我们保证没有这种数据。)
题目输出：
对每个样例,若我方的牌大于对面的牌,就输出"Yes", 否则就出"No"
输入样例：
5 3
H4 H4 C4 C3 C3
H5 H5 C5 C2 C2
输出样例：
Yes
提示：




题目：newFarkinggotravelling(1159)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
NewFarking's girlfriend is a beautiful girl.One day,they go travelling,so they need to pay for the bills in the travelling.But newFarking and his girlfriend are both very diligent so they always do some odd jobs while travelling. Now newFarking want to prove to his girlfriend that he costs less money than his girlfriend including the money they make while doing the odd jobs). And he also want to tell her that they have made much money during the travelling. But there are many bills , newFarking is not so clever to pick out some bills. Each line means a bill. Now it is your time to help him to pick out some bills. 
题目输入：

The first line is an interger T which implies there are T test cases,then followed by one interger n which 
means that in this test case there are n group numbers . In next n lines there are two  
intergers a and b in a line ( "a" means that newFarking consume or make "a" yuan in one bills  
, and "b" means that his girlfriend consume or make "b" yuan in one bills ).
( 0 < n < = 1000  ,  -100 < = a , b < = 100 )
题目输出：
For each test case , you should output one line contains one interger sum ( sum=suma+sumb , suma is  
the sum of newFarking consume and make and sumb is the sum of newFarking's girlfriend   
consume and make). You should make sure that suma > sumb , and make sure that suma + sumb is  
the maximum. If you can't find answer you should output "newFarking is a beiju."

输入样例：
2
2
1 2
-1 0
2
2 1
1 2
输出样例：
newFarking is a beiju.
3

提示：
In the second case we choose the first line , so the sum is 2 + 1 = 3 and 2 > 1




题目：Friends(1405)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
You want to plan a big birthday party with your friends. On planning you notice that you have to do a lot of operations with sets of friends. There is one group which consist of Arthur, Biene and Clemens. Then there is a group of friends you know from snowboarding which consists of Daniel, Ernst, Frida and Gustav. If you want to invite them both, the resulting party group consists of g1 + g2 (the result is the union of both groups). Then you can compute the intersection of the two groups g1 * g2, which consists of the empty set. Maybe you want to invite a group g1, but excluding all members of an other group g2, which is written as g1 - g2. Intersection (*) has precedence over union (+) and set difference (-). All operations are left associative, which means that in A op1 B op2 C you first have to evaluate A op1 B (provided op1 and op2 have equal precedence). 
题目输入：
The input consists of one or more lines. Each line contains one expression that you have to evaluate. Expressions are syntactically correct and only consist of the characters: 
'{' and '}' 
the elements 'A' to 'Z' meaning friend Arthur to Zora. 
the operations '+', '-' and '*' 
'(' and ')' for grouping operations 
the newline character '\n' marking the end of an expression. 
A line is never longer than 255 characters. 

题目输出：
Output the resulting set in curly braces '{' and '}', each on a line of its own. Print elements of sets sorted alphabetically.
输入样例：
{ABC}
{ABC}+{DEFG}+{Z}+{}
{ABE}*{ABCD}
{ABCD}-{CZ}
{ABC}+{CDE}*{CEZ}
({ABC}+{CDE})*{CEZ}


输出样例：
{ABC}
{ABCDEFGZ}
{AB}
{ABD}
{ABCE}
{CE}


提示：




题目：Birthdates(1707)
时间限制：2000ms
空间限制：65535kb
题目描述：
	Write a program to identify the youngest person and the oldest person in a class.
题目输入：
	The number n (1 ≤ n ≤ 100 ) in the first line determines the number of people in a class. The following n lines contain person’s name and his/her birthdate.	The information in each line is of this format:	personName dd mm yyyy	where personName is a single word less than 15 letters, dd mm yyyy are date, month and year of the birthdate.	Suppose that no one has the same name or the same birthdate.
题目输出：
	Print out 2 lines containing the name of youngest person and oldest person, respectively.
输入样例：
5
Mickey 1 10 1991
Alice 30 12 1990
Tom 15 8 1993
Jerry 18 9 1990
Garfield 20 9 1990

输出样例：
Tom
Jerry

提示：
None



题目：二叉树的遍历(1059)
时间限制：1000 ms
空间限制：65535 kb
题目描述：
先输入两个字符串，分别代表二叉树前序和中序的遍历结果，然后要求输出后序的遍历结果！！而且后序遍历的程序要求是非递归的程序！！
题目输入：
None
题目输出：
None
输入样例：
abcdefghijklmn
nmlkjihgfedcba

输出样例：
nmlkjihgfedcba
提示：
None



题目：Apple'sinterest(1301)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Apple is one of smart boys in my roommates.From his name,we may know he  likes computer science.He often finds a vast majority of interesting things about binary numbers.Please look at the following example:10   1010101001   01010101      10101010      01010101(A)  (B)Do you find something in common between matrix A and matrix B ? Yes,Apple finds that matrix B  results from matrix A after copying many times.Now you know matrix B,can you tell me the the smallest matrix A? For example:1010  10  101010        101010(B)     (C)   (D)the smallest matrix A is matrix  C,not matrix  D.
题目输入：
The first line contains an integer t ( 1 <= t <= 10 ): the number of test cases. Then for each test case:The first line contains two integers n,m ( 1 <= n,m <= 1000 ),where n,m is the size of  matrix B.Next n lines contain the informations of the matrix B,which only consists of '0' and '1'.
题目输出：
For each test case, output the result in the form of sample.You should print the case number and the size of smallest matrix A and the information of smallest matrix A.
输入样例：
1
3 4
1010
1010
1010

输出样例：
Case 1:
1 2
10

提示：
None



题目：BeeBreeding(1607)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		Professor B. Heif isconducting experiments with a species of South American bees that hefound during an expedition to the Brazilian rain forest. The honeyproduced by these bees is of superior quality compared to the honeyfrom European and North American honey bees. Unfortunately, the beesdo not breed well in captivity. Professor Heif thinks the reason isthat the placement of the different maggots (for workers, queens,etc.) within the honeycomb depends on environmental conditions, whichare different in his laboratory and the rain forest.	As a first step tovalidate his theory, Professor Heif wants to quantify the differencein maggot placement. For this he measures the distance between thecells of the comb into which the maggots are placed. To this end, theprofessor has labeled the cells by marking an arbitrary cell asnumber 1, and then labeling the remaining cells in a clockwisefashion, as shown in the following figure. 	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->								 		 	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		For example, twomaggots in cells 19 and 30 are 5 cells apart. One of the shortestpaths connecting the two cells is via the cells 19 - 7 - 6 - 5 - 15 -30, so you must move five times to adjacent cells to get from 19 to30.  	Professor Heifneeds your help to write a program that computes the distance,defined as the number of cells in a shortest path, between any pairof cells.  	
题目输入：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		The input consists ofseveral lines, each containing two integers a and b ( a, b<=10000),denoting numbers of cells. The integers are always positive, exceptin the last line where a = b = 0 holds. This last lineterminates the input and should not be processed.  
题目输出：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		For each pair ofnumbers (a, b) in the input file, output the distancebetween the cells labeled a and b. The distance is theminimum number of moves to get from a to b.  
输入样例：
19 30
0 0
输出样例：
The distance between cells 19 and 30 is 5.
提示：
None



题目：FrameUp(1509)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Consider the following five picture frames shown on an 9 x 8 array: ........   ........   ........   ........   .CCC....EEEEEE..   ........   ........   ..BBBB..   .C.C....E....E..   DDDDDD..   ........   ..B..B..   .C.C....E....E..   D....D..   ........   ..B..B..   .CCC....E....E..   D....D..   ....AAAA   ..B..B..   ........E....E..   D....D..   ....A..A   ..BBBB..   ........E....E..   DDDDDD..   ....A..A   ........   ........E....E..   ........   ....AAAA   ........   ........EEEEEE..   ........   ........   ........   ........   1          2           3          4          5Now place all five picture frames on top of one another starting with 1 at the bottom and ending up with 5 on top. If any part of a frame covers another frame, it hides that part of the frame below. Viewing the stack of five frames we see the following.            .CCC...           ECBCBB..           DCBCDB..           DCCC.B..           D.B.ABAA           D.BBBB.A           DDDDAD.A           E...AAAA           EEEEEE..Given a picture like this, determine the order of the frames stacked from bottom to top. Here are the rules for this challenge: The width of the frame is always exactly 1 character and the sides are never shorter than 3 characters. It is possible to see at least one part of each of the four sides of a frame. A corner is part of two sides. The frames will be lettered with capital letters, and no two frames will be assigned the same letter.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  Two space-separated integers: the height H (3 <= H <=30) and the width W (3 <= W <= 30).  Line 2..H+1:  H lines, each with a string W characters wide.
题目输出：
Print the letters of the frames in the order they were stacked from bottom to top. If there are multiple possibilities for an ordering, list all such possibilities -- in alphabetical order -- on successive lines. There will always be at least one legal ordering.
输入样例：
9 8
.CCC....
ECBCBB..
DCBCDB..
DCCC.B..
D.B.ABAA
D.BBBB.A
DDDDAD.A
E...AAAA
EEEEEE..
输出样例：
EDABC
提示：




题目：数组游戏(1823)
时间限制：3000 ms
空间限制：131072 KB
题目描述：
有一个无限长哒初始全部为0哒数组。王大锤和王小可一起轮流在数组上做游戏。王大锤先开始。每次王大锤都选择一个区间l0, r0；把这个区间[l0, r0]里面哒数字全部加起来得到s，把s告诉王小可；王小可也选择一个区间l1，r1和一个数字x，他把[l1 + s % 2014, r1 + s % 2014]范围内哒数字全部都加上(x + s) % 2014。

现在告诉你游戏哒情况，请你按照顺序输出王大锤计算出哒s值。
题目输入：
多Case，以EOF结尾
第一行，一个整数n表示游戏进行了多少轮
接下来2*n(1 <= n <= 10000)行，每两行表示一轮，格式为
l0 r0
l1 r1 x (所有数字都是在1000000000范围内哒正整数）
分别表示王大锤哒选择和王小可哒选择。
题目输出：
输出n行，王大锤计算哒s值
输入样例：
3
1 1
1 2 1
1 1
1 2 1
2 2
1 2 1

3
1 1
1 2 1
1 1
1 2 1
2 4
1 2 1
输出样例：
0
1
3
0
1
5
提示：




题目：营救fishhead(1160)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
某日，fishhead被人绑架了，被关在了njust后院某处的牢房里。得知这个消息后，acm小队队长珂大神决定带领众队员空降营救fishhead。但是经过newfarking大神的调查之后发现，njust后院的地形很奇特，高低不平，并且有神秘的机关。newfarking大神研究了半天后得出，以队员们的能力，只能向高度差为g的地方移动。比如，要是队员们现在所处的地方高度为10，那么他们只能向高度小于等于10+g且大于等于10-g的相邻的地方移动。队员们只能沿上下左右四个方向前进，且一旦不按照上面的规则制定路线，后果将不堪设想！当夜，dreamfeather驾驶者飞机载着acm小队实施空降营救，但无奈信号干扰严重，dreamfeather无法保证让acm营救小队降落在准确的位置。所以，请你帮忙计算一下，看acm小队能否成功营救出fishhead。
题目输入：
第一行是样例个数i(1 <= i <= 1000)。
第二行的两个数m和n分别表示这片区域的大小(1 <= m , n <= 70 )。
之后的m行乘以n列的正整数表示njust后院的地形，数字的大小表示该处的高度，数字越大高度越高（1 <= 高度 <= 5000）。
倒数第二行的四个数，前两个x1，y1表示acm小队的降落地点的行和列的坐标，后两个x2，y2表示牢房的行和列坐标。坐标均从0开始计，你可以确定两组坐标一定在这片区域之中。
最后一行为队员们能够承受的高度差g(g <= 1000)。

题目输出：
每个样例的输出仅一行，能营救出fishhead输出“YES”，否则输出“NO”。
输入样例：
3
3 3
1 2 3
4 5 6
7 8 9
0 1 2 2
1
4 5
9 9 9 9 11
2 6 12 9 9
0 2 23 1 4
0 0 0 0 2
0 3 3 0
3
1 1
33
0 0 0 0
10
输出样例：
NO
NO
YES
提示：




题目：PrimeSubstring(1708)
时间限制：10000ms
空间限制：65535kb
题目描述：
	Given a string of digits, your task is to find the largest prime number which presents in that string. Our prime numbers are values between 2 to 100,000 only.
题目输入：
	Each line contains a string of digits (255 digits at most). The line contains only 0 indicates the end which will not be processed. The input does not exceed 1,000 lines.
题目输出：
Print out in each line the largest prime number found in each input string.
输入样例：
11245
91321150448
1226406
0

输出样例：
11
1321
2

提示：
None



题目：QuadtreeII(1406)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Having realized that the quadtree-encoded treasure map was a fake, Florida Jones maliciously plans to also play a prank for the next treasure hunter after him. But for that, he needs your help once again: 
Can you write a program that takes a picture in the XBM format and encodes it with the quadtree scheme? 
题目输入：
The first line will be "#define quadtree_width n" where n is the picture size in pixels. (The picture is quadratic: n*n pixels) 
The second line will be "#define quadtree_height n" accordingly. 
The third line will be "static char quadtree_bits[] = {". 
Then, n lines will follow, each one encoding one pixel row of the picture. There will be n/8 hexadecimal numbers per line.
Each hexadecimal number is composed of 8 bits that encode 8 pixels from left to right (where the leftmost bit has the value 1 and the rightmost bit has the value 128). The hexadecimal numbers are printed in the form 0xdd where d is one character of the set { 0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f }. 
Example: The 8 pixels WBBBBWWB are written as 0x9e. (2+4+8+16+128 = 158 = 0x9e) 
After each hexadecimal number, a comma follows. 
The last line will be "};". 

题目输出：
First, print the integer n (8 <= n <= 512) on a line by itself. 
Then, print a string consisting of the letters B, W and Q that correctly encodes the picture with the quadtree scheme. 
Finally, terminate the string with a newline character. 
输入样例：
Note: The comments (enclosed by /* and */) are not part of the input. They should help to explain the XBM format. 
#define quadtree_width 16
#define quadtree_height 16
static char quadtree_bits[] = {
0xf0,0xf0,                       /* WWWWBBBB WWWWBBBB */
0xf0,0xf0,                       /* WWWWBBBB WWWWBBBB */
0xf0,0xf0,                       /* WWWWBBBB WWWWBBBB */
0xf0,0xf0,                       /* WWWWBBBB WWWWBBBB */
0x0f,0x0f,                       /* BBBBWWWW BBBBWWWW */
0x0f,0x0f,                       /* BBBBWWWW BBBBWWWW */
0x0f,0x0f,                       /* BBBBWWWW BBBBWWWW */
0x0f,0x0f,                       /* BBBBWWWW BBBBWWWW */
0xf0,0xf0,                       /* WWWWBBBB WWWWBBBB */
0xf0,0xf0,                       /* WWWWBBBB WWWWBBBB */
0xf0,0xf0,                       /* WWWWBBBB WWWWBBBB */
0xf0,0xf0,                       /* WWWWBBBB WWWWBBBB */
0x0f,0x0f,                       /* BBBBWWWW BBBBWWWW */
0x0f,0x0f,                       /* BBBBWWWW BBBBWWWW */
0x0f,0x0f,                       /* BBBBWWWW BBBBWWWW */
0x0f,0x0f,                       /* BBBBWWWW BBBBWWWW */
};


输出样例：
16
QQWBBWQWBBWQWBBWQWBBW


提示：
Since the problems "Quadtree" and "Quadtree II" are inverse to each other, you can double check your programs by converting back and forth between the respective input and output files. 



题目：Calculator(1060)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A simple 8-digit electronic calculator contains the following buttons: “1234567890+-*/=” (no quotes). It can be divided into the following categories:Digit: “1234567890”You can input any number with digital buttons (ignore leading zero). Notice, the LED of calculator can only display 8 digits. So when the number of digits large than eight, only the first eight digits will be retained. And when the number of one result’s digits large than eight, error occurs.Operator: “+-*/”For simplicity, all operations are integer operations. Some continuous operators, the last one is valid. When an operator button is pressed, the calculation before that will be completed.
Equal-sign: “=”If the second operand is missing, you can think it equal the first operand. More than one continuous equal-sign means repeat the operation. You can observe the following examples.

 
题目输入：
The first line is number of test cases. After that, each case consists of one line, containing a string means pressed button. The length of string is less than 100. There is no additional space.
题目输出：
First output the case number. Then output the displayed number in the same line. If there is any error occurs, just print “ERROR” please. Please follow the format of the sample output.
输入样例：
6
11+/2+
11+*==
3==+5=
5=7=+8=
99999999+1-1=
1-99999999=
输出样例：
Case 1: 5
Case 2: 1331
Case 3: 8
Case 4: 15
Case 5: ERROR
Case 6: -99999998
提示：




题目：Braveboy(1302)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Snow is a brave boy.He always has some new ideas.Now he wanna redefine the "+" operator for strings such that  "a"+"a"="a", "b"+"b"="c",...,"b"+"z"="ba".Now you have to add two strings a and b using the operator "+".Notice that the strings consist of only lower-case characters.
题目输入：
The first line contains an integer t ( 1 <= t <= 100 ): the number of test cases. Then for each test case:Each case contains two strings.
题目输出：
For each test case,  output the result in the form of sample.You should print the case number and the sum of the two strings.
输入样例：
2
aa
a
abc
cba

输出样例：
Case 1: aa
Case 2: ccc

提示：
None



题目：FencingtheCows(1510)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer John wishes to build a fence to contain his cows, but he's a bit short on cash right. Any fence he builds must contain all of the favorite grazing spots for his cows. Given the location of these spots, determine the length of the shortest fence which encloses them.
题目输入：
There are several test cases, end by EOF, for each test case:The first line of the input file contains one integer, N. N (0 <= N <= 10,000) is the number of grazing spots that Farmer john wishes to enclose. The next N line consists of two real numbers, Xi and Yi, corresponding to the location of the grazing spots in the plane (-1,000,000 <= Xi,Yi <= 1,000,000). The numbers will be in decimal format.
题目输出：
The output should consists of one real number, the length of fence required. The output should be accurate to two decimal places.
输入样例：
4
4 8
4 12
5 9.3
7 8
输出样例：
12.00
提示：




题目：BulletHole (1608)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		 	A cube is suspended inspace. A Cartesian coordinate system is defined with its origin atone of the bottom corners of the cube, as shown in the figure. Thecube has side dimension d, so its opposite corners are atcoordinates (0, 0, 0) and (d, d, d). Thepositive z-direction of the coordinate system is ``up'' withrespect to gravity.  	The interior of thecube contains partitions with uniform spacing in each dimension, sothat the cube is partitioned into n3 mini-cubes ofequal size. The partitions are thin and watertight, and eachmini-cube is filled with water. The total volume of water in all theminicubes is d3 .  	A gun fires abullet which may hit the cube. The muzzle of the gun is at the point( x1, y1, z1).The point ( x2, y2, z2)is a point on the bullet's path that defines the direction of thebullet. The bullet does not shatter the cube, but wherever the bullettouches a side or interior partition of the cube, it makes a smallhole. Bullet holes may be made in the sides, edges, or corners of theinterior mini-cubes. Water, influenced by gravity, may leak throughthese small holes. All the water that leaks out of the large cube iscollected and measured.  
题目输入：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }		TT.cjk { font-family: "DejaVu Sans Condensed", monospace }	-->		The input data setconsists of several trials. Each trial is described by eightintegers. The first integer is n (n<=50),as described above. The second integer is d (d<=100).The remaining six integers-- x1, y1, z1, x2, y2, z2--represent the origin and a point on the path ofthe bullet ( -100<=x1, y1, z1, x2, y2, z2<=100).The origin and the point on the path of the bullet are not the same.The origin may be inside the cube. After the last trial, the integer`0' terminates the data set.  
题目输出：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }		TT.cjk { font-family: "DejaVu Sans Condensed", monospace }	-->		Your program mustcompute the total volume of water that leaks out of the large cube.For each trial, print the trial number, the notation `Volume=', and the total volume of water accurate to two digits to theright of the decimal point.  	Print a blank linebetween trials.  	Note: Inthis problem, two real numbers are considered equal if they are lessthan 10-6 apart.  
输入样例：
 5   25     5  15   0     5  15 100
 3   30     0 -35   0     3 -25   3
10   16     8  17  11    12  19   6
 0
输出样例：
Trial 1, Volume = 2500.00

Trial 2, Volume = 1950.00

Trial 3, Volume = 0.00
提示：
None



题目：夕阳下的奔跑(1824)
时间限制：5000 ms
空间限制：65536 KB
题目描述：
傍晚了，夕阳快要落山。王小可在另外一个操场参加跑步比赛。所有童鞋在四周热身。比赛终点也是一条直线，万万没想到，终点线的向量v是固定的，但是终点线经过哪一个点是由裁判随机决定的。王小可给每人吃了一个苹果，所有人都答应他跑步的时候和他保持一样的速度。王小可天生匀速，他跑步的时候速度正好是单位1。问，裁判确定终点经过点之后一声令下，所有同学依次从热身点出发，以最快地方式跑到终点线的总时间是多少？（依次跑就是等一个人跑到终点线，另外一个人再开始跑）
题目输入：
多组样例，以EOF结尾。
第一行，x y， 终点线哒非零方向向量。
下面一行一个正整数n （1 <= n <= 100000)，表示n个童鞋。
接下来n行，每行两个整数，x0 y0，表示n个童鞋的坐标。
下面一行一个正整数m （1 <= m <= 100000)，表示裁判的m次可能的命令。
接下来m行，每行两个整数，x1 y1，表示m种不同的终点可能经过的点。
数据保证所有数字的绝对值不会超过 100000
题目输出：
对于每一次裁判可能的命令，输出要求的总时间，保留2位小数，结果误差在0.01范围之内均可被接受。
输入样例：
0 1
2
1 0
2 1
3
0 0
1 0
4 0
输出样例：
3.00
1.00
5.00
提示：
大量输入输出，建议使用scanf和printf。



题目：loveispopular(1161)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
在遥远的新城里，有N(100<N<800)个男的，M个女(100<M<200)，男女之间,有些互相有好感。现在给你一些少男少女的相互好感程度（没给出的那些男女间根本就不认识，谈何好感）求如何安排他们恋爱,显然是一夫一妻制，使好感程度之和最大，这个城市的总体和谐度就最高了。。
题目输入：
多组测试数据，每组以N,M开头
下面是p（p < 2000）对数据，形式为i j k( 1 <= i <= N ,1 <= j <= M,0 < k <= 100 )。 编号为i的男人和编号为j的女人的好感度为k。相信我们的数据，显然同一个男人对同一个女人只有一个好感程度。
输入以0 0 结束
题目输出：
最大好感程度和
输入样例：
200 200
2
1 2 2
2 3 2
0 0
输出样例：
4

提示：




题目：Coprime(1061)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
Please write a program to calculate the k-th positive integer that is coprime with m and n simultaneously. A is coprime with B when their greatest common divisor is 1.
题目输入：
The first line contains one integer T representing the number of test cases.
For each case, there's one line containing three integers m, n and k (0 < m, n, k <= 10^9).
题目输出：
For each test case, in one line print the case number and the k-th positive integer that is coprime with m and n.
Please follow the format of the sample output.
输入样例：
3
6 9 1
6 9 2
6 9 3
输出样例：
Case 1: 1
Case 2: 5
Case 3: 7
提示：




题目：ADiceyProblem(1609)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		The three-by-threearray in Figure 1 is a maze. A standard six-sided die is needed totraverse the maze (the layout of a standard six--sided die is shownin Figure 2). Each maze has an initial position and an initial dieconfiguration. In Figure 1, the starting position is row 1, column2--the ``2'' in the top row of the maze--and the initial dieconfiguration has the ``5'' on top of the die and the ``1'' facingthe player (assume the player is viewing the maze from the bottomedge of the figure).  	 	To move through themaze you must tip the die over on an edge to land on an adjacentsquare, effecting horizontal or vertical movement from one square toanother. However, you can only move onto a square that contains thesame number as the number displayed on the top of the die before themove, or onto a ``wild'' square which contains a star. Movement ontoa wild square is always allowed regardless of the number currentlydisplayed on the top of the die. The goal of the maze is to move thedie off the starting square and to then find a way back to that samesquare.  	For example, at thebeginning of the maze there are two possible moves. Since the 5 is ontop of the die, it is possible to move down one square, and since thesquare to the left of the starting position is wild it is alsopossible to move left. If the first move chosen is to move down, thisbrings the 6 to the top of the die and moves are now possible both tothe right and down. If the first move chosen is instead to the left,this brings the 3 to the top of the die and no further moves arepossible.  	If we consider mazelocations as ordered pairs of row and column numbers ( row, column) with row indexes starting at 1 for the top row andincreasing toward the bottom, and column indexes starting at 1 forthe left column and increasing to the right, the solution to thissimple example maze can be specified as: (1,2), (2,2), (2,3), (3,3),(3,2), (3,1), (2,1), (1,1), (1,2). A bit more challenging examplemaze is shown in Figure 3.  	The goal of thisproblem is to write a program to solve dice mazes. The input filewill contain several mazes for which the program should search forsolutions. Each maze will have either a unique solution or nosolution at all. That is, each maze in the input may or may not havea solution. For each input maze, either a solution or a messageindicating no solution is possible will be sent to the output.  	 
题目输入：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }		TT.cjk { font-family: "DejaVu Sans Condensed", monospace }	-->		The input file beginswith a line containing a string of no more than 20 non-blankcharacters that names the first maze. The next line contains sixintegers delimited by single spaces. These integers are, in order,the number of rows in the maze (an integer from 1 to 10, call thisvalue R), the number of columns in the maze (an integer from 1to 10, call this value C), the starting row, the startingcolumn, the number that should be on top of the die at the startingposition, and finally the number that should be facing you on the dieat the starting position. The next R lines contain C integers each, again delimited by single spaces. This R×C array of integers defines the maze. A value of zero indicates anempty location in the maze (such as the two empty squares in thecenter column of the maze in Figure 3), and a value of `-1'indicates a wild square. This input sequence is repeated for eachmaze in the input. An input line containing only the word `END'(without the quotes) as the name of the maze marks the end of theinput.  
题目输出：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }		TT.cjk { font-family: "DejaVu Sans Condensed", monospace }	-->		The output shouldcontain the name of each maze followed by its solution or the string`No Solution Possible' (without the quotes).All lines in the output file except for the maze names should beindented exactly two spaces. Maze names should start in the leftmostcolumn. Solutions should be output as a comma-delimited sequence ofthe consecutive positions traversed in the solution, starting andending with the same square (the starting square as specified in theinput). Positions should be specified as ordered pairs enclosed inparentheses. The solution should list 9 positions per line (with theexception of the last line of the solution for which there may not bea full 9 positions to list), and no spaces should be present withinor between positions.  
输入样例：
DICEMAZE1
3 3 1 2 5 1
-1 2 4
5 5 6
6 -1 -1
DICEMAZE2
4 7 2 6 3 6
6 4 6 0 2 6 4
1 2 -1 5 3 6 1
5 3 4 5 6 4 2
4 1 2 0 3 -1 6
DICEMAZE3
3 3 1 1 2 4
2 2 3
4 5 6
-1 -1 -1
END
输出样例：
DICEMAZE1
  (1,2),(2,2),(2,3),(3,3),(3,2),(3,1),(2,1),(1,1),(1,2)
DICEMAZE2
  (2,6),(2,5),(2,4),(2,3),(2,2),(3,2),(4,2),(4,1),(3,1),
  (2,1),(2,2),(2,3),(2,4),(2,5),(1,5),(1,6),(1,7),(2,7),
  (3,7),(4,7),(4,6),(3,6),(2,6)
DICEMAZE3
  No Solution Possible
提示：
None



题目：LongestWord(1709)
时间限制：2000ms
空间限制：65535kb
题目描述：
	A word is composed of only letters of the alphabet (a-z, A-Z) and may contain one hyphen (-) or more. Given a text containing words, and other characters (punctuations, numbers, symbols, etc), you are to write a program to find the longest word.	Each letter or a hyphen in a word is counted as 1. For example,	The length of Apple is 5	The length of son-in-law is 10	The length of ACM-ICPC is 8
题目输入：
	A text may contain several lines and paragraphs but the text does not exceed 10,000 characters. No word can exceed 100 characters. The word E-N-D indicates the end of input.
题目输出：
	Print out the longest word in small letters. If there exist several longest words, print only the first one found in the text.
输入样例：
ACM International Collegiate Programming Contest (abbreviated as
ACM-ICPC or just ICPC) is an annual multi-tiered computer programming
competition among the universities of the world. The contest is
sponsored by IBM. Headquartered at Baylor University, with autonomous
regions on six continents, the ICPC is directed by Baylor Professor
William B. Poucher, Executive Director, and operates under the
auspices of the Association for Computing Machinery (ACM).
The 2012 ACM-ICPC Asia Hatyai Regional Programming Contest is
held during 15-16 November 2012. It is hosted by Prince of Songkla
University, Hatyai campus. E-N-D
输出样例：
international
提示：
None



题目：HTML(1407)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
If you ever tried to read a html document on a Macintosh, you know how hard it is if no Netscape is installed. Now, who can forget to install a HTML browser? This is very easy because most of the times you don't need one on a MAC because there is a Acrobate Reader which is native to MAC. But if you ever need one, what do you do? Your task is to write a small html-browser. It should only display the content of the input-file and knows only the html commands (tags) <br> which is a linebreak and <hr> which is a horizontal ruler. Then you should treat all tabulators, spaces and newlines as one space and display the resulting text with no more than 80 characters on a line. 
题目输入：
The input consists of a text you should display. This text consists of words and HTML tags separated by one or more spaces, tabulators or newlines. 
A word is a sequence of letters, numbers and punctuation. For example, "abc,123" is one word, but "abc, 123" are two words, namely "abc," and "123". A word is always shorter than 81 characters and does not contain any ''. All HTML tags are either  or . 

题目输出：
You should display the the resulting text using this rules: 
If you read a word in the input and the resulting line does not get longer than 80 chars, print it, else print it on a new line. 
If you read a  in the input, start a new line. 
If you read a  in the input, start a new line unless you already are at the beginning of a line, display 80 characters of '-' and start a new line (again). 
The last line is ended by a newline character.
输入样例：
Hallo, dies ist eine 
ziemlich lange Zeile, die in Html
aber nicht umgebrochen wird.

Zwei   produzieren zwei Newlines. 
Es gibt auch noch das tag  was einen Trenner darstellt.
Zwei   produzieren zwei Horizontal Rulers.
Achtung       mehrere Leerzeichen irritieren

Html genauso wenig wie


mehrere Leerzeilen.


输出样例：
Hallo, dies ist eine ziemlich lange Zeile, die in Html aber nicht umgebrochen
wird.
Zwei

produzieren zwei Newlines. Es gibt auch noch das tag
--------------------------------------------------------------------------------
was einen Trenner darstellt. Zwei
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
produzieren zwei Horizontal Rulers. Achtung mehrere Leerzeichen irritieren Html
genauso wenig wie mehrere Leerzeilen.


提示：




题目：ChessboardGame(1303)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
LJB likes playing chessboard game.Now there are some chesses in the square chessboard. LJB has m chesses at his hands.He wants to put all of them on the chessboard at random .We can not put a chess on a position which already contains a chess. After putting all of them,he will be happy if an entire row, column or diagonal consists of chess.So I want you to calculate the percentage he will be happy.
题目输入：
The first line contains an integer t ( 1 <= t <= 100 ): the number of test cases. Then for each test case:The first line contains two integers n ( 1 <= n <= 8 ) and m ( 0 =< m <= 64),where n is the size of the square chessboard and m is the number of  chesses at LJB's hand. Next n lines each contains exactly n characters. Each character will be either '*' or '.', representing a chess on the position or an empty position.There will be at least m empty positions on the board, and there is no any row, column or diagonal all covered  by chess yet.
题目输出：
For each test case,  output the result in the form of sample.You should print the case number and the percentage LJB will be happy.Your answer is supposed to be rounded to six decimal digits.
输入样例：
1
7 10
*.*.***
.**.**.
***.*..
******.
.*.....
....*.*
...**.*



输出样例：
Case 1: 85.232524%





提示：
None



题目：小明拿筷子(1825)
时间限制：1000 ms
空间限制：65536 KB
题目描述：
小明随他的同学去食堂里吃饭，买完饭后大家要去拿筷子，于是小明就去帮大家去拿所需要的筷子。食堂里有多种种类的筷子，每种筷子都足够多，但是每个人都希望自己拿到的两根筷子是同一种类的，也就是只有相同的种类的筷子才可以配对，问小明至少一次性拿多少根筷子才可以确保满足大家的需求。
题目输入：
数据的第一行输入一个正整数T(T <= 100)，表示case数。
接下来每行有两个正整数n和m(1 <= n, m <= 1024)，表示一共有n个人和m种筷子。
题目输出：
对于每个case，输出一行一个整数，表示需要拿的筷子的数量。
输入样例：
2
2 2
3 1
输出样例：
5
6
提示：
对于第一组样例，一共有2个人，有2种筷子，如果只拿4根筷子，可能会形成{1, 3}或{3, 1}的情况，此时不能保证每个人的两根筷子是同种的，但是拿5根的话，将会形成{0, 5}, {1, 4}, {2, 3}, {3, 2}, {4, 1}, {5, 0}中的某一种，无论是哪一种，都可以从里面挑选出2对筷子出来。
对于第二组样例，一共有3个人，只有1种筷子，所以拿3人每人2根就足够了。



题目：StarryNight(1511)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
High up in the night sky, the shining stars appear in clusters of various shapes. A cluster is a non-empty group of neighbouring stars, adjacent in horizontal, vertical or diagonal direction. A cluster cannot be a part of a larger cluster. Clusters may be similar. Two clusters are similar if they have the same shape and number of stars, irrespective of their orientation. In general, the number of possible orientations for a cluster is eight, as Figure 1 exemplifies. 
Figure 1. Eight similar clusters The night sky is represented by a sky map, which is a two-dimensional matrix of 0's and 1's. A cell contains the digit 1 if it has a star, and the digit 0 otherwise. Given a sky map, mark all the clusters with lower case letters. Similar clusters must be marked with the same letter; non-similar clusters must be marked with different letters. You mark a cluster with a lower case letter by replacing every 1 in the cluster by that lower case letter.
题目输入：
There are several test cases, end by EOF, for each test case:The first two lines contain, respectively, the width W and the height H of a sky map. The sky map is given in the following H lines, of W characters each.
题目输出：

输入样例：
23
15
10001000000000010000000
01111100011111000101101
01000000010001000111111
00000000010101000101111
00000111010001000000000
00001001011111000000000
10000001000000000000000
00101000000111110010000
00001000000100010011111
00000001110101010100010
00000100110100010000000
00010001110111110000000
00100001110000000100000
00001000100001000100101
00000001110001000111000
输出样例：
a000a0000000000b0000000
0aaaaa000ccccc000d0dd0d
0a0000000c000c000dddddd
000000000c0b0c000d0dddd
00000eee0c000c000000000
0000e00e0ccccc000000000
b000000e000000000000000
00b0f000000ccccc00a0000
0000f000000c000c00aaaaa
0000000ddd0c0b0c0a000a0
00000b00dd0c000c0000000
000g000ddd0ccccc0000000
00g0000ddd0000000e00000
0000b000d0000f000e00e0b
0000000ddd000f000eee000
提示：




题目：Game(1062)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Bob and Alice are playing a new game. There are n boxes which have been numbered from 1 to n. Each box is either empty or contains several cards. Bob and Alice move the cards in turn. In each turn the corresponding player should choose a non-empty box A and choose another box B that B<A && (A+B)%2=1 && (A+B)%3=0. Then, take an arbitrary number (but not zero) of cards from box A to box B. The last one who can do a legal move wins. Alice is the first player. Please predict who will win the game.
题目输入：
The first line contains an integer T (T<=100) indicating the number of test cases. The first line of each test case contains an integer n (1<=n<=10000). The second line has n integers which will not be bigger than 100. The i-th integer indicates the number of cards in the i-th box.
题目输出：
For each test case, print the case number and the winner's name in a single line. Follow the format of the sample output.
输入样例：
2
2
1 2
7
1 3 3 2 2 1 2
输出样例：
Case 1: Alice
Case 2: Bob
提示：




题目：仙剑奇侠传-四之封神陵(1162)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
     华仔的仙四终于到了封神陵。可是，在南宫二层他遇到了一个问题。


正如上图，封神陵里有个神奇的东西在不停地转。这个神奇的东西共有三层，每层上面有个缺口，云天河等人只有在缺口处才能通过。华仔就突然想啊，我进入第一层还要再等第二层的缺口，不爽。他就想等三层缺口重合的时候一下穿过去，可是他不知道要等多少时间，他等啊等啊，等的肚子都饿了。现在他请聪明的你来计算一下，最少需要多少时间能出现三个缺口重合的情况，这样他好决定是否该出去吃饭。
已知每层转转可以分成N个小段，标号为1~N,开始时每层转转的1，2…..N标号的地方都是重合的（可是这时候他刚进来，还来不及穿越，所以他要等下一次三个缺口重合的时候,由于华仔刚进门时看见了缺口所在的编号，他就站在缺口等下一次三个缺口重合）。
题目输入：
第一行一个整数T，代表CASE数。每个CASE，第一行两个整数N,M，1<=n<=10000,1<=M<=N,分别代表总段数和缺口的标号M。
下面三行每行包含N个数，表示下一刻每个转转的状态。
例如N=5,M=2
2 1 3 5 4
3 2 1 4 5
5 4 3 2 1
表示第一个转转初始时都是1,2,3,4,5的状态，下一刻变为了2 1 3 5 4,那么，我们很容易得到再下一刻状态为1 2 3 4 5,由于天河在初始时2的地方等，2秒之后2的位置又出现了缺口(转转每次变换花费1秒)。

题目输出：
最少需要多少秒之后天河所在地出现三个缺口重合的现象。
输入样例：
1
5   2
2 1 3 5 4
3 2 1 4 5
5 4 3 2 1

输出样例：
2
提示：
华仔是神，玄宵霸气



题目：TradeonVerweggistan(1610)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		Since the days of PeterStuyvesant and Abel Tasman, Dutch merchants have been traveling allover the world to buy and sell goods. Once there was some trade onVerweggistan, but it ended after a short time. After reading thisstory you will understand why.  	At that timeVerweggistan was quite popular, because it was the only place in theworld where people knew how to make a `prul'. The end of the trade onVerweggistan meant the end of the trade in pruls (or `prullen', asthe Dutch plural said), and very few people nowadays know what a prulactually is.  	Pruls were manufacturedin workyards. Whenever a prul was finished it was packed in a box,which was then placed on top of the pile of previously producedpruls. On the side of each box the price was written. The pricedepended on the time it took to manufacture the prul. If all wentwell, a prul would cost one or two florins, but on a bad day theprice could easily rise to 15 florins or more. This had nothing to dowith quality; all pruls had the same value.  	In those days prulssold for 10 florins each in Holland. Transportation costs werenegligible since the pruls were taken as extra on ships that wouldsail anyway. When a Dutch merchant went to Verweggistan, he had aclear purpose: buy pruls, sell them in Holland, and maximize hisprofits. Unfortunately, the Verweggistan way of trading pruls madethis more complicated than one would think.  	One would expect thatmerchants would simply buy the cheapest pruls, and the pruls thatcost more than 10 florins would remain unsold. Unfortunately, allworkyards on Verweggistan sold their pruls in a particular order. Thebox on top of the pile was sold first, then the second one from thetop, and so on. So even if the fifth box from the top was thecheapest one, a merchant would have to buy the other four boxes aboveto obtain it.  	As you can imagine,this made it quite difficult for the merchants to maximize theirprofits by buying the right set of pruls. Not having computers tohelp with optimization, they quickly lost interest in trading prulsat all.  	In this problem, youare given the description of several workyard piles. You have tocalculate the maximum profit a merchant can obtain by buying prulsfrom the piles according to the restrictions given above. Inaddition, you have to determine the number of pruls he has to buy toachieve this profit.  
题目输入：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		The input describesseveral test cases. The first line of input for each test casecontains a single integer w, the number of workyards in thetest case ( 1w50).  	This is followed by w lines, each describing a pile of pruls. The first number in each lineis the number b of boxes in the pile ( 0b20).Following it are b positive integers, indicating the prices(in florins) of the pruls in the stack, given from top to bottom.  	The input is terminatedby a description starting with w = 0. This description shouldnot be processed.  
题目输出：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		For each test case,print the case number (1, 2, ...). Then print two lines, the firstcontaining the maximum profit the merchant can achieve. The secondline should specify the number of pruls the merchant has to buy toobtain this profit. If this number is not uniquely determined, printthe possible values in increasing order. If there are more than tenpossible values, print only the 10 smallest.  	Display a blank linebetween test cases.  
输入样例：
1
6 12 3 10 7 16 5
2
5 7 3 11 9 10
9 1 2 3 4 10 16 10 4 16
0
输出样例：
Workyards 1
Maximum profit is 8.
Number of pruls to buy: 4

Workyards 2
Maximum profit is 40.
Number of pruls to buy: 6 7 8 9 10 12 13
提示：
None



题目：Path(1710)
时间限制：10000ms
空间限制：65535kb
题目描述：
	Check if there exists a path of length L in the given tree with weight assigned to each edges.
题目输入：
	Only one test case.	The first line contains two integers n and q, which denote the number of nodes and queries, repectively.	The following (n−1) with three integers ai,bi,ci, which denote the edge between ai and bi, with weight ci.	Note that the nodes are labled by 1,2,…,n.	The last line contains q integers L1,L2,…,Lq, denote the queries.	(1≤n,q≤10^5,1≤ci≤2)	
题目输出：
		For each query, print the result in seperated line. If there exists path of given length, print "Yes". Otherwise, print "No".	
输入样例：
4 6
1 2 2
2 3 1
3 4 2
0 1 2 3 4 5

输出样例：
Yes
Yes
Yes
Yes
No
Yes

提示：




题目：DanDanliketravling(1304)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
DanDan is a smart girl,and she likes travling.Holiday is coming.So she wants to travel to America from China.With so many ways to America,she wants to choose the shortest.So she asks you to help.
题目输入：
The first line contains an integer t ( 1 <= t <= 10 ): the number of test cases. Then for each test case:The first line contains two integers n and m,where n ( n <= 10000 ) is the number of countries and m ( m <= 100000 )is the number of roads.Then next m lines each contains three elements A,B and C,that means the length from A to B is C and from B to A is also C.(The length of A and B is less than 100,C<=100)
题目输出：
For each test case, output the result in the form of sample.You should print the case number and the shortest length she will choose.If she can not arrive America,output "impossible!".
输入样例：
2
3 2
China Huodongshi 10
Huodongshi America 10
3 1
China Huodongshi 10


输出样例：
Case 1: 20
Case 2: impossible!

提示：
None



题目：AnagramGroups(1408)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
World-renowned Prof. A. N. Agram's current research deals with large anagram groups. He has just found a new application for his theory on the distribution of characters in English language texts. Given such a text, you are to find the largest anagram groups. 
A text is a sequence of words. A word w is an anagram of a word v if and only if there is some permutation p of character positions that takes w to v. Then, w and v are in the same anagram group. The size of an anagram group is the number of words in that group. Find the 5 largest anagram groups. 
题目输入：
The input contains words composed of lowercase alphabetic characters, separated by whitespace. It is terminated by EOF. 


题目输出：
Output the 5 largest anagram groups. If there are less than 5 groups, output them all. Sort the groups by decreasing size. Break ties lexicographically by the lexicographical smallest element. For each group output, print its size and its member words. Sort the member words lexicographically and print equal words only once. 


输入样例：
undisplayed
trace
tea
singleton
eta
eat
displayed
crate
cater
carte
caret
beta
beat
bate
ate
abet


输出样例：
Group of size 5: caret carte cater crate trace .
Group of size 4: abet bate beat beta .
Group of size 4: ate eat eta tea .
Group of size 1: displayed .
Group of size 1: singleton .
提示：




题目：MusicalThemes(1512)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A musical melody is represented as a sequence of N (1 <= N <= 5000) notes that are integers in the range 1..88, each representing a key on the piano. It is unfortunate but true that this representation of melodies ignores the notion of musical timing; but, this programming task is about notes and not timings. Many composers structure their music around a repeating "theme", which, being a subsequence of an entire melody, is a sequence of integers in our representation. A subsequence of a melody is a theme if it: is at least five notes long appears (potentially transposed -- see below) again somewhere else in the piece of music is disjoint from (i.e., non-overlapping with) at least one of its other appearance(s) Transposed means that a constant positive or negative value is added to every note value in the theme subsequence. Given a melody, compute the length (number of notes) of the longest theme. One second time limit for this problem's solutions!
题目输入：
There are several test cases, end by EOF, for each test case:The first line of the input file contains the integer N. Each subsequent line (except potentially the last) contains 20 integers representing the sequence of notes. The last line contains the remainder of the notes, potentially fewer than 20.
题目输出：
The output file should contain a single line with a single integer that represents the length of the longest theme. If there are no themes, output 0.
输入样例：
30
25 27 30 34 39 45 52 60 69 79 69 60 52 45 39 34 30 26 22 18
82 78 74 70 66 67 64 60 65 80
输出样例：
5
提示：
[The five-long theme is the last five notes of the first line and the first five notes of the second]



题目：万万没想到(1826)
时间限制：6000 ms
空间限制：131072 KB
题目描述：
过年了，王大锤的哥哥王小可圈了一块地玩游戏。王大锤也要圈，于是他也圈了一块。他们圈到地都是凸多边形，而且他们是按凸多边形的顶点照顺时针或逆时针一个一个圈哒。王大锤不喜欢别人的地擦到或者占到自己的地，否则他就会崩溃！问：给出王大锤和王小可的圈地情况，输出王大锤是否崩溃。
题目输入：
多case，以EOF结尾
第一行，一个整数n（3 <= n <= 100000)
接下来n行，依次的n个顶点坐标整数x0 y0（long long范围），表示王大锤依次圈的地
下一行，一个整数m（3 <= m <= 100000)
接下来m行，依次的m个顶点坐标整数x1 y1（long long范围），表示王小可依次圈的地
保证连续哒三个点不共线，保证点不多余
题目输出：
如果崩溃，输出“Crash”，否则输出“WanWanMeiXiangDao”。
输入样例：
3
0 0
0 1
1 0
3
1 0
1 1
0 1

3
0 0
0 1
1 0
3
2 0
2 1
1 1
输出样例：
Crash
WanWanMeiXiangDao
提示：




题目：Hotel(1063)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A new hotel has been built in a city where the citizens believe that the number 13 brings bad luck. The hotel has n rooms which are numbered from 1 to n inclusive. One of the main properties of a room is its unlucky value which depends on the room number. Only number whose decimal forms contain the substring "13" will be considered to be unlucky numbers. For example, 13, 132, 1313, 9130 are unlucky numbers, but 1, 3, 31, 103, 123123 are not. The unlucky value of a room is the square of the room number if the room number is unlucky, and zero otherwise.A hotel's unlucky value equals the sum of the unlucky value of all its rooms. Help the manager to calculate the unlucky value of this hotel.
题目输入：
The first line contains an integer T (T<=100) indicating the number of test cases. T lines follows, each line contains an integer k (1<=k<=100) indicating that this hotel has 10^k (the k-th power of 10) rooms.
题目输出：
For each test case, print the case number and the answer % 100003 in a single line where the answer is the unlucky value of this hotel. Follow the format of the sample output please.
输入样例：
3
1
2
3
输出样例：
Case 1: 0
Case 2: 169
Case 3: 49582
提示：




题目：island(1163)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
南太平洋的马尔代夫岛群是著名的旅游胜地，它是由若干个小岛组成的，，每个小岛都有一个收益值，有些小岛之间有桥，但是在开始时这个岛群只有一个入口，在某个小岛上，这样使得游客们感觉很不方便，于是，当地政府决定再建一个入口，他们想先把小岛群中的某一个桥破坏掉，使得小岛群变成不连通的两个部分，这样在没有入口的小岛群再建一个入口，为了保证游客量均衡，请使两个部分的收益和差值最小。
题目输入：
多case，每个case第一行使N(0 < N < 1000) M(0 < M < 5000)表示小岛和桥的数量
下面是一行有N个数值，表示每个小岛的收益值Xi(0 < Xi < 10000)
下面是M行，表示小岛X到Y之间有一座桥(0 <= X,Y <=N-1)。
题目输出：
输出分割成两个岛群后的利益和之差最小值。如果没有答案输出impossible
输入样例：
4 4
1 1 1 1
0 1
1 2
1 3
2 3
输出样例：
2
提示：




题目：Robot(1611)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		A robot arm used in anautomated factory consists of N connected links: link1 which is connected to link2, ..., and linkN- 1 which is connected to linkN. Each link isa straight rod of a specified length, len1, len2,..., lenN. Between each pairof connected links is a servo, servo2 (between link1 and link2), ..., and servoN (between linkN - 1 and linkN)that can be activated to adjust the angle between the connectedlinks. Link1 is also connected by a servo, servo1,to the factory floor (at the point x = 0, y = 0, z = 0 in a Cartesian coordinate system). At the free (unconnected) endof the last link (linkN) is a ``hand'' that can beused to grasp objects.  	In the initialsetting of the robot arm, each servo is set to no rotation (0degrees), and the links in the robot arm coincide with the z-axis.The xy plane is horizontal (the factory floor), and the entirerobot arm is initially pointing up, vertically. From this initialsetting, each servo can effect a rotation of up to 90 degrees ineither of two directions. Servo1 moves the entirerobot arm in the xz plane by rotation about the y-axis. Servo2 moves the arm (except link1)in the (perhaps rotated) yz plane by rotation about the x-axis. In a similar manner, each odd-numbered servo canrotate the remaining part of the arm in the (perhaps rotated) xz plane, and each even-numbered servo can rotate the remaining part ofthe arm in the (perhaps rotated) yz plane. In effect, theservos rotate the links about the y and x-axes ofcoordinate systems fixed to the end of each link. Counterclockwiserotations about a coordinate axis are produced with positive rotationangles, if we are looking along the positive half of the axis towardthe coordinate origin. The sample data has been carefully chosen toillustrate the effects of these rotations.  	There are tworestrictions on the final positioning of the robot's arm. No part ofthe arm can be below the factory floor, and the links in the robot'sarm cannot intersect with each other (except where they are connectedby the servos).  	You should check onlythe final position of the arm.  	Given the number oflinks in a robot's arm, their lengths, and the proposed settings ofthe servos, first determine if the proposed positioning of the arm isallowable. If the arm can be positioned as proposed, then determinethe coordinates of the robot's hand, accurate to three fractionaldigits. Otherwise identify the first (smallest numbered) servo thathas an inappropriate setting, and why that setting is inappropriate.Links are assumed to intersect if they come within 0.001 length unitsof each other.  
题目输入：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		The input data willcontain multiple test cases. Each test case includes, in order, thenumber of links, N, their lengths, len1, len2,..., lenN, and the proposedangles to which the servos (starting with servo1)are to be set. The lengths and servo angles are real numbers, and thenumber of links is an integer. There will be no more than 10 links inany robot arm. The last test case is followed by a negative integer.  
题目输出：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		For each test case,display the test case number (starting with 1). Then, if the proposedsetting is allowable, display the position of the robot's hand in theoriginal (factory floor) coordinate system (with three fractionaldigits). Otherwise display the identity of the first servo with aninappropriate setting and why that setting is inappropriate. Anoutput format similar to that shown below is acceptable.  
输入样例：
2 25 15 0 90.0
1 1.0 45.0
2 1 1 0 45
4 1 2 3 4 90 0 0 0
3 1 1 1 0 90 90
2 1 1 45.0 45
4 1 1 1 2 0 90 0 90
8 10 1 1 1 1 1 1 2
   0 0 90 0 90 0 90 0
-1
输出样例：
Case 1: robot's hand is at (0.000,-15.000,25.000)
Case 2: robot's hand is at (0.707,0.000,0.707)
Case 3: robot's hand is at (0.000,-0.707,1.707)
Case 4: robot's hand is at (10.000,0.000,0.000)
Case 5: robot's hand is at (1.000,-1.000,1.000)
Case 6: robot's hand is at (1.207,-0.707,1.207)
Case 7: servo 4 attempts to move arm below floor
Case 8: servo 8 causes link collision
提示：
None



题目：Transform(1711)
时间限制：3000ms
空间限制：65535kb
题目描述：
	One can transform x into x+d if d is divisor of x. Find out the minimum number of steps to transform a into b. (d is positive)
题目输入：
	Each test case contains two integers a and b.(1≤a,b≤10^5). Ends with EOF.
题目输出：
	The only integer denotes the minimum number of steps. Print -1 if impossible.
输入样例：
1 6

输出样例：
3

提示：
1->2->4->6 or 1->2->3->6



题目：红色珠子(1827)
时间限制：4000 ms
空间限制：65536 KB
题目描述：
fishhead有一串珠子，当然是环状的，而且均匀分布在圆环上。现在fishhead有红、黄、蓝三种颜色，想要给这串珠子涂色，使得珠子变得好看一点，每个珠子都必须涂上其中的一种颜色，并且只能涂一种颜色，不能一个珠子涂多种，这样不符合fishhead的省美观，于是fishhead就好奇，一共有多少种本质上不同的涂法呢？如果一种涂法的珠子通过旋转和翻转能够变成另外一种涂法，那么这两种涂法本质上是相同的。
聪明的鱼儿子一下就解决了这个问题，fishhead很高兴，不过紧接着就是烦恼，因为鱼儿子给fishhead出了一个更难的题目，鱼儿子喜欢红色，现在要求，涂好颜色后的这么多珠子中必须有一定数量的红色，他想知道在这个限制条件下一共有多少种本质上不同的涂法？因为这个数字可能很大，所以只要知道这个数字Mod 1000000007的值。
题目输入：
数据的第一行输入一个T(T<=50)，表示有T组测试数据。
接下来每组测试数据包括1行，2个数字，n和m(1<=n<=100000, 0<=m<=n)，表示有n个珠子，最后至少有m个红色的珠子。
题目输出：
每组测试数据输出一行一个数字。
输入样例：
2
3 0
3 2
输出样例：
10
3
提示：




题目：EasyProblem(1305)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
In space coordinate, calculate a position(x1,y1,z1) after point(x,y,z) rotating A degrees around a vector.
题目输入：
The first line contains an integer t ( 1 <= t <= 100 ): the number of test cases. Then for each test case:First line contains three numbers x0,y0,z0,where x,y,z are the position of the point.Second line contains three numbers x2,y2,z2,where x2,y2,z2 are the position of the point in the vector.Third line contains three numbers dx,dy,dz,where dx,dy,dz are the direction of the vector.The last line contains a number A,where A is the degree.
题目输出：
For each test case,  output the result in the form of sample.You should print the case number and the position(x1,y1,z1) after point(x,y,z) rotating A degrees around a vector.Your answer is supposed to be rounded to three decimal digits.
输入样例：
2
5.1 10.1 11.1
2.0 3.0 4.0
1.0 1.0 1.0
360
5.0 10.0 11.0
2.0 3.0 4.0
1.0 1.0 1.0
180
输出样例：
Case 1:
5.100 10.100 11.100
Case 2:
10.333 7.333 8.333
提示：
None



题目：Mahjong(1064)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Mahjong is a wonderful game which origins from China (or maybe Korea because everything is Korean).Mahjong is also a complex game. But the game we play here is rather easy. It just contains three suits: stones, bamboos and characters.Stones consist of a number of circles. Each circle is said to represent can (筒, tóng) coins with a square hole in the middle.

Bamboos consist of a number of bamboo sticks. Each stick is said to represent a string (索, suǒ) that holds a hundred coins. Note that 1 Bamboo is an exception: it has a bird sitting on a bamboo, to prevent alteration.

Each character represents ten thousand (萬, wàn) coins.

A player wins the round by creating a standard mahjong hand, which consists of a certain number of melds (namely, four for 13-tile variations) and a pair. A meld is three tiles which are adjacent in one suit or all the same. A pair is two same tiles.Now one player has three tiles in hand. Can you tell what more tile he need to win?Note that the number of each tile in Mahjong is four. So if the number of one tile the player has is four, he cannot get this tile anymore.
 
题目输入：
The first line contains one integer T indicating the number of test cases.
For each case, there are thirteen tiles in one line, separated by one space.
Each tile has two characters. The first character is ‘1’ to ‘9’ and the second is ‘s’ (for stone), ‘b’ (for bamboo), or ‘c’ (for character).
题目输出：
For each case, output one line containing the case number and all the tiles he needs to win the round, separated by one space.
If he needs more than one tile, first output stone, then bamboo, finally character, all from 1 to 9.
7
If he cannot win after get any tile, output “None” instead.
Please follow the format of the sample output.
输入样例：
5
1b 1b 2b 2b 3b 3b 5s 6s 7s 1c 1c 2c 2c
3s 4s 4s 5s 5s 5s 6s 6s 7s 9c 9c 4c 5c
1s 1s 1s 2s 3s 4s 5s 6s 7s 8s 9s 9s 9s
4b 5b 6b 7b 8b 8b 8b 2b 3b 4b 5s 6s 7s
4c 5c 6c 9b 9b 9b 9b 1s 2s 3s 2s 3s 4s
输出样例：
Case 1: 1c 2c
Case 2: 3c 6c
Case 3: 1s 2s 3s 4s 5s 6s 7s 8s 9s
Case 4: 1b 3b 4b 6b 7b 9b
Case 5: None
提示：
In case 3, if the player gets 1s, he can combine them into four melds (1s1s1s, 1s2s3s, 4s5s6s, 7s8s9s) and a pair (9s9s). And so it is with 2s to 9s.
2s: 1s1s1s, 3s4s5s, 6s7s8s, 9s9s9s, 2s2s
3s: 1s2s3s, 3s4s5s, 6s7s8s, 9s9s9s, 1s1s
4s: 1s1s1s, 2s3s4s, 4s5s6s, 7s8s9s, 9s9s
5s: 1s1s1s, 2s3s4s, 6s7s8s, 9s9s9s, 5s5s
6s: 1s2s3s, 4s5s6s, 6s7s8s, 9s9s9s, 1s1s
7s: 1s1s1s, 2s3s4s, 5s6s7s, 7s8s9s, 9s9s
8s: 1s1s1s, 2s3s4s, 5s6s7s, 9s9s9s, 8s8s
9s: 1s2s3s, 4s5s6s, 7s8s9s, 9s9s9s, 1s1s



题目：SnailTrails(1513)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Sally Snail likes to stroll on a N x N square grid (1 <n <= 120). She always starts in the upper left corner of the grid. The grid has empty squares (denoted below by `.') and a number (B) of barriers (denoted below by `#'). Here is a depiction of a grid including a demonstration of the grid labelling algorithm:           A B C D E F G H        1 S . . . . . # .        2 . . . . # . . .        3 . . . . . . . .        4 . . . . . . . .        5 . . . . . # . .        6 # . . . . . . .        7 . . . . . . . .        8 . . . . . . . .Sally travels vertically (up or down) or horizontally (left or right). Sally can travel either down or right from her starting location, which is always A1. Sally travels as long as she can in her chosen direction. She stops and turns 90 degrees whenever she encounters the edge of the board or one of the barriers. She can not leave the grid or enter a space with a barrier. Additionally, Sally can not re-cross any square she has already traversed. She stops her traversal altogether any time she can no longer make a move. Here is one sample traversal on the sample grid above:           A B C D E F G H        1 S---------+ # .        2 . . . . # | . .        3 . . . . . | . .        4 . . . . . +---+        5 . . . . . # . |        6 # . . . . . . |        7 +-----------+ |        8 +-------------+Sally traversed right, down, right, down, left, up, and right. She could not continue since she encountered a square already visited. Things might have gone differently if she had chosen to turn back toward our left when she encountered the barrier at F5. Your task is to determine and print the largest possible number of squares that Sally can visit if she chooses her turns wisely. Be sure to count square A1 as one of the visited squares.
题目输入：
There are several test cases, end by EOF, for each test case:The first line of the input has N, the dimension of the square, and B, the number of barriers (1 <= B <= 200). The subsequent B lines contain the locations of the barriers. The sample input file below describes the sample grid above. The sample output file below is supposed to describe the traversal shown above. Note that when N > 26 then the input file can not specify barriers to the right of column Z.
题目输出：
The output file should consist of exactly one line, the largest possible number of squares that Sally can visit.
输入样例：
8 4
E2
A6
G1
F5
输出样例：
33
提示：
Using this traversal:           A B C D E F G H        1 S . . . . . # .        2 | . . . # . . .        3 | . . . +-----+        4 | . . . | . . |        5 +-------+ # . |        6 # . . . . . . |        7 +------------ |        8 +-------------+



题目：LetitBead(1409)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
"Let it Bead" company is located upstairs at 700 Cannery Row in Monterey, CA. As you can deduce from the company name, their business is beads. Their PR department found out that customers are interested in buying colored bracelets. However, over 90 percent of the target audience insists that the bracelets be unique. (Just imagine what happened if two women showed up at the same party wearing identical bracelets!) It's a good thing that bracelets can have different lengths and need not be made of beads of one color. Help the boss estimating maximum profit by calculating how many different bracelets can be produced. 
A bracelet is a ring-like sequence of s beads each of which can have one of c distinct colors. The ring is closed, i.e. has no beginning or end, and has no direction. Assume an unlimited supply of beads of each color. For different values of s and c, calculate the number of different bracelets that can be made. 
题目输入：
Every line of the input file defines a test case and contains two integers: the number of available colors c followed by the length of the bracelets s. Input is terminated by c=s=0. Otherwise, both are positive, and, due to technical difficulties in the bracelet-fabrication-machine, cs<=32, i.e. their product does not exceed 32. 


题目输出：
For each test case output on a single line the number of unique bracelets. The figure below shows the 8 different bracelets that can be made with 2 colors and 5 beads. 


输入样例：
1 1
2 1
2 2
5 1
2 5
2 6
6 2
0 0


输出样例：
1
2
3
5
8
13
21


提示：




题目：Avatar(1164)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
公元2050年，人类科技已经到达登峰造极的境界，但是地球的能源也濒于枯竭，为了拯救地球上的人类，银河舰队总指挥官Fishhead向国际军事联盟提议，攻打距离地球100光年之外的潘多拉星球，因为潘多拉星球上有一种别的星球都没有的矿物元素”unobtanium”,它能够彻底缓解人类的能源危机。可是潘多拉星球上居住着一种叫做纳威人的土著，他们要誓死捍卫自己的星球。毕竟攻打其他生物居住的星球是一件影响人类生死存亡的大事，国际军事联盟最后决定，由全世界所有的N个国家的首脑进行投票，以决定最后是否攻打该星球。显然并不是所有的国家都会投赞成票，尤其是一向主张正义的中国，每个国家的首脑心里都有代表自己国民想法的意愿，但是国与国之间的友好关系也是他们必须考虑的，如果和同自己国家交往友好的国家投不同意见的票可能会造成国家关系紧张。
怎么办呢，为了将这种冲突降低到最低的程度，我们首先定义冲突数，如果某个国家投了和自己意愿相反的票，那么冲突数加1，如果某个国家投了与友好国家不同的票，冲突数加1，现在我们要求这个最少的冲突数。用这种投票方案，来决定是否攻打潘多拉星球。
题目输入：
第一行一个数代表case数。
对于每一个case:
第一行只有两个整数n，m，保证有2 ≤ n ≤ 300，1 ≤ m ≤ n ( n-1 ) / 2。其中n代表国家数，m代表友好国家的对数。文件第二行有n个整数，第i个整数代表第i个国家的意愿，当它为1时表示同意攻打潘多拉，当它为0时表示反对攻打。接下来文件还有m行，每行有两个整数i，j。表示i，j是一对友好国家，我们保证任何两对i，j不会重复。 

题目输出：
对于每一个case,输出一个整数，即可能的最小冲突数。
输入样例：
1
3 3
1 0 0
1 2
1 3
3 2

输出样例：
1
提示：




题目：Triangles(1712)
时间限制：10000ms
空间限制：65535kb
题目描述：
	How many triple of points A(xA,yA),B(xB,yB),C(xC,yC) which:	  •   xA,yA,xB,yB,xC,yC∈Z , Z means integers.	  •   0≤xA,xB,xC<n,0≤yA,yB,yC<m	  •   S△ABC∉Z? (S△ denotes the area of triangle)	
题目输入：
	Input ends with EOF.	Each test case contains two integers n and m. (1≤n,m≤10^9)	
题目输出：
	The only integer denotes the number possible triples, modulo 10^9+7.
输入样例：
2 2

输出样例：
24

提示：
There are 4 triangles.
Each of them is counted 6 times.



题目：TheLetterCarrier'sRounds(1612)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }		PRE.cjk { font-family: "DejaVu Sans Condensed", monospace }		TT.cjk { font-family: "DejaVu Sans Condensed", monospace }	-->		For an electronic mailapplication you are to describe the SMTP-based communication thattakes place between pairs of MTAs. The sender's User Agent gives aformatted message to the sending Message Transfer Agent (MTA). Thesending MTA communicates with the receiving MTA using the Simple MailTransfer Protocol (SMTP). The receiving MTA delivers mail to thereceiver's User Agent. After a communication link is initialized, thesending MTA transmits command lines, one at a time, to the receivingMTA, which returns a three-digit coded response after each command isprocessed. The sender commands are shown below in the order sent foreach message. There is more than one RCPT TO line when the samemessage is sent to several users at the same MTA. A message to usersat different MTAs requires separate SMTP sessions.  HELO myname Identifies the sender to the receiver (yes, there is only one L)  MAIL             FROM:< sender > Identifies the message sender  RCPT             TO:< user > Identifies one recipient of the message  DATA                             Followed by an arbitrary number of lines of text comprising the message  body, ending with a line containing a period in column one.  QUIT                             Terminates the communication.	The following responsecodes are sent by the receiving MTA:  			221  				Closing connection (after	QUIT)  				250  				Action was okay (after	MAIL FROM and RCPT TO specifying an acceptable user, or completion	of a message)  				354  				Start sending mail (after	DATA)  				550  				Action not taken; no such	user here (after RCPT TO with unknown user)  	
题目输入：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		The input containsdescriptions of MTAs followed by an arbitrary number of messages.Each MTA description begins with the MTA designation and its name (1to 15 alphanumeric characters). Following the MTA name is the numberof users that receive mail at that MTA and a list of the users (1 to15 alphanumeric characters each). The MTA description is terminatedby an asterisk in column 1. Each message begins with the sendinguser's name and is followed by a list of recipient identifiers. Eachidentifier has the form user@mtaname. The message(each line containing no more than 72 characters) begins andterminates with an asterisk in column 1. A line with an asterisk incolumn 1 instead of a sender and recipient list indicates the end ofthe entire input.  
题目输出：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		For each message, showthe communication between the sending and receiving MTAs. Every MTAmentioned in a message is a valid MTA; however, message recipientsmay not exist at the destination MTA. The receiving MTA rejects mailfor those users by responding to the RCPT TO command with the 550code. A rejection will not affect delivery to authorized users at thesame MTA. If there is not at least one authorized recipient at aparticular MTA, the DATA is not sent. Only one SMTP session is usedto send a message to users at a particular MTA. For example, amessage to 5 users at the same MTA will have only one SMTP session.Also a message is addressed to the same user only once. The order inwhich receiving MTAs are contacted by the sender is the same as inthe input file. As shown in the sample output, prefix thecommunication with the communicating MTA names, and indent eachnon-empty communication line. No innecessary spaces should beprinted.  
输入样例：
MTA London 4 Fiona Paul Heather Nevil
MTA SanFrancisco 3 Mario Luigi Shariff
MTA Paris 3 Jacque Suzanne Maurice
MTA HongKong 3 Chen Jeng Hee
MTA MexicoCity 4 Conrado Estella Eva Raul
MTA Cairo 3 Hamdy Tarik Misa
*
Hamdy@Cairo Conrado@MexicoCity Shariff@SanFrancisco Lisa@MexicoCity
*
Congratulations on your efforts !!
--Hamdy
*
Fiona@London Chen@HongKong Natasha@Paris
*
Thanks for the report!  --Fiona
*
*
输出样例：
Connection between Cairo and MexicoCity
     HELO Cairo
     250
     MAIL FROM:
     250
     RCPT TO:
     250
     RCPT TO:
     550
     DATA
     354
     Congratulations on your efforts !!
     --Hamdy
     .
     250
     QUIT
     221
Connection between Cairo and SanFrancisco
     HELO Cairo
     250
     MAIL FROM:
     250
     RCPT TO:
     250
     DATA
     354
     Congratulations on your efforts !!
     --Hamdy
     .
     250
     QUIT
     221
Connection between London and HongKong
     HELO London
     250
     MAIL FROM:
     250
     RCPT TO:
     250
     DATA
     354
     Thanks for the report!  --Fiona
     .
     250
     QUIT
     221
Connection between London and Paris
     HELO London
     250
     MAIL FROM:
     250
     RCPT TO:
     550
     QUIT
     221
提示：
None



题目：出现次数最多的数(1828)
时间限制：1.0s
空间限制：256MB
题目描述：
　　给定n个正整数，找出它们中出现次数最多的数。如果这样的数有多个，请输出其中最小的一个。
题目输入：
　　输入的第一行只有一个正整数n(1 ≤ n ≤ 1000)，表示数字的个数。
　　输入的第二行有n个整数s1, s2, …, sn (1 ≤ si ≤ 10000, 1 ≤ i ≤ n)。相邻的数用空格分隔。
题目输出：
　　输出这n个次数中出现次数最多的数。如果这样的数有多个，输出其中最小的一个。
样例输入
输入样例：
6
10 1 10 20 30 20
输出样例：
10
提示：
多组输入数据，以EOF结尾



题目：FirstFruit(1306)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
In space coordinate, there are two lines.Now you can choose a point from each line.I want to make the distance of the two points the shortest.Now how do you choose the two points? It is promised that there is only one pair of the two points.How easy it is.Solve the problem first,so you can get a fruit.
题目输入：
The first line contains an integer t ( 1 <= t <= 100 ): the number of test cases. Then for each test case:First line contains six numbers x0,y0,z0,x1,y1,z1,where they are the positions of the two points in the first line.Second line contains six numbers x2,y2,z2,x3,y3,z3,where they are the positions of the two points in the second line.
题目输出：
For each test case,  output the result in the form of sample.You should print the case number and the two points in the next two lines.(the point in the first line should be printed first.)
输入样例：
1
4.0 16.0 96.0 46.0 72.0 46.0
33.0 47.0 70.0 50.0 35.0 14.0
输出样例：
Case 1:
28.514 48.685 66.817
33.390 46.725 68.717
提示：
None



题目：ElectricFences(1514)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer John has decided to construct electric fences. He has fenced his fields into a number of bizarre shapes and now must find the optimal place to locate the electrical supply to each of the fences. A single wire must run from some point on each and every fence to the source of electricity. Wires can run through other fences or across other wires. Wires can run at any angle. Wires can run from any point on a fence (i.e., the ends or anywhere in between) to the electrical supply. Given the locations of all F (1 <= F <= 150) fences (fences are always parallel to a grid axis and run from one integer gridpoint to another, 0 <= X,Y <= 100), your program must calculate both the total length of wire required to connect every fence to the central source of electricity and also the optimal location for the electrical source. The optimal location for the electrical source might be anywhere in Farmer John's field, not necessarily on a grid point.
题目输入：
There are several test cases, end by EOF, for each test case:The first line contains F, the number of fences.F subsequent lines each contain two X,Y pairs each of which denotes the endpoints of a fence.
题目输出：
30 0 0 12 0 2 10 3 2 3
输入样例：
On a single line, print three space-separated floating point numbers, each with a single decimal place. Presume that your computer's output library will round the number correctly. 

The three numbers are: 

the X value of the optimal location for the electricity, 
the Y value for the optimal location for the electricity, and 
the total (minimum) length of the wire required.
输出样例：
1.0 1.6 3.7
提示：




题目：Pie(1065)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
A lot of boys and girls come to our company to pie friends. After we get their information, we need give each of them an advice for help. We know everyone’s height, and we believe that the less difference of a girl and a boy has, the better it is. We need to find as more matches as possible, but the total difference of the matches must be minimum.
题目输入：
The input consists of multiple test cases. The first line of each test case contains two integers, n, m (0 < n, m <= 10000), which are the number of boys and the number of girls. The next line contains n float numbers, indicating the height of each boy. The last line of each test case contains m float numbers, indicating the height of each girl. You can assume that |n – m| <= 100 because we believe that there is no need to do with that if |n – m| > 100. All of the values of the height are between 1.5 and 2.0.
The last case is followed by a single line containing two zeros, which means the end of the input.
题目输出：
Output the minimum total difference of the height. Please take it with six fractional digits.
输入样例：
2 3
1.5 2.0
1.5 1.7 2.0
0 0
输出样例：
0.000000
提示：




题目：人气王(1165)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
50年之后，南理工集训队队伍已经发展的很大，已经有上百个成员了（当然，鱼头哥那时候已经成为鱼爷爷啦~，鱼儿子继续着这项伟大而神圣的工作~嘻嘻）
   集训队的成员都各有特色，因此每个人在队里都有自己的崇拜对象，比如说Master很崇拜小倩姐姐，豆豆很崇拜小芹美女（开玩笑哈）。。。。现在集训队里有N个人（(1 <= N <= 10,000)，给出M (1 <= M <= 50,000)个关系（A,B），代表A崇拜B，而且，这个关系满足传递性，如果A崇拜B，B崇拜C，那么A就崇拜C。
那些被所有人都崇拜的号称“人气王”，小文姐姐很想知道自己是不是“人气王”，因此现在她找到你，让你计算“人气王”的个数。
题目输入：
* Line 1: 两个数字, N 和 M 

* Lines 2..1+M: 两个数字 A 和 B(用空格隔开), 那么A崇拜 B。 (A和B都是从1到N之间取值)
以文件尾结束！

题目输出：
* Line 1: 一个数字，被集训队所以人崇拜的人的个数。
输入样例：
5 5
1 2
2 3
2 4
3 1
4 5

输出样例：
1
提示：




题目：NewProblem(1410)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
You are to write an interpreter for a simple computer. This computer uses a processor with a small number of machine instructions. Furthermore, it is equipped with 32 byte of memory, one 8-bit accumulator (accu) and a 5-bit program counter (pc). The memory contains data as well as code, which is the usual von Neumann architecture. 
The program counter holds the address of the instruction to be executed next. Each instruction has a length of 1 byte - the highest 3 bits define the type of instruction and the lowest 5 bits define an optional operand which is always a memory address (xxxxx). For instructions that don't need an operand the lowest 5 bits have no meaning (-----). Here is a list of the machine instructions and their semantics: 
000xxxxx   STA x   store the value of the accu into memory byte x001xxxxx   LDA x   load the value of memory byte x into the accu010xxxxx   BEQ x   if the value of the accu is 0 load the value x into the pc011-----   NOP     no operation100-----   DEC     subtract 1 from the accu101-----   INC     add 1 to the accu110xxxxx   JMP x   load the value x into the pc111-----   HLT     terminate program
In the beginning, program counter and accumulator are set to 0. After fetching an instruction but before its execution, the program counter is incremented. You can assume that programs will terminate. 
题目输入：
The input file contains several test cases. Each test case specifies the contents of the memory prior to execution of the program. Byte 0 through 31 are given on separate lines in binary representation. A byte is denoted by its highest-to-lowest bits. Input is terminated by EOF.
题目输出：
For each test case, output on a line the value of the accumulator on termination in binary representation, again highest bits first.
输入样例：
00111110
10100000
01010000
11100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00111111
10000000
00000010
11000010
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111
10001001

输出样例：
10000111


提示：




题目：Xor(1713)
时间限制：10000ms
空间限制：65535kb
题目描述：
	For given multisets A and B, find minimum non-negative x which A⊕x=B.	Note that for A={a1,a2,…,an}, A⊕x={a1⊕x,a2⊕x,…,an⊕x}. ⊕ stands for exclusive-or.	
题目输入：
	The input ends with EOF. For each test case:	The first line contains a integer n, which denotes the size of set A (also for B).	The second line contains n integers a1,a2,…,an, which denote the set A.	The thrid line contains n integers b1,b2,…,bn, which denote the set B.	(1≤n≤10^5, n is odd, 0≤ai,bi<2^30)	
题目输出：
	The only integer denotes the minimum x. Print −1 if no such x exists.
输入样例：
3
0 1 3
1 2 3

输出样例：
2

提示：
please pay attention, A=B means A and B contains the same element , not necessary ai = bi.



题目：Flooded!(1613)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		To enable homebuyers toestimate the cost of flood insurance, a real-estate firm providesclients with the elevation of each 10-meter by 10-meter square ofland in regions where homes may be purchased. Water from rain,melting snow, and burst water mains will collect first in thosesquares with the lowest elevations, since water from squares ofhigher elevation will run downhill. For simplicity, we also assumethat storm sewers enable water from high-elevation squares in valleys(completely enclosed by still higher elevation squares) to drain tolower elevation squares, and that water will not be absorbed by theland.  	From weather dataarchives, we know the typical volume of water that collects in aregion. As prospective homebuyers, we wish to know the elevation ofthe water after it has collected in low-lying squares, and also thepercentage of the region's area that is completely submerged (thatis, the percentage of 10-meter squares whose elevation is strictlyless than the water level). You are to write the program thatprovides these results.  
题目输入：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		The input consists of asequence of region descriptions. Each begins with a pair of integers, m and n, each less than 30, giving the dimensions ofthe rectangular region in 10-meter units. Immediately following are m lines of n integers giving the elevations of the squares inrow-major order. Elevations are given in meters, with positive andnegative numbers representing elevations above and below sea level,respectively. The final value in each region description is aninteger that indicates the number of cubic meters of water that willcollect in the region. A pair of zeroes follows the description ofthe last region.  
题目输出：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		For each region,display the region number (1, 2, ...), the water level (in metersabove or below sea level) and the percentage of the region's areaunder water, each on a separate line. The water level and percentageof the region's area under water are to be displayed accurate to twofractional digits. Follow the output for each region with a blankline.  
输入样例：
3 3
25 37 45
51 12 34
94 83 27
10000
0 0
输出样例：
Region 1
Water level is 46.67 meters.
66.67 percent of the region is under water.
提示：
None



题目：ISBN号码(1829)
时间限制：1.0s
空间限制：256MB
题目描述：
　　每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括9位数字、1位识别码和3位分隔符，其规定格式如“x-xxx-xxxxx-x”，其中符号“-”是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如0代表英语；第一个分隔符“-”之后的三位数字代表出版社，例如670代表维京出版社；第二个分隔之后的五位数字代表该书在出版社的编号；最后一位为识别码。
　　识别码的计算方法如下：
　　首位数字乘以1加上次位数字乘以2……以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。例如ISBN号码0-670-82162-4中的识别码4是这样得到的：对067082162这9个数字，从左至右，分别乘以1，2，…，9，再求和，即0×1+6×2+……+2×9=158，然后取158 mod 11的结果4作为识别码。
　　编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出“Right”；如果错误，则输出是正确的ISBN号码。
题目输入：
　　输入只有一行，是一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码的格式要求）。
题目输出：
　　输出一行，假如输入的ISBN号码的识别码正确，那么输出“Right”，否则，按照规定的格式，输出正确的ISBN号码（包括分隔符“-”）。
输入样例：
0-670-82162-40-670-82162-0
输出样例：
Right0-670-82162-4
提示：
多组输入，以EOF结尾



题目：WisconsinSquares(1515)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
It's spring in Wisconsin and time to move the yearling calves to the yearling pasture and last year's yearlings to the greener pastures of the north 40. Farmer John has five kinds of cows on his farm (abbreviations are shown in parentheses): Guernseys (A), Jerseys (B), Herefords (C), Black Angus (D), and Longhorns (E). These herds are arranged on the 16 acre pasture, one acre for each small herd, on a 4 x 4 grid (labeled with rows and columns) like this:               1 2 3 4             +-------            1|A B A C            2|D C D E            3|B E B C            4|C A D EIn the initial pasture layout, the herds total 3 A's, 3 B's, 4 C's, 3 D's, and 3 E's. This year's calves have one more D herd and one fewer C herd, for a total of 3 A's, 3 B's, 3 C's, 4 D's, and 3 E's. FJ is extremely careful in his placement of herds onto his pasture grid. This is because when herds of the same types of cows are too close together, they misbehave: they gather near the fence and smoke cigarettes and drink milk. Herds are too close together when they are on the same square or in any of the eight adjacent squares. Farmer John must move his old herd out of the field and his new herd into the field using his old brown Ford pickup truck, which holds one small herd at a time. He picks up a new herd, drives to a square in the yearling pasture, unloads the new herd, loads up the old herd, and drives the old herd to the north 40 where he unloads it. He repeats this operation 16 times and then drives to Zack's for low-fat yogurt treats and familiar wall decor. Help Farmer John. He must choose just exactly the correct order to replace the herds so that he never puts a new herd in a square currently occupied by the same type of herd or adjacent to a square occupied by the same type of herd. Of course, once the old cows are gone and the new cows are in place, he must be careful in the future to separate herds based on the new arrangement. Very important hint: Farmer John knows from past experience that he must move a herd of D cows first. Find a way for Farmer John to move the yearlings to their new pasture. Print the 16 sequential herd-type/row/column movements that lead to a safe moving experience for the cows. Calculate the total number of possible final arrangements for the 4x4 pasture and calculate the total number of ways those arrangements can be created.
题目输入：
There are several test cases, end by EOF, for each test case:Four lines, each with four letters that denote herds.
题目输出：
16 lines, each with a herd-type, row and column. If there are multiple solutions (and there are), you should output the solution for which the concatenated string ("D41C42A31 ... D34") of the answers is first in lexicographic order. One more line with the total number of ways these arrangements can be created.
输入样例：
ABAC
DCDE
BEBC
CADE
输出样例：
D 4 1
C 4 2
A 3 1
A 3 3
B 2 4
B 3 2
B 4 4
E 2 1
E 2 3
D 1 4
D 2 2
C 1 1
C 1 3
A 1 2
E 4 3
D 3 4
14925
提示：




题目：Precious(1066)
时间限制：10000 ms
空间限制：65535 ms
题目描述：
Gollum is finding his Precious. The precious is hiding in a magic maze. The maze can be considered as a simple polygon. Some vertexes of the polygon are doors that can only allow Gollum to get in, and the other doors can only allow Gollum to get out.Gollum doesn’t know that restrict, he choose a door to get in, and choose a door to get out after he has got his precious. Gollum hasn’t learned math, so we believe that Gollum choose the door randomly, that means if there are n doors, the probability of a door chose by Gollum is 1/n.There is a monster in the maze, and if Gollum stay in the maze more than m minutes, the monster will wake up and eat Gollum. Gollum can move one unit distance by one minute.We want to know the probability that Gollum got his precious.
题目输入：
The input consists of multiply test cases. The first line of each test case contains two integers, n (3 <= n <= 100), m (0 <= m <= 10000), where n is the number of vertexes of the maze, and m is the time limit. The next n lines represent the maze, each line contains a coordinate, x, y (-10000 <= x, y <= 10000) and a DoorType. If DoorType equals to -1, then you can get in from this vertex; if DoorType equals to 0, then it’s not a door; if DoorType equals to 1, then you can get out from this vertex. The last line of each test case is a coordinate, indicating the location of the precious. You can assume that the precious is always in the maze.
The last test case is followed by a line containing two zeros, which means the end of the input.
题目输出：
Output the probability. Please take it with 9 factional digits.
输入样例：
12 4
-2 -1 -1
-1 -1 -1
-1 -2 -1
1 -2 -1
1 -1 -1
2 -1 -1
10
2 1 1
1 1 1
1 2 1
-1 2 1
-1 1 1
-2 1 1
0 0
0 0
输出样例：
0.138888889
提示：




题目：Gauss(1307)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
1+2+3+...+n-1+n=(n+1)*n/2;Guass was the first to discover this equation. Now your task is to give the result of the following formula.a*(a+1)*(a+2)*..(a+k)+(a+1)*(a+2)*..(a+k)*(a+k+1)+...+n*(n+1)*(n+2)*..(n+k-1)*(n+k)
题目输入：
The first line contains an integer t ( 1 <= t <= 10 ): the number of test cases. Then for each test case:The first line contains three integers a,k,n ( 0 < a <= 1000 , 0 <= k <= 1000 ,a < n <=10^8).
题目输出：
For each test case, output the result in the form of sample.You should print the case number and the answer mod 100000007.
输入样例：
2
1 0 100
2 4 10
输出样例：
Case 1: 5050
Case 2: 600480
提示：
None



题目：Equidistance(1411)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Alice and Bob haven't met for some time. Bob isn't very happy about this, so he urges Alice to finally make time for a meeting. Let's listen to an extract from a phone call: 
Alice: ... maybe we should meet on neutral territory. Bob: I've already heard this from you --- two years ago. Alice: I know ; I just haven't found yet a suitable place that is roughly at the same distance from both yours and mine. Bob: Well, the geometric place of the points that are equidistant from two given points on the surface of a sphere (and the earth is a sphere rather than a disc) is a great circle (namely the one which intersects the great circle through the given points orthogonally at the center of them). If you insist only on approximately equal distances though, we get a zone of some kilometers width and about 40000 km length. Not everything in this zone is water. Thus I think it is a feasible task to find a fitting place. Alice: Now, if I tell you to pick any, we'll certainly land up in Honolulu. Bob: Which is not a too bad idea. So, may I pick any ? Alice: As long as I don't have to accept --- but I'm open to suggestions. Bob: Honolulu ? Alice: Is it situated on aforementioned geometric place at all ??! Bob: Not quite ... 
Nice. Now let's stop the preliminaries and come to the facts: Given two locations on the earth's surface you can find the geometric place of all equidistant points on the surface. For another given location calculate its distance on the surface to this geometric place. Assume that the earth is a sphere with a radius of 6378 km. 
题目输入：
The input file consists of two parts: a list of locations and a list of queries. 

The location list consists of up to 100 lines, one line per location. Each contains a string and two floating-point numbers, separated by whitespace, representing the name of the location, its latitude and its longitude. Names are unique and shorter than 30 characters and do not contain whitespace. Latitudes are between -90 (South Pole) and 90 (North Pole) inclusive. Longitudes are between -180 and 180 inclusive where negative numbers denote locations west of the meridian and positive numbers denote locations east of the meridian. (The meridian passes through Greenwich, London.) The location list is terminated by a line consisting of a single "#". 

Each line in the query list contains three names of locations. You can assume the first location to be Alice's home, the second location to be Bob's home and the third location to be a possible meeting point. The query list is terminated by a line consisting of a single "#". 


题目输出：
For each query, output a line saying "M is x km off A/B equidistance." with M,x,A,B appropriately replaced by the location names and the calculated distance rounded to the nearest integer. 

If one of the locations in the query didn't occur in the list of locations print "?" instead of the distance. 


输入样例：
Ulm             48.700 10.500
Freiburg        47.700 9.500
Philadelphia    39.883 -75.250
SanJose         37.366 -121.933
Atlanta         33     -84
Eindhoven       52     6
Orlando         28     -82
Vancouver       49     -123
Honolulu        22     -157
NorthPole       90     0
SouthPole       -90    0
#
Ulm Freiburg Philadelphia
SanJose Atlanta Eindhoven
Orlando Vancouver Honolulu
NorthPole SouthPole NorthPole
Ulm SanDiego Orlando
NorthPole SouthPole SouthPole
Ulm Honolulu SouthPole
#


输出样例：
Philadelphia is 690 km off Ulm/Freiburg equidistance.
Eindhoven is 3117 km off SanJose/Atlanta equidistance.
Honolulu is 4251 km off Orlando/Vancouver equidistance.
NorthPole is 10019 km off NorthPole/SouthPole equidistance.
Orlando is ? km off Ulm/SanDiego equidistance.
SouthPole is 10019 km off NorthPole/SouthPole equidistance.
SouthPole is 1494 km off Ulm/Honolulu equidistance.


提示：




题目：仙四之封神陵二欲A此题，先A封一(1166)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
华仔第一次打句芒GG了，杯具的他忘记储存了。所以，他又再次来到了封神陵。这次他一不小心，那个转转转过了2秒，华仔现在只知道2秒后的状态了，他如果知道1秒后的状态就可以像封神陵一中那么做了。现在给你2秒后的置换，要你输出1秒后的状态。（由于结果可能不止一种，输入数据保证可能的解为1或2种,如果有2个解，输出字典序较小的那个）。
题目输入：
第一行一个CASE。第二行一个整数N，下面一行有N个整数，代表2秒后的状态.
题目输出：
1秒后的转转状态
输入样例：
1
3
3 1 2

输出样例：
2 3 1
提示：




题目：第k个1(1714)
时间限制：1000ms
空间限制：65536K
题目描述：
Shangke7788对数字比较感兴趣，经常玩弄数字间的逻辑关系。 某一天发现了这样一串奇妙的4个连续数字: 5, 6, 7, 8，这四个数字它存在这样一种特殊的关系，我们分别将他们转化成二进制数，5(101)，6(110)，7(111)，8(1000)，其中5的第一位是1，6的第二位是1，7的第三位是1，8的第四位是1，而下一个数字9(1001)，的第5位不是1，因此不能归于这组序列中。于是他就把这种数串定义为shangke数列，以下给出shangke数列的定义： (1) 这个数列都是有限数列，所有数字都是自然数. (2) 数列后一个数字永远比前一个数字大1. (3) 数列中第1个数二进制的第1位(最低位)是1，第2个数二进制的第2位(次低位)是1，依次类推，假设数列共有n个元素，那么对于任意的1<=k<=n，ak表示第k个数，那么ak的二进制的第k位必须是1。 符合上述3个条件的数列称为shangke数列. shangke数列的大小以最小的数字作为其大小的象征，元素个数不同的2个shangke数列不能比较大小。
题目输入：
第一行输入一个整数T, 表示有T组测试数据。每组Case，输入两个整数n(1<=n<=10^18), k(1<=k<=10^18)，表示第k大的含有n个数字的shangke数列。
题目输出：
输出以Case X: N的形式，X是当前的Case数目，从1开始计数，N为当前Case的shangke数列最小的数字 MOD (10^9+9)的值
输入样例：
2
2 1
4 1
输出样例：
Case 1: 1
Case 2: 5
提示：
None



题目：ToAddortoMultiply(1614)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }		TT.cjk { font-family: "DejaVu Sans Condensed", monospace }	-->		The Industrial ComputerProcessor Company offers very fast, special purpose processing unitstailored to customer needs. Processors of the a-C-m family (such as the 1-C-2 and the 5-C-3) have an instruction set withonly two different operations:  	A add a  	M multiply by m  	The processorreceives an integer, executes a sequence of A and M operations (the program) that modifiesthe input, and outputs the result. For example, the 1-C-2 processorexecuting the program AAAM with the input 2yields the output 10 (the computation is 2  3  4  5  10), while the 5-C-3 processor yields 51 with the same program andinput ( 2  7  12  17  51).  	You are an a-C-m programmer assigned to a top secret project. This means that you havenot been told the precise computation your program should perform.But you are given particular values p, q, r, and s and the following conditions:  						The	input is guaranteed to be a number between p and q.  									The output must be	some number between r and s.  				Given an a-C-m processor and the numbers p, q, r, and s,your job is to construct the shortest a-C-m programwhich, for every input x such that pxq,yields some output y such that rys.If there is more than one program of minimum length, choose the onethat come first lexicographically, treating each program as a stringof As and Ms.  
题目输入：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		The input containsseveral test cases. Each test case is given by a line with the sixintegers a, m, p, q, r, and s as described above ( 1a, m, p, q, r, s109 , pq and rs).  	The last test case isfollowed by a line with six zeros.  
题目输出：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }		TT.cjk { font-family: "DejaVu Sans Condensed", monospace }	-->		For each test case,display its case number followed by the best program as describedabove. Display the word ``empty" if thebest program uses no operations. Display the word ``impossible"if there is no program meeting the specifications.  	Display the program asa sequence of space-separated strings, alternating between strings ofthe form ``nA" and strings ofthe form ``nM", where n >0. Strings of the former type indicate n consecutive Aoperations, and strings of the latter type indicate n consecutive M operations.  	Follow the format ofthe sample output.  
输入样例：
1 2 2 3 10 20
1 3 2 3 22 33
3 2 2 3 4 5
5 3 2 3 2 3
0 0 0 0 0 0
输出样例：
Case 1: 1A 2M
Case 2: 1M 2A 1M
Case 3: impossible
Case 4: empty
提示：
None



题目：最大的矩形(1830)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　在横轴上放了n个相邻的矩形，每个矩形的宽度是1，而第i（1 ≤ i ≤ n）个矩形的高度是hi。这n个矩形构成了一个直方图。例如，下图中六个矩形的高度就分别是3, 1, 6, 5, 2, 3。　　请找出能放在给定直方图里面积最大的矩形，它的边要与坐标轴平行。对于上面给出的例子，最大矩形如下图所示的阴影部分，面积是10。
题目输入：
　　第一行包含一个整数n，即矩形的数量(1 ≤ n ≤ 1000)。
　　第二行包含n 个整数h1, h2, … , hn，相邻的数之间由空格分隔。(1 ≤ hi ≤ 10000)。hi是第i个矩形的高度。
题目输出：
　　输出一行，包含一个整数，即给定直方图内的最大矩形的面积。
输入样例：
　　输出一行，包含一个整数，即给定直方图内的最大矩形的面积。
输出样例：
10
提示：
多组输入，以EOF结尾



题目：MilkMeasuring(1516)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer John must measure Q (1 <= Q <= 20,000) quarts of his finest milk and deliver it in one big bottle to a customer. He fills that bottle with exactly the number of quarts that the customer orders. Farmer John has always been frugal. He is at the cow hardware store where he must purchase a set of pails with which to measure out Q quarts of milk from his giant milk tank. Since the pails each cost the same amount, your task is to figure out a minimal set of pails Farmer John can purchase in order to fill a bottle with exactly Q quarts of milk. Additionally, since Farmer John has to carry the pails home, given two minimal sets of pails he should choose the "smaller" one as follows: Sort the sets in ascending order. Compare the first pail in each set and choose the set with the smallest pail. If the first pails match, compare the second pails and choose from among those, else continue until the two sets differ. Thus the set {3, 5, 7, 100} should be chosen over {3, 6, 7, 8}. To measure out milk, FJ may completely fill a pail from the tank and pour it into the bottle. He can never remove milk from the bottle or pour milk anywhere except into the bottle. With a one-quart pail, FJ would need only one pail to create any number of quarts in a bottle. Other pail combinations are not so convenient. Determine the optimally small number of pails to purchase, given the guarantee that at least one solution is possible for all contest input data.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1: The single integer Q  Line 2: A single integer P (1 <= P <= 100) which is the number of pails in the store  Lines 3..P+2: Each line contains a single integer pail_value (1 <= pail_value <= 10000), the number of quarts a pail holds
题目输出：
The output is a single line of space separated integers that contains: the minimum number of pails required to measure out the desired number of quarts, followed by: a sorted list (from smallest to largest) of the capacity of each of the required pails
输入样例：
16
3
3
5
7
输出样例：
2 3 5
提示：




题目：Railway(1067)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
There are some locations in a park, and some of them are connected by roads. The park manger needs to build some railways along the roads, and he would like to arrange tourist routes to each circuit. If a railway belongs to more than one tourist routes, there might be clash on it, and if a railway belongs to none tourist route, it doesn’t need to build.Now we know the plan, and can you tell us how many railways are no need to build and how many railways where clash might happen.
题目输入：
The Input consists of multiple test cases. The first line of each test case contains two integers, n (0 < n <= 10000), m (0 <= m <= 100000), which are the number of locations and the number of the railways. The next m lines, each line contains two integers, u, v (0 <= u, v < n), which means the manger plans to build a railway on the road between u and v.
You can assume that there is no loop and no multiple edges.
The last test case is followed by two zeros on a single line, which means the end of the input.
题目输出：
Output the number of railways that are no need to build, and the number of railways where clash might happen. Please follow the format as the sample.
输入样例：
8 10
0 1
1 2
2 3
3 0
3 4
4 5
5 6
6 7
7 4
5 7
0 0
输出样例：
15
提示：




题目：HolyShit(1308)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
calculate a matrix A which is obtained when adding matrix B^n recursively to unit matrix I, ie, I+B+B^2+B^3+...B^n.Notice that B is a formal matrix whose number of rows and columns are equal.
题目输入：
The first line contains an integer t ( 1 <= t <= 10 ): the number of test cases. Then for each test case:The first line contains two integers n,k ( 1 <= n<= 10^8 ,2 <= k <= 20 ),where k is the size of matrix B.
题目输出：
For each test case, output the result in the form of sample.You should print the case number and  matrix A.Each element of matrix should be mod 10007
输入样例：
1
3 2
1 0
1 1
输出样例：
Case 1:
4 0
6 4
提示：
None



题目：HowmanyFibs?(1412)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Recall the definition of the Fibonacci numbers: 
f1 := 1 f2 := 2 fn := fn-1 + fn-2     (n>=3) Given two numbers a and b, calculate how many Fibonacci numbers are in the range [a,b].
题目输入：
The input contains several test cases. Each test case consists of two non-negative integer numbers a and b. Input is terminated by a=b=0. Otherwise, a<=b<=10^100. The numbers a and b are given with no superfluous leading zeros. 


题目输出：
For each test case output on a single line the number of Fibonacci numbers fi with a<=fi<=b. 


输入样例：
10 100
1234567890 9876543210
0 0


输出样例：
5
4


提示：




题目：仙剑奇侠传四之终局(1167)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
 重楼：“奴才就是奴才，在我重楼眼里你永远都只是奴才。”
  玄霄：“玄霄以命立誓，苍天弃吾，吾宁成魔。” 
  云天河：“杀气！”
  唐雪见：“我走了，以后再也不要见到你！”
  飞蓬：“你们没有一个值得我拔剑！”
  句芒：“你们不配成为后羿神弓的主人！”
  衔烛之龙：“汝等凡人，为何会来到不周山！此处乃是幽冥之国的属地，速速退去！”
   
  我们假定：仙剑六界有严格的等级划分，当然六界之中，以重楼为尊！
  仙剑奇侠终成经典。酷爱仙剑的阿才最终决定邀请各路人士前来聚会，出于盛情款待，而且机会难得，阿才希望能请到最多的人来参加聚会，可是听了上面一席话，阿才知道许多人是肯定不会一起来的，仔细研究发现，对于六界之中等级较低的生灵都不希望与比他直接高一级的boss一起参加宴会，而如果级数差距较大的，由于没有直接管辖关系，所以在一起不会感到不愉快（我们保证每一个低一级的生灵仅有一个比他直接高一级的BOSS）.比如衔烛之龙见到凡人就恼火之类，衔烛之龙就肯定不会和凡人出现在同一宴会上。这让阿才十分为难，于是阿才希望华仔能够帮助邀请客人。
题目输入：
  输入包含多个测试用例。
  第一行输入n，表示一共可以邀请的人数。(n<=200)
  接下来第一行是终极Boss的姓名
  之后的n-1行分别表示每一个生灵和比他直接高一级的boss。

题目输出：
 阿才最多可以邀请的客人数目。如果最多邀请客人选择方案唯一就输出“AC”,不唯一则输出“SPECIAL”（输出格式如下）
输入样例：
6
ChongLou
FeiPeng ChongLou
SuYao XuanXiao
JingTian XuanXiao
ZiXuan FeiPeng
XuanXiao FeiPeng

2
ChongLou
ZiXuan ChongLou

输出样例：
4 AC
1 SPECIAL

提示：




题目：上帝给你一个机会(1715)
时间限制：1000MS
空间限制：65536K
题目描述：
	我们的alex4814是个大学霸，相信现在的平均分已经超过了90了，当然他肯定也会有失误的时候，当考到88,89这样的分数是，alex4814一定在心里默默祈祷，上帝啊，再多给我2分该多好啊，对于高平均分的alex4814来说，他追求的是完美，高gpa值，于是有一天，他正在祈祷时，刚巧上帝路过，上帝看了他的资料，觉得这小孩很不错，因此就跟alex4814说，我可以给你一共加x分，你可以随意分配这x分，现在alex4814想知道，如何分配这x分可以把自己的平均gpa提高最多？
题目输入：
	第一行输入一个整数T，表面有T组数据。	每个case中，先输入3个整数c,n,x(1<=c<=30, 1<=n<=100, 0<=x<=200)，分别代表有c个分数的绩点安排，有n门学科，一共可以加x分。	然后接下来c行，每行都是一个整数ai(1<=ai<=1000 - -||这只是个题目)和一个实数bi(0.01<=bi<=10^8)，表示ai分数及以上的绩点是bi，越高的ai对应越高的bi，输入按递增的顺序输入，0分的gpa是0。	然后接下来的n行，每行都是一个整数ci和一个实数di，表示alex4814这门课得了ci分，这门课的学分是di，算gpa的时候是按照学分加权平均的。
题目输出：
	输出以Case X: N的形式，X是当前的Case数目，从1开始计数，N是可以提高的最大的平均gpa值，保留4位小数。
输入样例：
1
3 3 2
82 3.3
85 3.7
90 4.0
88 3.5
84 2.0
84 1.0
输出样例：
Case 1: 0.1846
提示：




题目：AffineMess(1615)
时间限制：300 ms
空间限制：65535 ms
题目描述：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		Tess L. Ation ran intoa little problem last week when she demonstrated the beta version ofher new drawing software. On the screen she had an elegantdemonstration design that illustrated every feature of her program;it had taken her hours to produce it. She was just putting thefinishing touches on it as a group of potential investors entered theroom to see the demonstration.  	The presentationwent well. Near the end, Tess clicked on a control panel button andtold her audience, ``This is the `snap to grid' control. It forcescontrol points, such as vertices, to jump to the nearest grid point.Here, let me show you," and she placed three bright red dots onthe screen. Each one appeared at the grid point nearest to where sheclicked. (``Luckily all control points in my demo design were alreadyat integer coordinates. But I will have to remember to delete thesethree red dots before I save my diagram," she thought toherself.) ``Now I'll step into the next room and get out of your wayso you can discuss the system among yourselves and get a closer lookat the screen, but please don't touch anything, since I haven't savedthat file yet."  	A few minuteslater, the group joined Tess. One of the visitors stepped up to Tessand said, ``I hope you don't mind, but I wanted to try it myself.Don't worry, I just played with the x-scale and y-scalecontrols a little bit." The next person said, ``Sorry if this isa problem, but I really wanted to get a feel for the speed ofdisplay, so I just played around with the translation tool." Anda third person said, ``I couldn't resist just one tiny test: Irotated the image just so I could see all of the vertices snap to thenearest grid points after the rotation."  	The person whoplayed with the rotation tool remembered going first, but the othertwo could not recall their order. The three remembered only a fewdetails of the changes. The x- and y-scaling factorshad been (possibly negative) nonzero integers; the center of scalingwas the origin (0, 0). The x- and y-translation amountshad been integers. Rotation had been specified by a point withinteger coordinates (x, y) on the perimeter of a squareof width 20 centered at the origin (hence, -10x, y10and the absolute value of x or y or both was 10). Thetool rotated the drawing around the origin such that the positive x-axis would pass through (x, y) afterwards.Snapping took place after this rotation (coordinates with afractional part of 0.5 were rounded away from zero).  	After they left,Tess looked at her design -- it was completely changed! She had notyet implemented the ``undo" feature, and she had not saved thediagram prior to giving the demonstration. However, the threeidentical red dots were still there (transformed to other integergrid locations, of course), and Tess could remember the integercoordinates where she had originally placed them. Obviously, someoneelse might have altered the drawing without saying anything to her,but she could write a program to see if it was possible toreconstruct the sequence of alterations. Can you too?  
题目输入：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		The input containsseveral test cases. Each test case consists of six pairs of integers xi and yi ( -500xi, yi500for 1i6),three pairs per input line. The first three pairs represent thedistinct initial locations of the three red dots. The last threepairs represent the distinct final locations of the three dots. Theindexing of the pairs in each group of three is not significant: forexample, (x1, y1) could have beenmapped to any of (x4, y4), (x5, y5) or (x6, y6).  	The last test case isfollowed by a line with six zeros.  
题目输出：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }		TT.cjk { font-family: "DejaVu Sans Condensed", monospace }	-->		For each test case,display its case number followed by one of the following threemessages:  							``equivalent	solutions" to indicate that there are one or more valid	transformations, and of them have the same effect on the whole	drawing (no matter what the whole drawing looks like).  									``inconsistent	solutions" to indicate that there are several valid	transformations, but in general not all of them map the entire	drawing in the same way (some drawing is mapped differently by two	valid transformations).  									``no	solution" to indicate that neither of the first two cases	occurs.  				A validtransformation is a combination of rotation, translation and scaling(or rotation, scaling and translation) which satisfies therestrictions described above and maps the initial set of red dots tothe final set (occupying all three final locations).  	Follow the format ofthe sample output.  
输入样例：
3 0 4 0 1 4
-2 -4 -1 3 3 -4
0 1 1 1 2 1
1 2 2 2 3 2
1 0 2 0 3 0
3 3 1 1 2 2
1 0 2 0 3 0
3 2 1 1 2 2
2 3 0 6 1 2
2 3 0 6 1 2
0 0 0 0 0 0
输出样例：
Case 1: equivalent solutions
Case 2: inconsistent solutions
Case 3: no solution
Case 4: inconsistent solutions
Case 5: equivalent solutions
提示：
None



题目：有趣的数(1831)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　我们把一个数称为有趣的，当且仅当：
　　1. 它的数字只包含0, 1, 2, 3，且这四个数字都出现过至少一次。
　　2. 所有的0都出现在所有的1之前，而所有的2都出现在所有的3之前。
　　3. 最高位数字不为0。
　　因此，符合我们定义的最小的有趣的数是2013。除此以外，4位的有趣的数还有两个：2031和2301。
　　请计算恰好有n位的有趣的数的个数。由于答案可能非常大，只需要输出答案除以1000000007的余数。
题目输入：
　　输入只有一行，包括恰好一个正整数n (4 ≤ n ≤ 1000)。
题目输出：
　　输出只有一行，包括恰好n 位的整数中有趣的数的个数除以1000000007的余数。
输入样例：
4
输出样例：
3
提示：
多组输入，以EOF结尾



题目：NetworkofSchools(1517)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A number of schools are connected to a computer network. Agreements have been developed among those schools: each school maintains a list of schools to which it distributes software (the "receiving schools"). Note that if B is in the distribution list of school A, then A does not necessarily appear in the list of school B. You are to write a program that computes the minimal number of schools that must receive a copy of the new software in order for the software to reach all schools in the network according to the agreement (Subtask A). As a further task, we want to ensure that by sending the copy of new software to an arbitrary school, this software will reach all schools in the network. To achieve this goal we may have to extend the lists of receivers by new members. Compute the minimal number of extensions that have to be made so that whatever school we send the new software to, it will reach all other schools (Subtask B). One extension means introducing one new member into the list of receivers of one school.
题目输入：
There are several test cases, end by EOF, for each test case:The first line of the input file contains an integer N: the number of schools in the network (2<=N<=100). The schools are identified by the first N positive integers. Each of the next N lines describes a list of receivers. The line i+1 contains the identifiers of the receivers of school i. Each list ends with a 0. An empty list contains a 0 alone in the line.
题目输出：
Your program should write two lines to the output file. The first line should contain one positive integer: the solution of subtask A. The second line should contain the solution of subtask B.
输入样例：
5
2 4 3 0
4 5 0
0
0
1 0
输出样例：
1
2
提示：




题目：SpecialFish(1068)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
There is a kind of special fish in the East Lake where is closed to campus of Wuhan University. It’s hard to say which gender of those fish are, because every fish believes itself as a male, and it may attack one of some other fish who is believed to be female by it.A fish will spawn after it has been attacked. Each fish can attack one other fish and can only be attacked once. No matter a fish is attacked or not, it can still try to attack another fish which is believed to be female by it.There is a value we assigned to each fish and the spawns that two fish spawned also have a value which can be calculated by XOR operator through the value of its parents.We want to know the maximum possibility of the sum of the spawns.
题目输入：
The input consists of multiply test cases. The first line of each test case contains an integer n (0 < n <= 100), which is the number of the fish. The next line consists of n integers, indicating the value (0 < value <= 100) of each fish. The next n lines, each line contains n integers, represent a 01 matrix. The i-th fish believes the j-th fish is female if and only if the value in row i and column j if 1.
The last test case is followed by a zero, which means the end of the input.
题目输出：
Output the value for each test in a single line.
输入样例：
3
1 2 3
011
101
110
0
输出样例：
6
提示：




题目：三国杀No1(1309)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
最近，胡新杰和朱黎为了争夺张俊杰，决定以一场三国杀一决胜负，由于朱黎的三国杀水平远胜于胡新杰，因此，胡新杰决定两人均以托管的方式战斗，把胜负的决定权交给神。作为神的你，现在就要决定一下是谁赢，由于你是神，你早已知道了下面的牌。 
规则介绍：输入一个字符串，该字符串只包含0和1,1表示杀，0表示闪。假设均不考虑两人的技能，有杀出杀，有闪出闪，且在有多张杀或闪的时候，总是打出先摸到的那张牌。当出牌完毕后（打出一张杀或者没有杀直接弃牌），进入弃牌阶段，如果手上的牌数大于自己的血量，需要弃掉X张牌，X=手牌数—血量。且托管状态下总是弃掉先摸到的X张牌。如果被杀而自己没有闪，则自己会丢失一滴血，最后血量为0时则视为死亡，初始时两人的血量都为3. 
游戏开始时，每人先摸四张牌，由胡新杰先摸，然后朱黎再摸。这时候开始由胡新杰开始出牌，出牌前再从牌堆摸两张牌。（也就是说，在胡新杰开始出牌的时候，胡新杰总共摸了6张牌，朱黎4张牌,摸牌顺序是胡新杰摸4张，朱黎摸4张，胡新杰再2张）
题目输入：
一个整数CASE。然后下面有CASE行，每行一个由0和1组成的字符串，表示牌堆的牌（字符串的总长度len总是为偶数，且8<=len<=1000）。
题目输出：
对于每个输入的牌，输出谁赢。如果胡新杰把朱黎杀死了，输出”xiaoyoulei win!”,如果朱黎把胡新杰杀死了，输出”zlly win!”,如果牌抓完了还不能决定，输出”ping ju!”。
输入样例：
3
1111111111
11111111111111111111
11110000111111111111

输出样例：
ping ju!
xiaoyoulei win!
zlly win!

提示：




题目：项目发展规划（Develop）(1168)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Macrosoft® 公司准备制定一份未来的发展规划。公司各部门提出的发展项目汇总成了一张规划表，该表包含了许多项目。对于每个项目，规划表中都给出了它所需的投资或预计的盈利。由于某些项目的实施必须依赖于其它项目的开发成果，所以如果要实施这个项目的话，它所依赖的项目也是必不可少的。现在请你担任Macrosoft® 公司的总裁，从这些项目中挑选出一部分，使你的公司获得最大的净利润。
题目输入：
输入文件包括项目的数量N，每个项目的预算Ci和它所依赖的项目集合Pi。格式如下：
第1行是N；
接下来的每一个项目有两行表示：
第一行：一个数是Ci，正数表示盈利，负数表示投资，每行相邻的两个数之间用一个或多个空格隔开。
第二行：第一个数Ni，所依赖项目的个数，后跟Ni个数，为i项目所依赖的项目编号。

题目输出：
一行：公司的最大净利润。
输入样例：
6
-4
0
1
0
2 
1 2
-1
2 1 2
-3
1 3
5
2 3 4

输出样例：
3
提示：




题目：PhylogeneticTreesInherited(1413)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Among other things, Computational Molecular Biology deals with processing genetic sequences. Considering the evolutionary relationship of two sequences, we can say that they are closely related if they do not differ very much. We might represent the relationship by a tree, putting sequences from ancestors above sequences from their descendants. Such trees are called phylogenetic trees. Whereas one task of phylogenetics is to infer a tree from given sequences, we'll simplify things a bit and provide a tree structure - this will be a complete binary tree. You'll be given the n leaves of the tree. Sure you know, n is always a power of 2. Each leaf is a sequence of amino acids (designated by the one-character-codes you can see in the figure). All sequences will be of equal length l. Your task is to derive the sequence of a common ancestor with minimal costs. 









Amino Acid 



Alanine 
Ala
A

Arginine 
Arg
R

Asparagine 
Asn
N

Aspartic Acid 
Asp
D

Cysteine 
Cys
C

Glutamine 
Gln
Q

Glutamic Acid 
Glu
E

Glycine 
Gly
G

Histidine 
His
H

Isoleucine 
Ile
I





Amino Acid 



Leucine 
Leu
L

Lysine 
Lys
K

Methionine 
Met
M

Phenylalanine 
Phe
F

Proline 
Pro
P

Serine 
Ser
S

Threonine 
Thr
T

Tryptophan 
Trp
W

Tyrosine 
Tyr
Y

Valine 
Val
V
The costs are determined as follows: every inner node of the tree is marked with a sequence of length l, the cost of an edge of the tree is the number of positions at which the two sequences at the ends of the edge differ, the total cost is the sum of the costs at all edges. The sequence of a common ancestor of all sequences is then found at the root of the tree. An optimal common ancestor is a common ancestor with minimal total costs. 
题目输入：
The input file contains several test cases. Each test case starts with two integers n and l, denoting the number of sequences at the leaves and their length, respectively. Input is terminated by n=l=0. Otherwise, 1<=n<=1024 and 1<=l<=1000. Then follow n words of length l over the amino acid alphabet. They represent the leaves of a complete binary tree, from left to right. 


题目输出：
For each test case, output a line containing some optimal common ancestor and the minimal total costs.
输入样例：
4 3
AAG
AAA
GGA
AGA

4 3
AAG
AGA
AAA
GGA

4 3
AAG
GGA
AAA
AGA

4 1
A
R
A
R

2 1
W
W

2 1
W
Y

1 1
Q

0 0


输出样例：
AGA 3
AGA 4
AGA 4
R 2
W 0
Y 1
Q 0


提示：




题目：鱼头的赌场(1716)
时间限制：1000ms
空间限制：32768 KB
题目描述：
	ACM俱乐部的娱乐场有一个轮盘赌的轮，具有1到M的M个位置。如果一次旋转发生的数n可被它的立方根的下整数除尽，也就是说，如果	                                      n mod ⌊∛n⌋ =0	则成为赢家，并且鱼头付我们5元；否则成为输者，且我们要给鱼头1元。	如果我们玩这样的游戏，是否指望赢钱？求平均每次能赢的钱或者输的钱。	
题目输入：
	输入有多行，给出M的值，以0作为输入数据的结束。数据小于100000000
题目输出：
	输出时每个case成一行，并且保留两位小数，防止数据太小，赢的钱的单位用分来表示。
输入样例：
1000
0

输出样例：
3.20

提示：
None



题目：AncientMessages(1616)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	In order to understand early civilizations,archaeologists often study texts written in ancient languages. One such language, used in Egypt more than 3000 years ago, is based on characters calledhieroglyphs. Figure C.1 shows six hieroglyphs and their names. In this problem, you will write a program to recognize these six characters. 	FigureC.1: Six hieroglyphs
题目输入：
	The input consists of several test cases, each of which describes an image containing one or more hieroglyphs chosen from among those shown in Figure C.1. The image is given in the form of a series of horizontal scan lines consisting of black pixels (represented by 1) and white pixels (represented by 0). In the input data, each scan line is encoded in hexadecimal notation. For example, the sequence of eight pixels 10011100 (one black pixel, followed by two white pixels, and so on) would be represented in hexadecimal notation as 9c. Only digits and lowercase letters a through f are used in the hexadecimal encoding. The first line of each test case contains two integers, H and W. H (0 < H <=200) is thenumber of scan lines in the image. W(0 < W<= 50) is the number of  hexadecimal characters in each line. The next H lines contain the hexadecimal characters of the image, working from top to bottom. Input images conform to the following rules:	•       The image contains only hieroglyphs shown in Figure C.1.	•       Each image contains at least one valid hieroglyph.	•       Each black pixel in the image is part of a valid hieroglyph.	•       Each hieroglyph consists of a connected set of black pixels and each black pixel has at least one other black pixel on its top, bottom, left, or right side.	•       The hieroglyphs do not touch and no hieroglyph is inside another hieroglyph.	•       Two black pixels that touch diagonally will always have a common touching black pixel.    The hieroglyphs may be distorted but each has a shape that is topologically equivalent to one of the symbols in Figure C.1. (Two figures are topologically equivalent if each can be transformed into the other by stretching without tearing.)The last test case is followed by a line containing two zeros.
题目输出：
	For each test case, display its case number followed by a string containing one character for each hieroglyph recognized in the image, using the following code:Ankh: A Wedjat: J Djed: D Scarab: SWas: W Akhet: KIn each output string, print the codes in alphabetic order. Follow the format of the sample output.	The sample input contains descriptions of test cases shown in Figures C.2 and C.3. Due to space constraints not all of the sample input can be shown on this page. 	
输入样例：
100 25
0000000000000000000000000
0000000000000000000000000
...(50 lines omitted)...
00001fe0000000000007c0000
00003fe0000000000007c0000
...(44 lines omitted)...
0000000000000000000000000
0000000000000000000000000
150 38
00000000000000000000000000000000000000
00000000000000000000000000000000000000
...(75 lines omitted)...
0000000003fffffffffffffffff00000000000
0000000003fffffffffffffffff00000000000
...(69 lines omitted)...
00000000000000000000000000000000000000
00000000000000000000000000000000000000
0 0

输出样例：
Case 1: AKW
Case 2: AAAAA

提示：

	 




题目：I’mstuck!(1832)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　给定一个R行C列的地图，地图的每一个方格可能是'#', '+', '-', '|', '.', 'S', 'T'七个字符中的一个，分别表示如下意思：
　　'#': 任何时候玩家都不能移动到此方格；
　　'+': 当玩家到达这一方格后，下一步可以向上下左右四个方向相邻的任意一个非'#'方格移动一格；
　　'-': 当玩家到达这一方格后，下一步可以向左右两个方向相邻的一个非'#'方格移动一格；
　　'|': 当玩家到达这一方格后，下一步可以向上下两个方向相邻的一个非'#'方格移动一格；
　　'.': 当玩家到达这一方格后，下一步只能向下移动一格。如果下面相邻的方格为'#'，则玩家不能再移动；
　　'S': 玩家的初始位置，地图中只会有一个初始位置。玩家到达这一方格后，下一步可以向上下左右四个方向相邻的任意一个非'#'方格移动一格；
　　'T': 玩家的目标位置，地图中只会有一个目标位置。玩家到达这一方格后，可以选择完成任务，也可以选择不完成任务继续移动。如果继续移动下一步可以向上下左右四个方向相邻的任意一个非'#'方格移动一格。
　　此外，玩家不能移动出地图。
　　请找出满足下面两个性质的方格个数：
　　1. 玩家可以从初始位置移动到此方格；
　　2. 玩家不可以从此方格移动到目标位置。
题目输入：
　　输入的第一行包括两个整数R 和C，分别表示地图的行和列数。(1 ≤ R, C ≤ 50)。
　　接下来的R行每行都包含C个字符。它们表示地图的格子。地图上恰好有一个'S'和一个'T'。
题目输出：
　　如果玩家在初始位置就已经不能到达终点了，就输出“I'm stuck!”（不含双引号）。否则的话，输出满足性质的方格的个数。
输入样例：
5 5
--+-+
..|#.
..|##
S-+-T
####.
输出样例：
2
提示：
如果把满足性质的方格在地图上用'X'标记出来的话，地图如下所示：
　　--+-+
　　..|#X
　　..|##
　　S-+-T
　　####X




题目：BigBarn(1518)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer John wants to place a big square barn on his square farm. He hates to cut down trees on his farm and wants to find a location for his barn that enables him to build it only on land that is already clear of trees. For our purposes, his land is divided into N x N parcels. The input contains a list of parcels that contain trees. Your job is to determine and report the largest possible square barn that can be placed on his land without having to clear away trees. The barn sides must be parallel to the horizontal or vertical axis.EXAMPLEConsider the following grid of Farmer John's land where `.' represents a parcel with no trees and `#' represents a parcel with trees:           1 2 3 4 5 6 7 8        1 . . . . . . . .        2 . # . . . # . .        3 . . . . . . . .        4 . . . . . . . .        5 . . . . . . . .        6 . . # . . . . .        7 . . . . . . . .        8 . . . . . . . .The largest barn is 5 x 5 and can be placed in either of two locations in the lower right part of the grid.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  Two integers: N (1 <= N <= 1000), the number of parcels on a side, and T (1 <= T <= 10,000) the number of parcels with trees  Lines 2..T+1: Two integers (1 <= each integer <= N), the row and column of a tree parcel
题目输出：
The output file should consist of exactly one line, the maximum side length of John's barn.
输入样例：
8 3
2 2
2 6
6 3
输出样例：
5
提示：




题目：Triangles(1069)
时间限制：10000 ms
空间限制：65535 ms
题目描述：
Mr. Cooper was a celebrated scientist who had a really big lab. There were N sticks in this lab and the length of the i-th stick was i millimeters. One day, when Mr. Cooper decided to do research on triangles, he found that M of the sticks were missed. Mr. Cooper wanted to know how many kinds of triangles could be constructed by three of the remaining sticks. Two triangles are different if and only if they are formed by different sets of sticks.For Example, there were 8 sticks in the lab originally and the second and the sixth sticks were missed. The 7 different triangles can be constructed were (3,4,5), (3,5,7), (4,5,7), (3,7,8), (4,7,8), (5,7,8), (4,5,8).
题目输入：
The first line contains an integer T (T<=25) indicating the number of test cases. The first line of each test case contains two integers N (1<=N<=1000000000) and M (0<=M<=1000). If M is not zero, there is an additional line containing M distinct integers between 1 and N indicating the missed sticks.
题目输出：
For each test case, print the case number and the answer % 1000000007 in a single line where the answer is the number of the triangles can be formed. Please follow the format of the sample output.
输入样例：
3
3 0
8 2
2 6
58 3
23 5 3
输出样例：
Case 1: 0
Case 2: 7
Case 3: 13861
提示：




题目：珂神的球(1310)
时间限制：20000 ms
空间限制：65535 ms
题目描述：
有一些玻璃球,每个玻璃球有一定的价值,有一个高度为m的楼,用这些玻璃球测出在哪一层把玻璃球扔下去的时候正好玻璃球能摔坏.每次扔一个求,不管有没有摔坏,花费的代价是k,如果球摔坏的话,那么要花费额外的代价ki(第i个球的价值).现在要求出在最坏情况下正好摔坏球的那个楼层,并且保证总的花费最小.(保证最高楼层一定会把球摔坏)
题目输入：
第一行输入一个整数 x (x<=100)表示有x个case
每个case第一行三个正整数 n , m , k (n<=50,m<=1000,k<=100)分别表示有n个球,m层楼,还有上文中提到的k
第二行有n个数,表示每个球的代价(ki<=100)

题目输出：
一个数,最小的代价
输入样例：
2
2 4 2
1 1
5 10 3
1 2 3 4 5

输出样例：
7
13
提示：




题目：Sumdiv(1169)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Consider two natural numbers A and B. Let S be the sum of all natural divisors of A^B. Determine S modulo 9901 (the rest of the division of S by 9901).
题目输入：
The line contains the two natural numbers A and B, (0 <= A,B <= 50000000)separated by blanks.It has more than one case.
题目输出：
The line of the output will contain S modulo 9901.
输入样例：
2 3
输出样例：
15
提示：




题目：HikeonaGraph(1414)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
"Hike on a Graph" is a game that is played on a board on which an undirected graph is drawn. The graph is complete and has all loops, i.e. for any two locations there is exactly one arrow between them. The arrows are coloured. There are three players, and each of them has a piece. At the beginning of the game, the three pieces are in fixed locations on the graph. In turn, the players may do a move. A move consists of moving one's own piece along an arrow to a new location on the board. The following constraint is imposed on this: the piece may only be moved along arrows of the same colour as the arrow between the two opponents' pieces. 
In the sixties ("make love not war") a one-person variant of the game emerged. In this variant one person moves all the three pieces, not necessarily one after the other, but of course only one at a time. Goal of this game is to get all pieces onto the same location, using as few moves as possible. Find out the smallest number of moves that is necessary to get all three pieces onto the same location, for a given board layout and starting positions. 
题目输入：
The input file contains several test cases. Each test case starts with the number n. Input is terminated by n=0. Otherwise, 1<=n<=50. Then follow three integers p1, p2, p3 with 1<=pi<=n denoting the starting locations of the game pieces. The colours of the arrows are given next as a m×m matrix of whitespace-separated lower-case letters. The element mij denotes the colour of the arrow between the locations i and j. Since the graph is undirected, you can assume the matrix to be symmetrical. 


题目输出：
For each test case output on a single line the minimum number of moves required to get all three pieces onto the same location, or the word "impossible" if that is not possible for the given board and starting locations. 


输入样例：
3 1 2 3
r b r
b b b
r b r
2 1 2 2
y g
g y
0


输出样例：
2
impossible


提示：




题目：CoffeeCentral(1617)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		Is it just a fad or isit here to stay? You're not sure, but the steadily increasing numberof coffee shops that are opening in your hometown has certainlybecome quite a draw. Apparently, people have become so addicted tocoffee that apartments that are close to many coffee shops willactually fetch higher rents.  	This has come to theattention of a local real-estate company. They are interested inidentifying the most valuable locations in the city in terms of theirproximity to large numbers of coffee shops. They have given you a mapof the city, marked with the locations of coffee shops. Assuming thatthe average person is willing to walk only a fixed number of blocksfor their morning coffee, you have to find the location from whichone can reach the largest number of coffee shops. As you are probablyaware, your hometown is built on a square grid layout, with blocksaligned on north-south and east-west axes. Since you have to walkalong streets, the distance between intersections (a, b)and (c, d ) is | a - c| + | b - d|.  
题目输入：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }		TT.cjk { font-family: "DejaVu Sans Condensed", monospace }	-->		The input containsseveral test cases. Each test case describes a city. The first lineof each test case contains four integers dx, dy, n,and q. These are the dimensions of the city grid dx x dy (1dx, dy1000),the number of coffee shops n (0n5 . 105), and the number of queries q (1q20).Each of the next n lines contains two integers xi and yi (1xidx,1yidy);these specify the location of the i-th coffee shop. There willbe at most one coffee shop per intersection. Each of the next q lines contains a single integer m (0m106),the maximal distance that a person is willing to walk for a cup ofcoffee.  	The last test case isfollowed by a line containing four zeros.  
题目输出：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		For each test case inthe input, display its case number. Then display one line per queryin the test case. Each line displays the maximum number of coffeeshops reachable for the given query distance m followed by theoptimal location. For example, the sample output shows that 3 coffeeshops are within query distance 1 of the optimal location (3, 4), 4shops are within query distance 2 of optimal location (2, 2), and 5shops are within query distance 4 of optimal location (3, 1). Ifthere are multiple optimal locations, pick the location that isfurthest south (minimal positive integer y-coordinate). Ifthere is still a tie, pick the location furthest west (minimalpositive integer x-coordinate).  	Follow the format ofthe sample output.  
输入样例：
4 4 5 3
1 1
1 2
3 3
4 4
2 4
1
2 
4
0 0 0 0
输出样例：
Case 1:
3 (3,4)
4 (2,2)
5 (3,1)
提示：
None



题目：相反数(1833)
时间限制：1.0s
空间限制：256MB
题目描述：
　　有 N 个非零且各不相同的整数。请你编一个程序求出它们中有多少对相反数(a 和 -a 为一对相反数)。
题目输入：
　　第一行包含一个正整数 N。(1 ≤ N ≤ 500)。
　　第二行为 N 个用单个空格隔开的非零整数,每个数的绝对值不超过1000,保证这些整数各不相同。
题目输出：
　　只输出一个整数,即这 N 个数中包含多少对相反数。
输入样例：
5
1 2 3 -1 -2
输出样例：
2
提示：
多组输入，以EOF结尾



题目：清帝之惑之康熙(1717)
时间限制：1000ms
空间限制：32768 KB
题目描述：
	背景	康熙是中国历史乃至世界历史中最伟大的帝王之一，清除螯拜，撤除三藩，统一台湾，平 定准葛尔叛乱；与此同时，出众的他也被世界各国遣清使臣所折服。康熙是历史上少有的全人，不仅文武兼得，而且在各各方面都有见地，比如说航海、数学、英 语、构图、建筑等等。一个最好的例子可以证明：康熙当年演算代数题的草稿纸至今仍然保存完好。	  话说康熙掌权之后，每天都抽空做数学题，特别是无聊题。这些天，某某老师开始教他做一些奇怪的题目。在第一节课的时候，老师就问了康熙一个超BT的题目：	描述	话说西汉时期，汉武帝刘彻派遣张骞出使西域，欲同月氏国结交而共驱匈奴。同时，月氏 国也欲同大汉结交，也派出使者康破伦出使大汉，可是因为月氏国对于大汉的认知甚少，康破伦同样向西出使大汉。一开始，张骞从大汉出发，康破伦从月氏国出 发，两人都在同一纬度线上，张骞所处的坐标为x，康破伦所处的坐标为y(以向东为正方向)；接下来，两人同时向西走，而且只能向西走，张骞每天走m公里，康破伦每天走n公 里，且每天走路的速度不变，也不停下来休息；这样两人就在这一条长为L的纬度线上一直向西走。问：过了多少天之后张骞和康破伦会碰面，并磋商两国结交之事（所谓碰面，是指两人处在同一经度上）。	  这下，康熙犯难了，他还是个不大的青年，怎么可能做得出这么难的题目；但是，他又是统领全国的帝皇，怎么能在老师面前丢这么大一个面子。康熙想：不行！一定得把这个题做出来！（然后就有了下面这段记录）	  第一天，……	  第二天，…………	  第三天，………………	  第四天，……………………	  第五天，…………………………	  第六天，………………………………	  第七天，……………………………………！！！！！！！	  啊！ 第七天，康熙终于打了7个感叹号，得出了一个重要的结论！！！！！那就是――做不出来。（汗），没办法，他只有请教你，他的挚友，帮他解决这一难题。康熙 答应你，如果你把这一题做出来了，你将得到御赐赏银一万万两！$$$$$$$$-$$$$$$$$。为了改变你生活的现状――衣衫褴褛、闻鼠起舞、蟑螂为 伴，你下定了决心――我一定得把这题解决！	
题目输入：
输入只包括一行5个整数x，y，m，n，L其中0<x≠y < =2000000000，0 < m、n < =2000000000，0 < L < =2100000000。
题目输出：
输出碰面所需要的天数，如果永远不可能碰面则输出一行"Impossible"。
输入样例：
1 2 3 4 5

输出样例：
1

提示：
None



题目：AllLatinSquares(1519)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A square arrangement of numbers 1  2  3  4  52  1  4  5  33  4  5  1  24  5  2  3  15  3  1  2  4is a 5 x 5 Latin Square because each whole number from 1 to 5 appears once and only once in each row and column. Write a program that will compute the number of NxN Latin Squares whose first row is: 1 2 3 4 5.......NYour program should work for any N from 2 to 7.
题目输入：
There are several test cases, end by EOF, for each test case:One line containing the integer N.
题目输出：
A single integer telling the number of latin squares whose first row is 1 2 3 . . . N.
输入样例：
5
输出样例：
1344
提示：




题目：ASimpleProblem(1311)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
The Problem is simple . Give some inequalities like ax+by+c<0 in the 
form of a,b,c . Now your task is to calculate the area of the intersection of 
those inequalities.
题目输入：
First a number n(n<1000) as the number of the inequalities . Then the next n lines each contains three numbers a , b , c  ( 0 < a,b,c <200 )described above . The input ends with a 0 .
题目输出：
Each case print a number (the area) , the format is as sample output .
If the area is not closed , just output -1.00 .
(two numbers after point)
输入样例：
1
1 1 1
4
0 -1 0
0 1 -1
-1 0 0
1 0 -1
3
1 0 -1
0 1 -1
-1 -1 1
0

输出样例：
-1.00
1.00
0.50

提示：




题目：Children’sDay(1070)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Children’s Day will come. Kane beg his father to buy a lot of gifts. But his father is a little mean. He makes 2 rules: 1.the number of all the gifts mustn’t larger than M; 2. the total weight of all the gifts chosen must smaller than W. In the shop, every gift has its price. What’s more, some gifts are particular; custom can only buy more one for each. Now, Kane problem is how to buy gifts so that the sum of gifts’ price is maximum. Could you help him?
题目输入：
Standard input contains several cases: in each case first line is three integers N, M, W (N<=50, M<=50, W<=1000). N is the amount of gifts in the shop. M is the largest number of gifts Kane can buy. W is the weight Kane’s father willing to buy gift. In the next N lines, each line gives you one gift’s information using three integers A, B, C (A<=1000, B<=1000). A means the gift’s price. B means the gift’s weight. C (either 0 or 1) means whether this gift is unique: 1 means you can only buy one of this gift, 0 means you can buy as many as possible. The last line of the file contains 0 0 0. 
题目输出：
For each case, you should just print the maximum of total money Kane’s farther will pay in one line.
输入样例：
2 3 100
15 15 0
65 60 1
2 3 100
40 40 0
60 65 1
0 0 0

输出样例：
95
80

提示：




题目：Assignments(1170)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
In a factory, there are N workers to finish two types of tasks (A and B). Each type has N tasks. Each task of type A needs xi time to finish, and each task of type B needs yj time to finish, now, you, as the boss of the factory, need to make an assignment, which makes sure that every worker could get two tasks, one in type A and one in type B, and, what's more, every worker should have task to work with and every task has to be assigned. However, you need to pay extra money to workers who work over the standard working hours, according to the company's rule. The calculation method is described as follow: if someone’ working hour t is more than the standard working hour T, you should pay t-T to him. As a thrifty boss, you want know the minimum total of overtime pay.
题目输入：
There are multiple test cases, in each test case there are 3 lines. First line there are two positive Integers, N (N<=1000) and T (T<=1000), indicating N workers, N task-A and N task-B, standard working hour T. Each of the next two lines has N positive Integers; the first line indicates the needed time for task A1, A2…An (Ai<=1000), and the second line is for B1, B2…Bn (Bi<=1000).
题目输出：
For each test case output the minimum Overtime wages by an integer in one line.
输入样例：
2 5
4 2
3 5

输出样例：
4

提示：
None



题目：打野(1415)
时间限制：1000 ms
空间限制：65536 ms
题目描述：
 

 话说很多人在打DotA的时候都喜欢去打野。冰蛙是一个野生动物保护主义者，觉得大家都去打野不和谐，于是在DotA8.88中，他把所有的野生动物分别封闭在许多的魔法保护区域里面，这样大家就走不进去了。        但是天灾和近卫军团里面有很多法力强大的野生动物不保护主义者，他们在野生动物聚集的地方修了很多单向传送门。这些门两个一组，可以把英雄从一个野生动物聚集处传送到另一个，并且可以多次使用，两点之间可能有多个组传送门。英雄打死野生动物后会得到一定数量（<=1000）的钱，如果被打死会损失一定的钱(<=1000)，并且原地满状态复活（英雄信春哥）。        每个英雄可以经过任意一个野生动物聚集处多次，可以选择打或者不打，但是最多能打一次（野生动物不会复活）。现在你的英雄有两张传送卷轴（都只能用一次），一张可以把英雄传到任意的野生动物聚集点，另一张用来回基地，我们想知道你的英雄可以赚多少钱。假设没有其他的英雄和你竞争。
题目输入：
    有多组测试数据，以文件尾结束。每组第一行有两个正整数N(<=30000),M(<=150000)，N为野生动物聚集地数目（编号从0到N-1），M为传送门组数。第二行有N个整数，a1,a2,…,ai,…,an-1，(|ai|<=1000)，表示英雄打败第i个野生动物能得到ai个钱，若ai为负数则说明英雄被打死。接下来M行每行有两个整数u，v，说明有传送门从u到v。
题目输出：
    输出得到钱数的最大值。
输入样例：
2 2
4 21
0 1
1 0

8 11
5 -5 6 3 3 -3 10 10
0 1
0 1
1 0
1 2
2 1
1 3
1 7
3 5
5 4
4 3
5 6

输出样例：
25
27

提示：
样例2中英雄传送到点0，得5个钱；经过点1到达点2，得6个钱；经过点1到点3，得3个钱；经过点5到点4，得3个钱；经过点3点5到点6，得10个钱；回家，总收入为27。



题目：MagicSticks(1618)
时间限制：10000 ms
空间限制：65535 ms
题目描述：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		Magic was accepted byall ancient peoples as a technique to compel the help of divinepowers. In a well-known story, one group of sorcerers threw theirwalking sticks on the floor where they magically appeared to turninto live serpents. In opposition, another person threw his stick onthe floor, where it turned into a serpent which then consumed thesorcerers' serpents!  	The only magic requiredfor this problem is its solution. You are given a magic stick thathas several straight segments, with joints between the segments thatallow the stick to be folded. Depending on the segment lengths andhow they are folded, the segments of the stick can be arranged toproduce a number of polygons. You are to determine the maximum areathat could be enclosed by the polygons formed by folding the stick,using each segment in at most one polygon. Segments can touch only attheir endpoints. For example, the stick shown below on the left hasfive segments and four joints. It can be folded to produce a polygonas shown on the right.  	
题目输入：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		The input containsseveral test cases. Each test case describes a magic stick. The firstline in each test case contains an integer n (1n500)which indicates the number of the segments in the magic stick. Thenext line contains n integers S1, S2,..., Sn (1Si1000)which indicate the lengths of the segments in the order they appearin the stick.  	The last test case isfollowed by a line containing a single zero.  
题目输出：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		For each case, displayits case number followed by the maximum total enclosed area that canbe obtained by folding the magic stick at the given points. Answerswithin an absolute or relative error of 10-4 will beaccepted.  	Follow the format ofthe sample output.  
输入样例：
4
1 2 3 4
8
3 4 5 33 3 4 3 5
0
输出样例：
Case 1: 4.898979
Case 2: 19.311
提示：
None



题目：窗口(1834)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　在某图形操作系统中,有 N 个窗口,每个窗口都是一个两边与坐标轴分别平行的矩形区域。窗口的边界上的点也属于该窗口。窗口之间有层次的区别,在多于一个窗口重叠的区域里,只会显示位于顶层的窗口里的内容。
　　当你点击屏幕上一个点的时候,你就选择了处于被点击位置的最顶层窗口,并且这个窗口就会被移到所有窗口的最顶层,而剩余的窗口的层次顺序不变。如果你点击的位置不属于任何窗口,则系统会忽略你这次点击。
　　现在我们希望你写一个程序模拟点击窗口的过程。
题目输入：
　　输入的第一行有两个正整数,即 N 和 M。(1 ≤ N ≤ 10,1 ≤ M ≤ 10)
　　接下来 N 行按照从最下层到最顶层的顺序给出 N 个窗口的位置。 每行包含四个非负整数 x1, y1, x2, y2,表示该窗口的一对顶点坐标分别为 (x1, y1) 和 (x2, y2)。保证 x1 < x2,y1 < y2。
　　接下来 M 行每行包含两个非负整数 x, y,表示一次鼠标点击的坐标。
　　题目中涉及到的所有点和矩形的顶点的 x, y 坐标分别不超过2559 和1439。
题目输出：
　　输出包括 M 行,每一行表示一次鼠标点击的结果。如果该次鼠标点击选择了一个窗口,则输出这个窗口的编号(窗口按照输入中的顺序从 1 编号到 N);如果没有,则输出"IGNORED"(不含双引号)。
输入样例：
3 4
0 0 4 4
1 1 5 5
2 2 6 6
1 1
0 0
4 4
0 5
输出样例：
2
1
1
IGNORED
提示：
样例说明
　　第一次点击的位置同时属于第 1 和第 2 个窗口,但是由于第 2 个窗口在上面,它被选择并且被置于顶层。
　　第二次点击的位置只属于第 1 个窗口,因此该次点击选择了此窗口并将其置于顶层。现在的三个窗口的层次关系与初始状态恰好相反了。
　　第三次点击的位置同时属于三个窗口的范围,但是由于现在第 1 个窗口处于顶层,它被选择。
　　最后点击的 (0, 5) 不属于任何窗口。



题目：潜艇威胁(1718)
时间限制：3000ms
空间限制：65536k
题目描述：
	有一艘潜艇进入我国海域，对我国造成威胁。潜艇可能存在n（0<n<100）个区域之中，出现在第i区域的可能为wi (0<wi <1.0)。现在派出m(0<m<1000)艘猎潜艇去搜索该潜艇，搜索行动是独立的。目标在i海域这一条件下，发现目标的概率为 pi=1-e^(-ai*xi)， ai(0<ai<=1.0)表示参数， xi表示搜索该区域猎潜艇的数目。现在要做出猎潜艇的分配方案，使发现目标的概率最大，最大概率是多少？
题目输入：
	有若干测试数据，第一行为两个整数n，m，接下来n行，每行有两个数 ai，wi 。
题目输出：
	输出最大发现目标的概率。
输入样例：
4 5
1.0 0.05
1.0 0.05
1.0 0.6
1.0 0.2

输出样例：
0.743
提示：
None



题目：CanadaTour(1520)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
You have won a contest sponsored by an airline. The prize is a ticket to travel around Canada, beginning in the most western point served by this airline, then traveling only from west to east until you reach the most eastern point served, and then coming back only from east to west until you reach the starting city. No city may be visited more than once, except for the starting city, which must be visited exactly twice (at the beginning and the end of the trip). You are not allowed to use any other airline or any other means of transportation. Given a list of cities served by the airline and a list of direct flights between pairs of cities, find an itinerary which visits as many cities as possible and satisfies the above conditions beginning with the first city and visiting the last city on the list and returning to the first city.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  The number N of cities served by the airline and the number V of direct flights that will be listed. N will be a positive integer not larger than 100. V is any positive integer.  Lines 2..N+1: Each line contains a name of a city served by the airline. The names are ordered from west to east in the input file. There are no two cities in the same meridian. The name of each city is a string of, at most, 15 digits and/or characters of the Latin alphabet; there are no spaces in the name of a city.  Lines N+2..N+2+V-1: Each line contains two names of cities (taken from the supplied list), separated by a single blank space. This pair is connected by a direct, two-way airline flight.
题目输出：
Line 1: The number M of different cities visited in the optimal itinerary. Output 1 if no itinerary is possible.
输入样例：
8 9	
Vancouver		
Yellowknife	
Edmonton
Calgary
Winnipeg
Toronto	
Montreal
Halifax	
Vancouver Edmonton
Vancouver Calgary	
Calgary Winnipeg
Winnipeg Toronto
Toronto Halifax
Montreal Halifax
Edmonton Montreal
Edmonton Yellowknife
Edmonton Calgary
输出样例：
7
提示：




题目：Tall(1071)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
南京理工大学acm集训队即将迎来一批新人，他们身高各异，鱼头很想知道谁是最高的。
题目输入：
输入数据的第一行是测试的个数T（T<= 50），下面就是T个测试;
每个测试一行，第一个数字是n,表示人数，随后有n个整数x1,x2,x3,…,xn，表示每个人的身高;
题目输出：
输出最高的那个人。
输入样例：
2
5 1 2 3 4 5
3 122 134 155

输出样例：
5
155

提示：




题目：dreaming3000之火星旅行(1312)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
dreaming3000的xiaoyoulei有一天买了一张彩票，结果很不幸的事情发生了，他中奖了，可是对于这样的横财，dreaming3000有个不成文的规定，其他2个人也要分红，怎么办？怎么分？于是Bearjie 
就提出来我们去火星旅游吧。于是他们准备去火星旅游了。 
正如大家知道的，火星上是不能提供我们能生存的空气，所以旅游公司建了一些管道来连接这些旅游景点以便人工供氧，为了节省建造成本，旅游公司在建造时尽量建了少的管道，使得任意俩个景点能互相连通（可以经过其他的景点）。由于火星上的资源是全人类共有的，所以旅游公司不能收取景点的费用，当是他们能收取旅客们过管道的费用，不同的管道的费用可能不同。黑心的旅游公司为了赚更多的钱定下了一个规则：就是旅客不能往回走，当然可以在任意一个景点进入，任意一个景点出来。 
贪恋的zlly一听说能去火星旅游，而且是吝啬的xiaoyoulei 
出钱，于是想让xiaoyoulei多发费一些钱，可是zlly只能搞到旅游景点的地图，却不知道怎么旅游才能让xiaoyoulei多发钱，不过他听说NJUST的Acmer能过帮他解决这个问题，于是他向你们求救，你能告诉zlly能让xiaoyoulei 
发费多少钱吗？
题目输入：
第一行T，表示测试数据组数
每一组数据的第一行是一个 N（1 < = N< = 10^6），表示景点的个数.
接着有n-1行，每行有3个数a b c 表示（景点a到景点b之间）或（景点b到景点a之间）的管道收费是c  (a不等于b ,  1 < = a ,b < = n , 1 < = c < = 100) 保证任意2个景点是能连通的。

题目输出：
对与每一个组测试数据，输出一行表xiaoyoulei最多会发费多少钱。
输入样例：
2
2
1 2 1
5
1 2 2
2 3 5
2 4 3
2 5 4

输出样例：
3
27

提示：
注意是dreaming3000 有3个人，都会去旅游的



题目：AliceandBob'sTrip(1171)
时间限制：10000 ms
空间限制：65535 ms
题目描述：
	Alice and Bob are going on a trip. Alice is a lazy girl who wants to minimize the total travelling distance, while Bob as an active boy wants to maximize it. At the same time, they cannot let the value to be less than a given integer L since that will make them miss too much pleasure, and they cannot let the value to be greater than a given integer R since they don't want to get too exhausted.The city they are visiting has n spots and the spots are connected by directed edges. The spots are connected in such a way that they form a tree and the root will always be at spot 0. They take turns to select which edge to go. Both of them choose optimally. Bob will go first.	 
题目输入：
There are multiple test cases. For every test case, the first line has three integers, n, L and R (1<=n<=500000, 0<=L, R<=1000000000). The next n-1 lines each has three integers a, b and c, indicating that there is an edge going from spot a to spot b with length c (1<=c<=1000). The spots are labeled from 0 to n-1.There is a blank line after each test case.Proceed to the end of file.
题目输出：
If the total distance is not within the range [L, R], print "Oh, my god!" on a single line. Otherwise, print the most value Bob can get.
输入样例：
3 2 4
0 1 1
0 2 5

7 2 8
0 1 1
0 2 1
1 3 1
1 4 10
2 5 1
2 6 5

7 4 8
0 1 1
0 2 1
1 3 1
1 4 2
2 5 1
2 6 5

4 2 6
0 1 1
1 2 1
1 3 5

输出样例：
Oh, my god!
2
6
2
 
提示：
None



题目：生日礼物的意外(1416)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
我们的大队长xiaoyoulei同学，在过生日的时候收到了rayafjyblue送他的手链，这个手链是什么样子的呢，它有n个珠子，这n个珠子颜色都是不一样的，但是不小心被bobo弄散了，xiaoyoulei很生气，结果把波波揍了一顿，并且要bobo把手链接好，bobo在接手链的时候突然很想了解一个问题，就是他最多可以拼成多少种，因为他人品比较尴尬，所以他想知道他最多要拼多少次，才可以还原，我们认为经过旋转，翻转以后变成一样的是同一种，由于bobo眼神很好，所以他可以保证他每次不会接成一样的方案，现在他很头疼，所以他来问我，但是由于我要出题，所以我就问你们了
题目输入：
每一行有一个整数n，表示有多少个珠子，n<=500
输入以n=-1结束
题目输出：
输出一个整数，表示最多尝试的次数，由于数字会很大，所以最后的值模除一个3000
输入样例：
1
2
3
4
5
-1

输出样例：
1
3
11
70
629

提示：
大数使用long long,切莫使用__int64



题目：MiningYourOwnBusiness(1619)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		John Digger is theowner of a large illudium phosdex mine. The mine is made up of aseries of tunnels that meet at various large junctions. Unlike someowners, Digger actually cares about the welfare of his workers andhas a concern about the layout of the mine. Specifically, he worriesthat there may a junction which, in case of collapse, will cut offworkers in one section of the mine from other workers (illudiumphosdex, as you know, is highly unstable). To counter this, he wantsto install special escape shafts from the junctions to the surface.He could install one escape shaft at each junction, but Diggerdoesn't care about his workers that much. Instead, he wants toinstall the minimum number of escape shafts so that if any of thejunctions collapses, all the workers who survive the junctioncollapse will have a path to the surface.  	Write a program tocalculate the minimum number of escape shafts and the total number ofways in which this minimum number of escape shafts can be installed.  
题目输入：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		The input consists ofseveral test cases. The first line of each case contains a positiveinteger N (N5 . 104) indicating the number of mine tunnels.Following this are N lines each containing two distinctintegers s and t, where s and t arejunction numbers. Junctions are numbered consecutively starting at 1.Each pair of junctions is joined by at most a single tunnel. Each setof mine tunnels forms one connected unit (that is, you can get fromany one junction to any other).  	The last test case isfollowed by a line containing a single zero.  
题目输出：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		For each test case,display its case number followed by the minimum number of escapeshafts needed for the system of mine tunnels and the total number ofways these escape shafts can be installed. You may assume that theresult fits in a signed 64-bit integer.  	Follow the format ofthe sample output.  
输入样例：
9
1 3
4 1
3 5
1 2
2 6
1 5
6 3
1 6
3 2
6 
1 2
1 3
2 4
2 5
3 6
3 7
0
输出样例：
Case 1: 2 4
Case 2: 4 1
提示：
None



题目：命令行选项(1835)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　请你写一个命令行分析程序,用以分析给定的命令行里包含哪些选项。每个命令行由若干个字符串组成,它们之间恰好由一个空格分隔。这些字符串中的第一个为该命令行工具的名字,由小写字母组成,你的程序不用对它进行处理。在工具名字之后可能会包含若干选项,然后可能会包含一 些不是选项的参数。
　　选项有两类:带参数的选项和不带参数的选项。一个合法的无参数选项的形式是一个减号后面跟单个小写字母,如"-a" 或"-b"。而带参数选项则由两个由空格分隔的字符串构成,前者的格式要求与无参数选项相同,后者则是该选项的参数,是由小写字母,数字和减号组成的非空字符串。
　　该命令行工具的作者提供给你一个格式字符串以指定他的命令行工具需要接受哪些选项。这个字符串由若干小写字母和冒号组成,其中的每个小写字母表示一个该程序接受的选项。如果该小写字母后面紧跟了一个冒号,它就表示一个带参数的选项,否则则为不带参数的选项。例如, "ab:m:" 表示该程序接受三种选项,即"-a"(不带参数),"-b"(带参数), 以及"-m"(带参数)。
　　命令行工具的作者准备了若干条命令行用以测试你的程序。对于每个命令行,你的工具应当一直向后分析。当你的工具遇到某个字符串既不是合法的选项,又不是某个合法选项的参数时,分析就停止。命令行剩余的未分析部分不构成该命令的选项,因此你的程序应当忽略它们。
题目输入：
　　输入的第一行是一个格式字符串,它至少包含一个字符,且长度不超过 52。格式字符串只包含小写字母和冒号,保证每个小写字母至多出现一次,不会有两个相邻的冒号,也不会以冒号开头。
　　输入的第二行是一个正整数 N(1 ≤ N ≤ 20),表示你需要处理的命令行的个数。
　　接下来有 N 行,每行是一个待处理的命令行,它包括不超过 256 个字符。该命令行一定是若干个由单个空格分隔的字符串构成,每个字符串里只包含小写字母,数字和减号。
题目输出：
　　输出有 N 行。其中第 i 行以"Case i:" 开始,然后应当有恰好一个空格,然后应当按照字母升序输出该命令行中用到的所有选项的名称,对于带参数的选项,在输出它的名称之后还要输出它的参数。如果一个选项在命令行中出现了多次,只输出一次。如果一个带参数的选项在命令行中出 现了多次,只输出最后一次出现时所带的参数。
输入样例：
albw:x
4
ls -a -l -a documents -b
ls
ls -w 10 -x -w 15
ls -a -b -c -d -e -l
输出样例：
Case 1: -a -l
Case 2:
Case 3: -w 15 -x
Case 4: -a -b
提示：
多组输入，以EOF结尾



题目：最优子树问题(1719)
时间限制：1000ms
空间限制：65536k
题目描述：
		有一棵树，节点数为n（1<=n<=100 ），节点编号为（0,1,...,n-1）这棵树的每个点都有一个权值，现在要求你找出节点数为k( 1<=k<=n)的一个子树，并使这个子树的权值和最大。		
题目输入：
	有若干组测试数据，第一行输入两个整数n，k	第二行输入n个整数，表示从0到n-1各个点的权值	接下来n-1行，输入两个点u，v，表示这两个点有一条边相连	
题目输出：
	输出节点数大小为k的子树最大的权值和。
输入样例：
5 3
5 4 3 6 2
0 1
0 2
0 3
1 4

输出样例：
15
提示：
答案不会超过int



题目：Betsy'sTour(1521)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A square township has been divided up into N^2 square plots (1 <= N <= 7). The Farm is located in the upper left plot and the Market is located in the lower left plot. Betsy takes her tour of the township going from Farm to Market by walking through every plot exactly once. Shown below is one possible tour for Betsy when N=3. ----------------|    |    |    || F**********  ||    |    | *  |------------*---|    |    | *  ||  *****  | *  ||  * | *  | *  |---*---*----*---|  * | *  | *  ||  M | ******  ||    |    |    |----------------Write a program that will count how many unique tours Betsy can take in going from Farm to Market for any value of N.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1: A single integer N (1 <= N <= 7)
题目输出：
A single line with a single integer, the number of unique tours.
输入样例：
3
输出样例：
2
提示：




题目：大数乘法(1417)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
给出两个整数（<=100位），计算他们的积
题目输入：
多个case，以文件尾结束。
每个case两个整数

题目输出：
他们的乘积
输入样例：
1     1
99    99

输出样例：
1
9801

提示：




题目：PermutationCounting(1172)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	Given a permutation a1, a2, … aN of {1, 2, …, N}, we define its E-value as the amount of elements where ai > i. For example, the E-value of permutation {1, 3, 2, 4} is 1, while the E-value of {4, 3, 2, 1} is 2. You are requested to find how many permutations of {1, 2, …, N} whose E-value is exactly k.
题目输入：
There are several test cases, and one line for each case, which contains two integers, N and k. (1 <= N <= 1000, 0 <= k <= N).
题目输出：
Output one line for each case. For the answer may be quite huge, you need to output the answer module 1,000,000,007.
输入样例：
3 0
3 1

输出样例：
1
4

提示：
There is only one permutation with E-value 0: {1,2,3}, and there are four permutations with E-value 1: {1,3,2}, {2,1,3}, {3,1,2}, {3,2,1}



题目：史上最简单问题(1072)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
幸运的你，今天碰到了这个世界上最简单的问题。在这个问题中，所有你要做的就是为一个给定的数加一。并且，为了纪念出题者第一次为校赛出题，我甚至会告诉你这个最简单问题的做法(请见hint).聪明的你，还不赶紧抓住这道题^_^?hint:可以用字符串数组模拟这道题
题目输入：
第一行给出一个整数T,表示case数，然后会有T行，每一行一个十进制正整数x。为了体现我们的人文关怀，我们保证每一个数据的长度不会超过100位。
题目输出：
输出x+1
输入样例：
4
1
521
20100515
999
输出样例：
2
522
20100516
1000

提示：
可以用字符串数组模拟这道题



题目：FinalTrip(1313)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
Striving Panda 
这个暑假就要毕业去上海了，当然也不会在这里进行集训，如此长的假期，他打算充分利用这一段时间来把在南京没有参观过的景点游览一次。 
他仔细想了想，发现有n个景点他没有去过，所以他决定都去参观。他设想一种方案：从学校出发，依次游览这n个景点（每个景点必须游览且只游览一次），再从最后一个景点回到学校。我们知道 
，学校不是景点。另外Panda得到了一个优惠证，他从学校到任一个景点以及任一个景点到学校的费用都是免费的，但是 
从第i个景点到第j个景点的路途费用是cost[i][j] 。 
出于资金问题，他不想把主要费用花费在路途上，所以他想找一种最优的游览顺序，使得他在路途的总费用最少。你能帮他计算最少要多少费用吗？
题目输入：
每个测试给定n（<=18），表示n个景点，然后给出n*n的方阵，第i行j列说明从景点i到景点j的费用是cost[i][j]。
	文件以EOF结尾。

题目输出：
	每个Input输出1个数，表示总的最小费用。
输入样例：
2
0 1
2 0
4

0 3 6 7

5 0 3 5

6 2 0 9

1 2 7 0

输出样例：
1
7
提示：
Case 1: 学校->景点1->景点2->学校
Case 2: 学校->景点4->景点1->景点2->景点3->学校



题目：Pyramids(1620)
时间限制：3000 ms
空间限制：655350 ms
题目描述：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }		TT.cjk { font-family: "DejaVu Sans Condensed", monospace }	-->		It is not too hard tobuild a pyramid if you have a lot of identical cubes. On a flatfoundation you lay, say, 10 x 10 cubes in asquare. Centered on top of that square you lay a 9 x 9 square of cubes. Continuing this way you end up with a single cube,which is the top of the pyramid. The height of such a pyramid equalsthe length of its base, which in this case is 10. We call this a highpyramid.  	If you think that ahigh pyramid is too steep, you can proceed as follows. On the 10 x 10 base square, lay an 8 x 8 square, then a6 x 6 square, and so on, ending with a 2 x 2 top square (if you start with a base of odd length, you end up witha single cube on top, of course). The height of this pyramid is abouthalf the length of its base. We call this a low pyramid.  	Once upon a time(quite a long time ago, actually) there was a pharaoh who inherited alarge number of stone cubes from his father. He ordered his architectto use all of these cubes to build a pyramid, not leaving a singleone unused. The architect kindly explained that not every number ofcubes can form a pyramid. With 10 cubes you can build a low pyramidwith base 3. With 5 cubes you can build a high pyramid of base 2. Butno pyramid can be built using exactly 7 cubes.  	The pharaoh was notamused, but after some thinking he came up with new restrictions.  						All	cubes must be used.  									You	may build more than one pyramid, but you must build as few pyramids	as possible.  									All	pyramids must be different.  									Each	pyramid must have a height of at least 2.  									Satisfying	the above, the largest of the pyramids must be as large as possible	(i.e., containing the most cubes).  									Satisfying	the above, the next-to-largest pyramid must be as large as possible.  									And so on...  				Drawing figures andpictures in the sand, it took the architect quite some time to comeup with the best solution.  	Write a program thatdetermines how to meet the restrictions of the pharaoh, given thenumber of cubes.  
题目输入：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		The input consists ofseveral test cases, each one on a single line. A test case is aninteger c, where 1c106,giving the number of cubes available.  	The last test case isfollowed by a line containing a single zero.  
题目输出：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }		TT.cjk { font-family: "DejaVu Sans Condensed", monospace }	-->		For each test case,display its case number followed by the pyramids to be built. Thepyramids should be ordered with the largest first. Pyramids arespecified by the length of their base followed by an L for low pyramids or an H for high pyramids.If two different pyramids have the same number of cubes, list thehigh pyramid first. Print ``impossible"if it is not possible to meet the requirements of the pharaoh.  	Follow the format ofthe sample output.  
输入样例：
29
28
0
输出样例：
Case 1: 3H 3L 2H
Case 2: impossible
提示：
None



题目：等价交换(1720)
时间限制：1000MS
空间限制：65536K
题目描述：
 “想要得到一样东西，必须付出与之相等的代价，这就是炼金术的基本原则——等价交换，那时我们相信，这就是这个世界的真理” 在n个数字里（a1,a2...an,0<=ai<=9），你可以在数字之间添加+号，或者=号使得表达式成立。 例如 1 1 1 1 可以变成 1 + 1 = 1 + 1 ， 1 = 1 = 1 = 1  11 = 11 均使得表达成立(至少有一个"=")。
题目输入：
第一行输入一个整数n(2=<n<10),接着输入n个数。 当n = 0时结束
题目输出：
 输出最多有几种方式使得表达式成立。
输入样例：
4
1 1 1 1
5
1 2 3 4 5
输出样例：
3
1
提示：
无



题目：无线网络(1836)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　目前在一个很大的平面房间里有 n 个无线路由器,每个无线路由器都固定在某个点上。任何两个无线路由器只要距离不超过 r 就能互相建立网络连接。
　　除此以外,另有 m 个可以摆放无线路由器的位置。你可以在这些位置中选择至多 k 个增设新的路由器。
　　你的目标是使得第 1 个路由器和第 2 个路由器之间的网络连接经过尽量少的中转路由器。请问在最优方案下中转路由器的最少个数是多少?
题目输入：
　　第一行包含四个正整数 n,m,k,r。(2 ≤ n ≤ 100,1 ≤ k ≤ m ≤ 100, 1 ≤ r ≤ 108)。
　　接下来 n 行,每行包含两个整数 xi 和 yi,表示一个已经放置好的无线 路由器在 (xi, yi) 点处。输入数据保证第 1 和第 2 个路由器在仅有这 n 个路由器的情况下已经可以互相连接(经过一系列的中转路由器)。
　　接下来 m 行,每行包含两个整数 xi 和 yi,表示 (xi, yi) 点处可以增设 一个路由器。
　　输入中所有的坐标的绝对值不超过 108,保证输入中的坐标各不相同。
题目输出：
　　输出只有一个数,即在指定的位置中增设 k 个路由器后,从第 1 个路 由器到第 2 个路由器最少经过的中转路由器的个数。
输入样例：
5 3 1 3
0 0
5 5
0 3
0 5
3 5
3 3
4 4
3 0
输出样例：
2
提示：
多组输入，以EOF结尾



题目：Telecowmunication(1522)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Farmer John's cows like to keep in touch via email so they have created a network of cowputers so that they can intercowmunicate. These machines route email so that if there exists a sequence of c cowputers a1, a2, ..., a(c) such that a1 is connected to a2, a2 is connected to a3, and so on then a1 and a(c) can send email to one another. Unfortunately, a cow will occasionally step on a cowputer or Farmer John will drive over it, and the machine will stop working. This means that the cowputer can no longer route email, so connections to and from that cowputer are no longer usable. Two cows are pondering the minimum number of these accidents that can occur before they can no longer use their two favorite cowputers to send email to each other. Write a program to calculate this minimal value for them, and to calculate a set of machines that corresponds to this minimum. For example the network:                1*              /               3 - 2*shows 3 cowputers connected with 2 lines. We want to send messages between 1 with 2. Direct lines connect 1-3 and 2-3. If cowputer 3 is down, them there is no way to get a message from 1 to 2.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1 Four space-separated integers: N, M, c1, and c2. N is the number of computers (1 <= N <= 100), which are numbered 1..N. M is the number of connections between pairs of cowputers (1 <= M <= 600). The last two numbers, c1 and c2, are the id numbers of the cowputers that the questioning cows are using. Each connection is unique and bidirectional (if c1 is connected to c2, then c2 is connected to c1). There can be at most one wire between any two given cowputers. Computer c1 and c2 will not have a direction connection.  Lines 2..M+1 The subsequent M lines contain pairs of cowputers id numbers that have connections between them.
题目输出：
Generate two lines of output. The first line is the minimum number of cowputers that can be down before terminals c1 & c2 are no longer connected. The second line is a minimal-length sorted list of cowputers that will cause c1 & c2 to no longer be connected. Note that neither c1 nor c2 can go down. In case of ties, the program should output the set of computers that, if interpreted as a base N number, is the smallest one.
输入样例：
3 2 1 2
1 3
2 3
输出样例：
1
3
提示：




题目：真懒(1073)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
最近，一个题目难住了我们帅气的阿镇。他每天写很多单词，但是由于阿镇比较粗心，所以经常写错单词。然而，有时他写错单词之后又不想重新把这个单词再写一遍。所以他想修改其中的字母或者划去其中的字母，他可以有以下的几种方法：
 1.他可以在这个单词中插入一个字母。 
2他也可以删除一个字母。
 3.他可以将一个字母改写为另一个。
 例如，他写的字要“one”，但他写道，“two”。因此，他可以先删除两个字母“t”型和“w”（两个步骤）。他可以在结尾插入再两个字母”n”和”e”（两个步骤）。 这样，他需要4个步骤，以纠正错误的单词。另外他可以直接依次将”o””n””e”直接修改成”t””w””o” 共三个步骤。
 下面问题来了.求出他最少修改的步骤数目使得他的单词与原单词相同。
题目输入：
第一行给出了测试用例t 。
然后的t行，每行包含两个单词。第一个是正确的单词，第二是他写的单词。（区分大小写）
题目输出：
最少需要的步骤数目（与样例类似）每个结果占一行
输入样例：
INPUT
6
Words information
Int apple
Int int
However how
Howe how
I III

输出样例：
9
5
1
5
2
2

提示：




题目：求逆序数(1418)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
给出n（1<=n<=500000）个数，求出对这些数进行冒泡排序所需要进行交换的次数（升序）
题目输入：
一个整数n ,表示数据的个数
接下来n个整数，表示要排序的数

题目输出：
一个整数,表示冒泡排序中需要交换的次数
输入样例：
5
4  8  3  1  9

输出样例：
5
提示：




题目：疯狂的小鸟(1314)
时间限制：2000 ms
空间限制：65535 ms
题目描述：

最近疯狂的小鸟很火，大家玩的不亦乐乎。小鸟们的蛋被猪偷走了，很不爽，于是他们团结起来，扛了一堵墙，到最高处扔下。在初始时候，空中也有很多墙水平放置，用浮云驾着，猪们(不会在墙里面)就躲在这些墙下面，一旦这些空中的墙被下落的墙砸中，浮云就碎了，当前墙也随同下落墙一起往下掉。（最上面的墙只有一块）

最后输出从1号到m号猪头被压的墙的层数。
题目输入：
第一行输入一个n,m，n表示一共有n堵墙，墙就以直线表示，m表示有m个猪头。以-1 -1结束。
接着输入n个 （a b c）表示墙横坐标从[a,b]的高度为c的墙。最上层的墙就是自动下落的墙。
接着输入m个（a,c）表示猪头在横坐标为a的高度为c的位置。
（1<=n,m<=10 000,   1<=a,b<=100 000 000  ,1=< c <=10 000）
注:坐标原点在左下角

题目输出：
输出m个数，表示m个猪头（按照输入顺序输出）被压得墙的层数。
输入样例：
5 2
3 7 10
2 5 8
5 6 6
6 12 5
1 3 2
7 6
3 1
-1 -1

输出样例：
1 3

提示：
墙可能重叠。



题目：Seaside(1173)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	XiaoY is living in a big city, there are N towns in it and some towns near the sea. All these towns are numbered from 0 to N-1 and XiaoY lives in the town numbered ’0’. There are some directed roads connecting them. It is guaranteed that you can reach any town from the town numbered ’0’, but not all towns connect to each other by roads directly, and there is no ring in this city. One day, XiaoY want to go to the seaside, he asks you to help him find out the shortest way.	 
题目输入：
There are several test cases. In each cases the first line contains an integer N (0<=N<=10), indicating the number of the towns. Then followed N blocks of data, in block-i there are two integers, Mi (0<=Mi<=N-1) and Pi, then Mi lines followed. Mi means there are Mi roads beginning with the i-th town. Pi indicates whether the i-th town is near to the sea, Pi=0 means No, Pi=1 means Yes. In next Mi lines, each line contains two integers SMi and LMi, which means that the distance between the i-th town and the SMi town is LMi.
题目输出：
Each case takes one line, print the shortest length that XiaoY reach seaside.
输入样例：
5
1 0
1 1
2 0
2 3
3 1
1 1
4 100
0 1
0 1

输出样例：
2

提示：
None



题目：Picture(1523)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A number, N (1 <= N < 5000), of rectangular posters, photographs and other pictures of the same shape are pasted on a wall. Their sides are all vertical or horizontal. Each rectangle can be partially or totally covered by the others. The length of the boundary of the union of all rectangles is called the perimeter. Write a program to calculate the perimeter. Figure 1 shows an example with seven rectangles: Figure 1. A set of seven rectangles The corresponding boundary is the whole set of line segments drawn in Figure 2: Figure 2. The boundary of the set of rectangles The vertices of all rectangles have integer coordinates. All coordinates are in the range [-10000,10000] and any existing rectangle has a positive area. The numeric value of the result fits in a 32-bit signed representation.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1: N, the number of rectangles pasted on the wall.  Lines 2..N+1 In each of the subsequent lines, one can find the integer coordinates of the lower left vertex and the upper right vertex of each rectangle. The values of those coordinates are given as ordered pairs consisting of an x-coordinate followed by a y-coordinate.
题目输出：
A single line with a non-negative integer which corresponds to the perimeter for the input rectangles.
输入样例：
7
-15 0 5 10
-5 8 20 25
15 -4 24 14
0 -6 16 4
2 15 10 22
30 10 36 20
34 0 40 16
输出样例：
228
提示：




题目：任务调度(1837)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　有若干个任务需要在一台机器上运行。它们之间没有依赖关系,因此 可以被按照任意顺序执行。
　　该机器有两个 CPU 和一个 GPU。对于每个任务,你可以为它分配不 同的硬件资源:
　　1. 在单个 CPU 上运行。
　　2. 在两个 CPU 上同时运行。
　　3. 在单个 CPU 和 GPU 上同时运行。
　　4. 在两个 CPU 和 GPU 上同时运行。
　　一个任务开始执行以后,将会独占它所用到的所有硬件资源,不得中 断,直到执行结束为止。第 i 个任务用单个 CPU,两个 CPU,单个 CPU 加 GPU,两个 CPU 加 GPU 运行所消耗的时间分别为 ai,bi,ci 和 di。
　　现在需要你计算出至少需要花多少时间可以把所有给定的任务完成。
题目输入：
　　输入的第一行只有一个正整数 n(1 ≤ n ≤ 40), 是总共需要执行的任 务个数。
　　接下来的 n 行每行有四个正整数 ai, bi, ci, di(ai, bi, ci, di 均不超过 10), 以空格隔开。
题目输出：
　　输出只有一个整数,即完成给定的所有任务所需的最少时间。
输入样例：
3
4 4 2 2
7 4 7 4
3 3 3 3
输出样例：
7
提示：
样例说明
　　有很多种调度方案可以在 7 个时间单位里完成给定的三个任务,以下是其中的一种方案:
　　同时运行第一个任务(单 CPU 加上 GPU)和第三个任务(单 CPU), 它们分别在时刻 2 和时刻 3 完成。在时刻 3 开始双 CPU 运行任务 2,在 时刻 7 完成。



题目：TrashRemoval(1621)
时间限制：15000 ms
空间限制：65535 ms
题目描述：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		Allied ChuteManufacturers is a company that builds trash chutes. A trash chute isa hollow tube installed in buildings so that trash dropped in at thetop will fall down and be collected in the basement. Designing trashchutes is actually highly nontrivial. Depending on what kind of trashpeople are expected to drop into them, the trash chute needs to havean appropriate size. And since the cost of manufacturing a trashchute is proportional to its size, the company always would like tobuild a chute that is as small as possible. Choosing the right sizecan be tough though.  	We will consider a2-dimensional simplification of the chute design problem. A trashchute points straight down and has a constant width. Objects thatwill be dropped into the trash chute are modeled as polygons. Beforean object is dropped into the chute it can be rotated so as toprovide an optimal fit. Once dropped, it will travel on a straightpath downwards and will not rotate in flight. The following figureshows how an object is first rotated so it fits into the trash chute.  	 	Your task is to computethe smallest chute width that will allow a given polygon to passthrough.  
题目输入：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		The input containsseveral test cases. Each test case starts with a line containing aninteger n (3n100),the number of points in the polygon that models the trash item.  	The next n linesthen contain pairs of integers xi and yi (0xi, yi104),giving the coordinates of the polygon vertices in order. All pointsin one test case are guaranteed to be mutually distinct and thepolygon sides will never intersect. (Technically, there is oneinevitable exception of two neighboring sides sharing their commonvertex. Of course, this is not considered an intersection.)  	The last test case isfollowed by a line containing a single zero.  
题目输出：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		For each test case,display its case number followed by the width of the smallest trashchute through which it can be dropped. Display the minimum width withexactly two digits to the right of the decimal point, rounding up tothe nearest multiple of 1/100. Answers within 1/100 of the correctrounded answer will be accepted.  	Follow the format ofthe sample output.  
输入样例：
3
0 0
3 0
0 4
4
0 10
10 0
20 10
10 20
0
输出样例：
Case 1: 2.40
Case 2: 14.15
提示：
None



题目：致命玩笑(1721)
时间限制：5000MS
空间限制：65536K
题目描述：
			蝙蝠侠的宿敌小丑设置了一个小小的考验，如果蝙蝠侠不能在最少的时间内破解一个密码锁则会导致上千名人质的死亡，蝙蝠侠忙着和超人拯救世界没空陪他玩，这个考验自然就落到了身为他助手的你身上。				密码锁的设置如下，密码锁有n位，每位可以在0-9之间循环，你可以在一个步骤内旋转1-3个连续的位数上或者下，问最少需要多少步能从初始状态移到目标状态	
题目输入：
多组测试数据，以EOF结束 每组数据由序列S1和序列S2（长度<=1000）组成，分别代表初始状态和目标状态。
题目输出：
打开密码锁的最小步骤数
输入样例：
111111 222222
896521 183995
输出样例：
2
12
提示：
无



题目：才神的钱(1315)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
随着大家钱包里的钱越来越来多，作为才神的WAVwind 
当然钱就更多了，可是钱多了也有一个坏处，才神一个人管理不过来了，于是WAVwind就找了一些人来帮他管理钱，可是钱是罪恶的，这些人都想拿WAVwind的钱，作为Acmer的WAVwind就想到了一种预防他们的方法，让他们互相监督，如A能监督B，B也能监督A，当然如果A能监督B，B能监督C的话，A就能监督C，C也能监督A，WAVwind是很懒的，于是他就安排了最少的人互相监督，从而使所有的人都能互相监督。所以如果WAVwind只请了n个人，则他只要安排n-1对人互相监督就行了。但是有一个问题来了，如果某个人突然不在了（这样跟他有监督关系的人都会不被他监督了），这样其他一些存在互相监督的关系的人会团结起来变成一个个团伙，其中最多人数团伙的会互相包庇起来一起坑WAVwind的钱。不过作为才神的WAVwind 
也是有2把刷子的。当一个坑WAVwind钱的团伙坑的人不超过K个人时才神就能发现他们坑他的钱了。WAVwind现在想知道K至少为多少时，他才有可能发现有团伙坑他的钱。（即当K小于这个值时，无论哪个人突然不在了，WAVwind都不会发现有团伙坑他的钱）
题目输入：
第一行为T，表示WAVmind准备安排的互相监督的方案。
接着是T组数据表示，WAVmind的一种安排方案。
每组数据第一行有一个n (1< = n <= 10^5) 表示WAVmind在这个方案里准备请的人数，接着有n-1行 a b 表示WAVmind安排 a,b互相监督。(a不等于b ,  1 < = a ,b < = n , 数据保证满足题意要求）

题目输出：
对于每一种方案输出一行表示K .
输入样例：
2
3
1 2
2 3
7
1 2
2 3
2 4
1 5
5 6
6 7

输出样例：
1
3

提示：
树的重心




题目：积木游戏(1074)
时间限制：1000 ms
空间限制：65535 ms
题目描述：

有一位非常聪明可爱的小女孩SGY很喜欢玩积木游戏，而且与其他小朋友不同的是，她非常喜欢思考，她总是会预先计算好玩这个游戏每一步应该怎么操作，所以她总是能够赢得游戏的胜利。有一天，当她玩积木游戏的时候，她突然发现一个从前没有研究过的问题，她想知道如果把所有的积木放置成两排，横向看，从左往右，积木的高度依次递增，纵向看，后排的积木总是高于前排的积木，满足这个要求一共有多少种方案呢？(为了简化这个问题，我们把每一个积木看成是一个长方体，他有一个高度H,并且N个积木的高度依次为H[1]=1,H[2]=2,H[3]=3…H[i]=i;)

题目输入：
第一行是测试数据的个数T.
接下来T行，每行一个整数N(2<=N<=100)

题目输出：
输出答案模除20100501的值
输入样例：
2
2
3

输出样例：
1
2

提示：




题目：打印菱形(1419)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
打印边长为n的菱形
题目输入：
多个case，以文件尾结束.
每个case输入一个整数n (1<=n<=50),表示菱形的边长

题目输出：
边长为N的菱形，不要有多余的空格（每行均以'*'结尾）
输入样例：
6
输出样例：
     *
    ***
   *****
  *******
 *********
***********
 *********
  *******
   *****
    ***
     *

提示：




题目：THEMATRIXPROBLEM(1174)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
	You have been given a matrix CN*M, each element E of CN*M is positive and no more than 1000, The problem is that if there exist N numbers a1, a2, … an and M numbers b1, b2, …, bm, which satisfies that each elements in row-i multiplied with ai and each elements in column-j divided by bj, after this operation every element in this matrix is between L and U, L indicates the lowerbound and U indicates the upperbound of these elements.
题目输入：
There are several test cases. You should process to the end of file.Each case includes two parts, in part 1, there are four integers in one line, N,M,L,U, indicating the matrix has N rows and M columns, L is the lowerbound and U is the upperbound (1<=N、M<=400,1<=L<=U<=10000). In part 2, there are N lines, each line includes M integers, and they are the elements of the matrix.
题目输出：
If there is a solution print "YES", else print "NO".
输入样例：
3 3 1 6
2 3 4
8 2 6
5 2 9

输出样例：
YES

提示：
None



题目：HiddenPassword(1524)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Sometimes the programmers have very strange ways of hiding their passwords. Billy "Hacker" Geits chooses a string S composed of L (5 <= L <= 100,000) lowercase letters ('a'..'z') with length L. Then he makes and sorts all L-1 one-letter left cyclic shifts of the string. He then takes as a password one prefix of the lexicographically first of the obtained strings (including S). For example consider the string "alabala". The sorted cyclic one-letter left shifts (including the initial string) are: aalabal abalaal alaalab alabala balaala laalaba labalaa Lexicographically, first string is 'aalabal'. The first letter of this string ('a') is the 'a' that was in position 6 in the initial string (counting the first letter in the string as position 0). Write a program that, for given string S, finds the start position of the first letter of the sorted list of cyclic shifts of the string. If the first element appears more than once in the sorted list, then the program should output the smallest possible initial position.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1: A single integer: L Line 2..?: All L characters of the the string S, broken across lines such that each line has 72 characters except the last one, which might have fewer.
题目输出：
Line 1: A single integer that is the start position of the first letter, as described above.
输入样例：
7
alabala
输出样例：
6
提示：




题目：相邻数对(1838)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　给定n个不同的整数，问这些数中有多少对整数，它们的值正好相差1。
题目输入：
　　输入的第一行包含一个整数n，表示给定整数的个数。
　　第二行包含所给定的n个整数。评测用例规模与约定
　　1<=n<=1000，给定的整数为不超过10000的非负整数。
题目输出：
　　输出一个整数，表示值正好相差1的数对的个数。
输入样例：
6
10 2 6 3 7 8
输出样例：
3
提示：
样例说明
　　值正好相差1的数对包括(2, 3), (6, 7), (7, 8)。



题目：MonitoringWheelchairPatients(1622)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
															A researcher at a rehabilitation facility is studying the use that a patient makes of a motorized wheelchair in a restricted area at the facility. The chair's motor is connected to the axle by a chain drive. Therefore both wheels turn at the same speed and the chair can travel only in a straight line. The patient can stop the chair, rotate the wheels, and thereby change the direction only while the wheelchair is stopped. To help monitor its usage, the chair is equipped with a compass, a clock, and a speedometer. A recording device records each time interval that the chair is in motion, the average speed during the time interval, and the compass bearing during the time interval. The compass is a standard compass in which 0o is north, 90o is east, and so forth.																								A map of the restricted area is shown. The restricted area is the area of the lawn inside a 200 ft by 400 ft rectangle. Patients enter the restricted area from the door of a building located on the southern edge of the restricted area. The door is at the center of the 400 ft southern boundary, as shown in the figure.		The recording device turns itself on when the patient enters the restricted area through the door and monitors the patient's movements for up to 1 hour. Time is measured in seconds from 0 to 3600, with time 0 being the time the patient initially enters the restricted area through the door. The device records 4 numbers to describe the motion of the wheelchair during any interval when the motor is in operation. The first two numbers give the time the motion begins and ends; the third number gives the speed during the time interval; and the fourth number gives the compass bearing during the time interval. (During each time interval the wheelchair maintains constant speed and bearing.) For example, the recorded line	          10.6    15.9    2.8     274	would indicate that between times  and  seconds the wheelchair was traveling at speed of 2.8 ft/sec with compass bearing (direction) 274  . Times are recorded to 0.1 sec, speeds are recorded to 0.1 ft/sec, and bearings are recorded to a whole number of degrees.		Your job is to analyze the data from the wheelchair's recording device. Specifically, you must determine the following:				1)				Did the patient leave the restricted area after going through the door? If so, determine the first time that the patient left the restricted area and determine at what point on the perimeter of the restricted area the wheelchair crossed out of the restricted area. If the patient did not leave the restricted area, what was the distance from the door to the farthest point the patient reached within the area?				2)				What was the total distance that the patient traveled?									For the purpose of answering these questions, use coordinates with the location (0,0) corresponding to the southwest corner of the restricted area and the location (400,200) corresponding to the northeast corner. Since the recorder switches on when the patient passes through the door, the position of the patient at timet = 0.0 is always (200,0). Patients will be traveling north when they enter the restricted area.
题目输入：
	The input data consists of several data sets. The first line of each data set has an integer which is the number of lines recorded by the device. Each subsequent line in the data set consists of the four numbers recorded by the device during a particular time interval. The end of data is indicated by a data set whose first line consists of the number 0.		In the first data set of the sample input, the patient entered through the door (at time 0.0) and for the first 5 seconds was traveling due north at 3 ft/sec. From time t = 7 to t = 9 he traveled at a speed of 2 ft/sec with a compass bearing of 30  . He then stopped, changed his bearing to 60  , and then traveled at 4 ft/sec from time t = 10 to time t = 100. Ten seconds later (at time t = 110) he headed due north at 2 ft/sec until t = 200.
题目输出：
The output for each data set begins with an identification of that case. The output indicates whether the patient departed from the restricted area and if so the time and point of departure on the perimeter. If not, the maximum distance the patient reached from the door is provided. For each case, the total distance that the patient traveled is provided. Format your output so that the same labeling information is included as shown in the sample output, with a line of asterisks separating the cases.
输入样例：
4
0.0	5.0	3.0	0
7.0	9.0	2.0	30
10.0	100.0	4.0	60
110.0	200.0	2.0	0
3
0.0	20.0	2.0	0
500.0	600.0	1.0	270
3000.0	3100.0	1.0	0
7
0.0	5.3	2.1	0
19.8	35.6	2.7	346
42.0	78.4	2.3	15
1181.4	1192.1	1.7	117
2107.0	2193.6	2.1	295
2196.3	2201.2	2.0	298
2704.3	2709.2	1.5	208
0
输出样例：
Case Number 1
Left restricted area at point (400.0,132.8) and time 67.2 sec.
Total distance traveled was 559.0 feet
***************************************
Case Number 2
No departure from restricted area
Maximum distance patient traveled from door was 172.0 feet
Total distance traveled was 240.0 feet
***************************************
Case Number 3
Left restricted area at point (67.0,200.0) and time 2191.4 sec.
Total distance traveled was 354.7 feet
***************************************
提示：

	Assumptions and requirements


	1. Within each data set, time intervals will be listed in chronological order, with the first time interval always having time 0.0 as the time of entry into the restricted area. All times will be given with one decimal place accuracy and will be in the range 0.0 to 3600.0 inclusive. For each time interval specified, the duration of the time interval will be positive, i.e. the second time specified will be greater than the first.


	2. Speeds will be in the range 0.1 to 9.9 ft/sec.


	3. Compass bearings will be given as a whole number of degrees and will be in the range 0 to 359 inclusive. The initial compass bearing for the first line of data in each data set will be 0.


	4. Within each line of data, numbers will be separated by at least one blank space.


	5. All numerical results will be displayed with one decimal place of accuracy as shown in the sample output.


	6. If the patient goes out of the restricted area, his location may include negative coordinates. However, you don't have to worry about the wheelchair crashing through the walls of the building.




题目：所有的平方差(1722)
时间限制：2000ms
空间限制：65536K
题目描述：
	我们发现有一些数具备这样的性质，比如3这个数字，可以用两个自然数的平方之差得到，3=2*2-1*1，有时这种情况不止一种，例如9，可以有这两种表示：9=3*3-0*0和9=5*5-4*4，但是也可能出现不存在的情况，例如6没有办法表示成任何的两个自然数平方差的情况。	现在我们要求找出给定的n所有的平方差，例如有m对符合要求，那么假设这m对表示成:	n = a1*a1 - b1*b1, n = a2*a2 - b2*b2, ... , n = am*am - bm*bm	其中对于任意的1<=k1,k2<=m，ak1 != ak2 或者 bk1 != bk2，并且ak1,ak2,bk1,bk2>=0	那么我们需要求的是n^(a1*a1+b1*b1+a2*a2+b2*b2+...+am*am+bm*bm) % 大质数10000000019的值
题目输入：
第一行输入一个整数T, 表示有T组测试数据。 每组Case，输入一个整数n(1<=n<=2^62)
题目输出：
输出以Case X: N的形式，X是当前的Case数目，从1开始计数，N为题设中要求得到的那个值，如果所得的m=0，在输出-1。
输入样例：
2
3
6
输出样例：
Case 1: 243
Case 2: -1
提示：
无



题目：陪小屁孩买东西(1316)
时间限制：1000 ms
空间限制：65535 ms
题目描述：

今天，WAVwind陪小屁孩去苏果超市买东西，可是，付账的时候人实在太多了，而且大家都买了好多好多东西，一个人付账就要好长时间。小屁孩就买了一盒饼干，WAVwind拿着那盒饼干站在队伍末尾，WAVwind心里就想啊：让我先付账多好啊，也浪费不了后面人的多少时间，可能半分钟就搞定了。
假设已知队伍的人数为N，且每个人付账需要的时间也确定了为Ai，现在呢，WAVwind请你计算一下，怎样排队可以使得N个人全部都付完帐后大家总的等待时间最短。
题目输入：
一个整数CASE,表示测试样例的个数。对于每组数据，输入一个整数N(1<=N<=1000)，表示总排队的人数，接着N个整数分别表示每个人付账需要的时间。(1<=Ai<=100)
题目输出：
要求输出最少的总等待时间。
(自己付账时的等待时间也算入其中)

输入样例：
1
3
4 7 1

输出样例：
18
提示：




题目：爬楼梯(1075)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
似乎大家都有做电梯的习惯，现在为了锻炼身体，我们漂亮的贾琼姐姐提议大家天天走楼梯，另外一个方面，帆哥比较喜欢思考，他想知道到底有多少种方法能够走到楼顶。由于帆哥身体素质不够过关，他一次最多只能跨两个台阶，最少跨一个台阶。
题目输入：
第一行给出测试样例的个数t（t<100)
接下来给出t行，每行给出楼梯的高度n(1<=n<=20)

题目输出：
他一共有多少种不同的走法能够走到楼顶
输入样例：
2
2
19

输出样例：
2
6765

提示：




题目：Transportation(1175)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	There are N cities, and M directed roads connecting them. Now you want to transport K units of goods from city 1 to city N. There are many robbers on the road, so you must be very careful. The more goods you carry, the more dangerous it is. To be more specific, for each road i, there is a coefficient ai. If you want to carry x units of goods along this road, you should pay ai * x2 dollars to hire guards to protect your goods. And what’s worse, for each road i, there is an upper bound Ci, which means that you cannot transport more than Ci units of goods along this road. Please note you can only carry integral unit of goods along each road.You should find out the minimum cost to transport all the goods safely. 
题目输入：
There are several test cases. The first line of each case contains three integers, N, M and K. (1 <= N <= 100, 1 <= M <= 5000, 0 <= K <= 100). Then M lines followed, each contains four integers (ui, vi, ai, Ci), indicating there is a directed road from city ui to vi, whose coefficient is ai and upper bound is Ci. (1 <= ui, vi <= N, 0 < ai <= 100, Ci <= 5)
题目输出：
Output one line for each test case, indicating the minimum cost. If it is impossible to transport all the K units of goods, output -1.
输入样例：
2 1 2
1 2 1 2
2 1 2
1 2 1 1
2 2 2
1 2 1 2
1 2 2 2

输出样例：
4
-1
3

提示：
None



题目：Easytask(1420)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Given a string containing 'a' to 'z' with length N(1<=N<=100000)。
You have two operations:
Q L R : output the length of the longest consecutive non-decreasing subsequence
C L R P : replace each letter from L to R by letter P('a'<=P<='z') 。
in which,1<=L,R<=N.what's more,maybe you should know the fact 'a'<'b'<'c'<...<'z' . 
SA10010044 considers it an easy task ,isn't it ?
题目输入：
T in the first line,indicating the case number(T<=10).
Each case starts with a string(the length of it will be no more than 100000)
The next line contains a number QQ,representing the operation number.(1<=QQ<=100000).
Then the next QQ lines,each line has an operation:
   Q L R
   C L R P
as described above.Notice : L may be larger than R.

题目输出：
For each Q,output the answer.
输入样例：
1
abcdef        
5           
Q 1 6         
C 3 4 b
Q 1 3
C 4 5 c
Q 2 5

输出样例：
6
3
4

提示：




题目：Twofive(1525)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
In order to teach her young calvess the order of the letters in the alphabet, Bessie has come up with a game to play with them. The calves are given a 5 x 5 grid on which they can put the letters 'A'-'Y', but the one rule is that all the letters going across the columns and down the rows must be in the order they appear in the alphabet. There are a huge number of possible grids, so Bessie decides that they will be named by the string of letters that is given by reading across each row, going down the rows. For example, the grid:       A B C D E     F G H I J     K L M N O     P Q R S T      U V W X Ywould have the name ABCDEFGHIJKLMNOPQRSTUVWXY, which is coincidentally the first possible grid when the entire set of grids is ordered alphabetically. The second grid that meets this requirement is ABCDEFGHIJKLMNOPQRSUTVWXY, which is formed by switching the 'T' and 'U' in the above grid. Help the calves gain bragging rights. Given a number, M, find which string is Mth in the list of all possible grids when they are sorted alphabetically, and, given a string of letters, find out what number the corresponding grid is in the list of all possible grids.
题目输入：
There are several test cases, end by EOF, for each test case:The first input line contains one of two letters, either an 'N' or a 'W'. If the first input line contains an 'N', the second line will contain an integer, M, that corresponds to the number of a valid grid. If the first line contains a 'W', the second line will contain a string of 25 letters, which represents a valid grid.
题目输出：
If the input contained the number of a valid grid (first line 'N'), the output should contain a string of 25 letters on a line, which corresponds to the Mth grid in the sorted list of all possible grids. If the input contained a string of letters indicating a grid (first line 'W'), the output should contain a single integer on a line, which corresponds to the number of the given grid in the list of all possible grids.
输入样例：
N
2
输出样例：
ABCDEFGHIJKLMNOPQRSUTVWXY
提示：




题目：画图(1839)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　在一个定义了直角坐标系的纸上，画一个(x1,y1)到(x2,y2)的矩形指将横坐标范围从x1到x2，纵坐标范围从y1到y2之间的区域涂上颜色。
　　下图给出了一个画了两个矩形的例子。第一个矩形是(1,1) 到(4, 4)，用绿色和紫色表示。第二个矩形是(2, 3)到(6, 5)，用蓝色和紫色表示。图中，一共有15个单位的面积被涂上颜色，其中紫色部分被涂了两次，但在计算面积时只计算一次。在实际的涂色过程中，所有的矩形都涂成统一的颜色，图中显示不同颜色仅为说明方便。
 　　给出所有要画的矩形，请问总共有多少个单位的面积被涂上颜色。

题目输入：
　　输入的第一行包含一个整数n，表示要画的矩形的个数。
　　接下来n行，每行4个非负整数，分别表示要画的矩形的左下角的横坐标与纵坐标，以及右上角的横坐标与纵坐标。评测用例规模与约定
　　1<=n<=100，0<=横坐标、纵坐标<=100。
题目输出：
　　输出一个整数，表示有多少个单位的面积被涂上颜色。
输入样例：
2
1 1 4 4
2 3 6 5
输出样例：
15
提示：
None



题目：AncientMessages(1623)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }	-->		In order to understandearly civilizations, archaeologists often study texts written inancient languages. One such language, used in Egypt more than 3000years ago, is based on characters called hieroglyphs. Figure C.1shows six hieroglyphs and their names. In this problem, you willwrite a program to recognize these six characters.  	 	FigureC.1: Six hieroglyphs  
题目输入：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }		TT.cjk { font-family: "DejaVu Sans Condensed", monospace }	-->		The input consists ofseveral test cases, each of which describes an image containing oneor more hieroglyphs chosen from among those shown in Figure C.1. Theimage is given in the form of a series of horizontal scan linesconsisting of black pixels (represented by 1) and white pixels(represented by 0). In the input data, each scan line is encoded inhexadecimal notation. For example, the sequence of eight pixels 10011100 (one black pixel, followed by twowhite pixels, and so on) would be represented in hexadecimal notationas 9c. Only digits and lowercase letters a through f are used in the hexadecimalencoding. The first line of each test case contains two integers, H and W. H (0 < H200)is the number of scan lines in the image. W (0 < W50)is the number of hexadecimal characters in each line. The next H lines contain the hexadecimal characters of the image, working fromtop to bottom. Input images conform to the following rules:  							The	image contains only hieroglyphs shown in Figure C.1.  									Each	image contains at least one valid hieroglyph.  									Each	black pixel in the image is part of a valid hieroglyph.  									Each	hieroglyph consists of a connected set of black pixels and each	black pixel has at least one other black pixel on its top, bottom,	left, or right side.  									The	hieroglyphs do not touch and no hieroglyph is inside another	hieroglyph.  									Two	black pixels that touch diagonally will always have a common	touching black pixel.  									The hieroglyphs	may be distorted but each has a shape that is topologically	equivalent to one of the symbols in Figure C.1. (Two figures are	topologically equivalent if each can be transformed into the other	by stretching without tearing.)  				The last test caseis followed by a line containing two zeros.  
题目输出：
	<!--		@page { margin: 2cm }		P { margin-bottom: 0.21cm }		TT.cjk { font-family: "DejaVu Sans Condensed", monospace }	-->		For each test case,display its case number followed by a string containing one characterfor each hieroglyph recognized in the image, using the followingcode:  	Ankh: A Wedjat: J Djed: D Scarab: S Was: W Akhet: K  	In each outputstring, print the codes in alphabetic order. Follow the format of thesample output.  	The sample inputcontains descriptions of test cases shown in Figures C.2 and C.3. Dueto space constraints not all of the sample input can be shown on thispage.  	
输入样例：
100 25
0000000000000000000000000
0000000000000000000000000
...(50 lines omitted)...
00001fe0000000000007c0000
00003fe0000000000007c0000
...(44 lines omitted)...
0000000000000000000000000
0000000000000000000000000
150 38
00000000000000000000000000000000000000
00000000000000000000000000000000000000
...(75 lines omitted)...
0000000003fffffffffffffffff00000000000
0000000003fffffffffffffffff00000000000
...(69 lines omitted)...
00000000000000000000000000000000000000
00000000000000000000000000000000000000
0 0
输出样例：
Case 1: AKW
Case 2: AAAAA
提示：
None



题目：Anotherlottery(1318)
时间限制：5000 ms
空间限制：65535 ms
题目描述：

Even in times of an economic crisis, people in Byteland still like to 
participate in lotteries. With a bit of luck, they might get rid of all their 
sorrows and become rich. 
The most popular lottery in Byteland consists of m rounds. In 
each round, everyone can purchase as many tickets as he wishes, and among all 
tickets sold in this round, one ticket is chosen randomly, each one with the 
same probability. The owner of that ticket wins the prize money of this round. 
Since people in Byteland like powers of 2, the prize money for the winner of 
round i amounts to 2i Bytelandian 
Dollars. 
Can you determine for each participant in the lottery the probability that he 
will win more money than anybody else? 
题目输入：
The input consists of several test cases. Each test case starts with a line containing two integers n and m, the number of participants in the lottery and the number of rounds in the lottery. You may assume that 1 ≤ n ≤ 10000 and 1 ≤ m ≤ 30.

The following n lines contain the description of the tickets bought by the participant. The ith such line contains m non-negative integers c1, ..., cm, where cj (1 ≤ j ≤ m) is the amount of tickets of round j bought by partipant i. The total number of tickets sold in each round is between 1 and 109.

The input ends with a line containing 2 zeros. 
题目输出：
For each test case, print n lines of output, where line i contains the probability as a reduced fraction that participant i wins the most money. See the sample output for details. 
输入样例：
5 4
3 1 2 3
3 1 2 4
3 1 3 5
4 4 4 0
5 5 0 0
1 1
1
0 0
输出样例：
1 / 4
1 / 3
5 / 12
0 / 1
0 / 1
1 / 1
提示：




题目：小坑坑堆砖头(1723)
时间限制：5000MS
空间限制：131072KB
题目描述：
	小坑坑觉得堆砖头太坑了，于是想要破解了这个游戏。	小坑坑有一堆砖头，每个砖头都有两个属性，一个是他的质量，一个是他所能承受的质量。	现在小坑坑想要将这些砖头尽可能地堆起一堆，使其总质量最大。		PS:质量小的砖头只能放在质量大于等于的砖头上面，如果一个砖头上面所放砖头的总质量大于了该砖头所能承受的质量，则该砖头会破碎。
题目输入：
	输入一个整数T(T<=10)，表示样例的个数，接下来输入整数n，表示n(n<=30)个砖头，接下来输入n行，每行分别有两个数m1,m2(m1 <= 50 , m2<= 1500)，分别表示每个砖块自己的质量和所能承受的质量。	
题目输出：
	每个样例分别输出他所堆出的最大质量。	
输入样例：
1
3
5 6
4 5
3 2
输出样例：
9
提示：
None



题目：Volume(1176)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	This time your job is to calculate the volume of a special object. The object consists of two orthogonal cylinders. The two cylinders intersect each other in the middle place. One example is shown in Fig. 1. The radiuses of the bottom disk of both cylinders are R, and the heights of both cylinders are H.	 
题目输入：
We test the problem in many cases. Each case includes two integers, the first one is R and the second one is H. All the numbers given are positive integers and are less than 100.
题目输出：
The output consists of the volumes. The results must be round to 4 decimal numbers. Remember that R may be less than half of H.
输入样例：
10 30
10 40

输出样例：
13516.2226
19799.4079

提示：
None



题目：机器人(1421)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
有一个机器人，在一个神秘的小屋里走着，上面有一些开关。现在这个机器人需要将这些开关全部打开，但是由于机器人程序问题，每次走到开关位置时，都会去改变一下开关的状态（由开变关，或由关变开），如果这个开关开启之后再关上那么会有意想不到的后果，为了避免这种情况出现，所以机器人只能走到每一个开关上有且只有一次。而且这个机器人高度智能化，从现在所处的位置到下一个开关处最多只会拐一次弯（如果两点的坐标x，y其中之一相同，则不会拐弯，否则只拐一次弯）
我们想知道机器人打开所有开关用的最长步数是多少？比如从位置（x,y）到（x,y+1）算一步，聪明的你肯定懂一步的其他几种情况。
题目输入：
第一行输入T，表示有T个case，每个case中：
第一行输入一个数n，表示开关个数(n<=15)
接下来有n行，每行两个整数x，y表示开关坐标0<=x,y<=1000
机器人的起始位置可以任意设置，但是必须在某一开关处。

题目输出：
每个样例输出一个数，表示最长的步数
输入样例：
2
2
1 1
2 2
3
1 1
2 2
3 3

输出样例：
2
6

提示：




题目：Rich(1076)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
鱼头每个月都领工资，但是他发现工资并不是每个月儿都一样的，于是，他想知道自己的平均月工资是多少。
题目输入：
12个数字，分别代表每个月鱼头的工资
题目输出：
输出平均值（结果保留两位小数）
输入样例：
1000 1200 1300 1202 1450 1907 1770 200 300 1300 1907 1770
输出样例：
1275.50
提示：




题目：PostalVans(1526)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Tiring of their idyllic fields, the cows have moved to a new suburb. The suburb is a rectangular grid of streets with a post office at its Northwest corner. It has four avenues running East-West and N (1 <= N <= 1000) streets running North-South. For example, the following diagram shows such a suburb with N=5 streets, with the avenues depicted as horizontal lines, and the post office as a dark blob at the top-left corner: Each day the postal van leaves the post office, drives around the suburb and returns to the post office, passing exactly once through every intersection (including those on borders or corners). The executives from the post company want to know how many distinct routes can be established for the postal van (of course, the route direction is significant in this count). For example, the following diagrams show two such routes for the above suburb: As another example, the following diagrams show all the four possible routes for a suburb with N=3 streets: Write a program that will determine the number of such distinct routes given the number of streets.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1: A single integer, N
题目输出：
Line 1: A single integer that tells how many possible distinct routes corresponding to the number of streets given in the input.
输入样例：
4
输出样例：
12
提示：




题目：Subblock(1624)
时间限制：1000 ms
空间限制：125536 ms
题目描述：
	  		You must know the differences between substring nd subsequence.Four-dimensional thinking—Xiaoyoulei knows too，someday he invents one new definition—subblock.	Give you one text，which contains only lower case letters,then a pattern string which contains lower case letters and character '*'.	The substrings of the pattern seperated by the character '*' are viewed as a whole just like one character,	we name the pattern as b1*b2*b3*……bn,here bi is the substring,the character ‘*’can match none or one or more characters.	if b1b2b3……bn is the text's subsequence ,we say the pattern string is the subblock of the text.Here is the task,	if given pattern is the subblock of the given text,output "YES",otherwise output "NO".	
题目输入：
Line 1：the text,contains only the lower case letter,whose length is mo more than 100000 and bigger than 0.Line 2: the pattern string，only the lower case letter and character '*'，whose length is mo more than 100000 and bigger than 0.the number of charavter '*' is no more than 10。Input ends with EOF.
题目输出：
Line 1：if given pattern is the subblock of the given text,output "YES",otherwise output "NO".Sample Input
输入样例：
abc
a*
abc
*b
abc
*cb*
输出样例：
YES
YES
NO
提示：
None



题目：字符串匹配(1840)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　给出一个字符串和多行文字，在这些文字中找到字符串出现的那些行。你的程序还需支持大小写敏感选项：当选项打开时，表示同一个字母的大写和小写看作不同的字符；当选项关闭时，表示同一个字母的大写和小写看作相同的字符。
题目输入：
　　输入的第一行包含一个字符串S，由大小写英文字母组成。
　　第二行包含一个数字，表示大小写敏感的选项，当数字为0时表示大小写不敏感，当数字为1时表示大小写敏感。
　　第三行包含一个整数n，表示给出的文字的行数。
　　接下来n行，每行包含一个字符串，字符串由大小写英文字母组成，不含空格和其他字符。评测用例规模与约定
　　1<=n<=100，每个字符串的长度不超过100。

题目输出：
　　输出多行，每行包含一个字符串，按出现的顺序依次给出那些包含了字符串S的行。
输入样例：
Hello
1
5
HelloWorld
HiHiHelloHiHi
GrepIsAGreatTool
HELLO
HELLOisNOTHello
输出样例：
HelloWorld
HiHiHelloHiHi
HELLOisNOTHello
提示：
样例说明
　　在上面的样例中，第四个字符串虽然也是Hello，但是大小写不正确。如果将输入的第二行改为0，则第四个字符串应该输出。



题目：Ballotevaluation(1319)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
Before the 2009 elections at the European Parliament, Bill and Ted have 
asked their friends to make guesses about the outcome of the ballot. Now, the 
results have been published, so Bill and Ted want to check who was right. But 
checking the results of their many friends would take a very long time, and they 
need the evaluation to be done by a computer. Since they are not so good at 
programming, they ask you for help.
题目输入：
The data provided by Bill and Ted has the following format: The first line consists of the number p of parties followed by the number g of guesses (with 1 ≤ p ≤ 50 and 1 ≤ g ≤ 10000). Then follow p lines, each line consisting of a unique party name of length ≤ 20 (only containing letters a-z, A-Z and digits 0-9) and the achieved vote percentage of this party with one digit after the decimal point. After the parties follow g lines, each consisting of a guess. A guess has the form P1 + P2 + ... + Pk COMP n, where P1 to Pk are party names, COMP is one of the comparison operators , <=, >= or = and n is an integer between 0 and 100, inclusively. Each party name occurs at most once in each guess. 
题目输出：
For each guess, sum up the vote percentages of the parties and compare them with the specified integer n. Then, print a line stating whether the guess was correct. See the sample output for details. 
输入样例：
6 5
CDU 30.7
SPD 20.8
Gruene 12.1
FDP 11.0
DIELINKE 7.5
CSU 7.2
FDP > 11
CDU + SPD < 50
SPD + CSU >= 28
FDP + SPD + CDU <= 42
CDU + FDP + SPD + DIELINKE = 70

输出样例：
Guess #1 was incorrect.
Guess #2 was incorrect.
Guess #3 was correct.
Guess #4 was incorrect.
Guess #5 was correct.

提示：
Be careful with the comparison of floating point values, because some values in the input (like 0.1) do not have an exact representation as a floating point number.



题目：Problem-DeltaWave(1177)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
	The researchers have discovered a new kind of species call "otaku",whose brain waves are rather strange. The delta wave of an otaku's brain can be approximated by a polygonal line in the 2D coordinate system. The line is a route from point (0,0) to (N,0), and it is allowed to move only to the right(up,down or straight) at every step. And during the whole moving, it is not allowed to dip below the y=0 axis. 	For example, there are the 9 kinds of delta waves for N=4:	            	Given N, you are requested to find out how many kinds of different delta waves of otaku. 	 
题目输入：
There are no more than 20 test cases. There is only one line for each case, containing an integer N  ( 1000 <= N < = 10000 )
题目输出：
Output one line for each test case. For the answer may be quite huge, you need only output the answer mod 10^100.
输入样例：
1000
2000
输出样例：
6931034666534175155289953905326098910534128693214689917140093377138459245912955193770266157466468457
8451046774713572913143679282992147665005735760822308240585775136207162862343802397227405194192080977
提示：
None



题目：小坑坑漂流记(1724)
时间限制：5000MS
空间限制：131072KB
题目描述：
	小坑坑有次漂流到了一个岛上，觉得太坑了，于是他要破解这个岛的秘密。	对于这个小岛，小坑坑想要知道的是，这岛上的哪一点距海岸最远呢？最远的距离是多少呢？	为了简化问题，我们只考虑这座岛是一个凸的简单多边形。
题目输入：
	输入包括多组数据。每组数据是岛的地图，第一行为整数n（3 <= n <= 100），代表多边形的点数。	接下来n行，每行一个坐标x和y。(0 <= x_i, y_i <= 10000)	线段(x_i,y_i)-(x_i+1,y_i+1)按逆时针方向输入。	输入以n=0结束。
题目输出：
	每组数据输出一行，输出最远的距离，保留6位小数。	
输入样例：
4
0 0
1 0
1 1
0 1

3
1 1
2 2
1 2
输出样例：
0.500000
0.292893
提示：
None



题目：逆序数(1422)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
话说我们都会算全排列的逆序数。
例如：1 4 3 2，逆序数为3，因为有3对（4,3）（4,2）（3,2）
但是我们总喜欢逆向思维，也就是对长度为4，逆序数为3的全排列个数感兴趣，现在请你帮忙解决下这个问题。
题目输入：
第一行输入T，case数
每个case输入两个数，n<=1000，k<=10000，表示全排列的长度和逆序对数

题目输出：
输出一个数，表示满足的全排列个数，数字太大，模1000000007后输出。
输入样例：
1
4 3

输出样例：
6
提示：




题目：儿童节(1077)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
儿童节快到了，Kane请求他的父亲给他买一堆礼物。但是，他的父亲有点小气，父亲列举了2条规定：1.礼物的数量不得大于M，2.礼物的总质量必须小于等于W。在商店里，每件礼物有它的价格和质量，另外，有些礼物是特殊的，顾客每次只能买1件同样的礼品。现在，Kane希望得到的礼物价格总和最大，你能帮助他吗？
题目输入：
标准输入包括几个样例：每个样例的第一行给出3个整数N, M, W (N<=50, M<=50, W<=1000). N是在商店中礼物的种类数. M是爸爸规定的Kane所能买的礼物总数。W是爸爸规定的礼物总质量。在接下来的N行，每行给出3个整数A, B, C (A<=1000, B<=1000). A表示礼物的价格。B表示礼物的质量，C (0或1) 表示礼物是否特殊：1表示礼物只能买1件，0表示礼物能买任意件。输入最后以0 0 0结束。
题目输出：
对于每个样例，只须在每一行输出Kane的父亲付出钱的最大值。
输入样例：
2 3 100
15 15 0
65 60 1
2 3 100
40 40 0
60 65 1
0 0 0

输出样例：
95
80

提示：




题目：最优配餐(1841)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　栋栋最近开了一家餐饮连锁店，提供外卖服务。随着连锁店越来越多，怎么合理的给客户送餐成为了一个急需解决的问题。
　　栋栋的连锁店所在的区域可以看成是一个n×n的方格图（如下图所示），方格的格点上的位置上可能包含栋栋的分店（绿色标注）或者客户（蓝色标注），有一些格点是不能经过的（红色标注）。
　　方格图中的线表示可以行走的道路，相邻两个格点的距离为1。栋栋要送餐必须走可以行走的道路，而且不能经过红色标注的点。
 
　　送餐的主要成本体现在路上所花的时间，每一份餐每走一个单位的距离需要花费1块钱。每个客户的需求都可以由栋栋的任意分店配送，每个分店没有配送总量的限制。
　　现在你得到了栋栋的客户的需求，请问在最优的送餐方式下，送这些餐需要花费多大的成本。

题目输入：
　　输入的第一行包含四个整数n, m, k, d，分别表示方格图的大小、栋栋的分店数量、客户的数量，以及不能经过的点的数量。
　　接下来m行，每行两个整数xi, yi，表示栋栋的一个分店在方格图中的横坐标和纵坐标。
　　接下来k行，每行三个整数xi, yi, ci，分别表示每个客户在方格图中的横坐标、纵坐标和订餐的量。（注意，可能有多个客户在方格图中的同一个位置）
　　接下来d行，每行两个整数，分别表示每个不能经过的点的横坐标和纵坐标。评测用例规模与约定
　　前30%的评测用例满足：1<=n <=20。
　　前60%的评测用例满足：1<=n<=100。
　　所有评测用例都满足：1<=n<=1000，1<=m, k, d<=n^2。可能有多个客户在同一个格点上。每个客户的订餐量不超过1000，每个客户所需要的餐都能被送到。
题目输出：
　　输出一个整数，表示最优送餐方式下所需要花费的成本。
输入样例：
10 2 3 3
1 1
8 8
1 5 1
2 3 3
6 7 2
1 2
2 2
6 8
输出样例：
29
提示：
None



题目：GraduationTrip(1625)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
At the end of life in university,misshanli would like to have a gradution trip from city st to city ed.She has mapped out several cities as choices.Each city has a certain number of old friends.She refered the train ticket price between some couples of cities on the 12306 net.Even though she has been saving money for long,lack of money is still the constraint of visiting all of the friends.Now she wants to costs as little money as possible from city st to city ed and visit as many friends as possible at the same time.Of course,saving money is most important.Here is the problem.Whatis the number of the "money-shortest" path?And among these paths,what's the maximum number of friends she can visit if she makes the best choice.
题目输入：
Line 1:Four space-separated integers: n(1=<n<=500,cities are numbered from 0 to n-1)，m，st，ed(0=<st,ed<=n-1)Line 2:n integers a0,a1,……an(0<ai<=10000000) represent the number of friends from city 0 to city n-1next m lines: each line three integers p1,p2,wei(0<wei<=500),represents the ticket money between city p1 and city p2 is weiInput ends with EOF	 
题目输出：
Each case one line:two space-separated integers a,b represent the number of shortest paths from city st to city ed and maximum number of friends she can visit if she chooses one of these paths.If there isn't any path from st to ed,just output 0 0.
输入样例：
5 6 0 2
1 2 1 5 3
0 1 1
0 2 2
0 3 1
1 2 1
2 4 1
3 4 1
输出样例：
2 4
提示：
None



题目：ARectangularBarn(1527)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Ever the capitalist, Farmer John wants to extend his milking business by purchasing more cows. He needs space to build a new barn for the cows. FJ purchased a rectangular field with R (1 ≤ R ≤ 3,000) rows numbered 1..R and C (1 ≤ C ≤ 3,000) columns numbered 1..C. Unfortunately, he realized too late that some 1x1 areas in the field are damaged, so he cannot build the barn on the entire RxC field. FJ has counted P (0 ≤ P ≤ 30,000) damaged 1x1 pieces and has asked for your help to find the biggest rectangular barn (i.e., the largest area) that he can build on his land without building on the damaged pieces.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1: Three space-separated integers: R, C, and P. Lines 2..P+1: Each line contains two space-separated integers, r and c, that give the row and column numbers of a damaged area of the field
题目输出：
Line 1: The largest possible area of the new barn
输入样例：
3 4 2
1 3
2 1
输出样例：
6
提示：
1 2 3 4
 +-+-+-+-+

1| | |X| |

 +-+-+-+-+

2|X|#|#|#|

 +-+-+-+-+

3| |#|#|#|

 +-+-+-+-+

Pieces marked with 'X' are damaged and pieces marked with '#' are part of the new barn.



题目：Cyclicantimonotonicpermutations(1320)
时间限制：15000 ms
空间限制：65535 ms
题目描述：

A permutation is a sequence of integers which contains each 
integer from 1 to n exactly once. In this problem we 
are looking for permutations with special properties: 

  Antimonotonic: for each consecutive 3 values 
  pi-1, pi, 
  pi+1 (1 < i < n), 
  pi should either be the smallest or the biggest of 
  the three values. 
  Cyclic: The permutation should consist of only one cycle, 
  that is, when we use pi as a pointer from 
  i to pi, it should be possible to start 
  at position 1 and follow the pointers and reach all 
  n positions before returning to position 
1.
题目输入：
The input file contains several test cases. Each test case consists of a line containing an integer n, (3 ≤ n ≤ 10^6), the number of integers in the permutation. Input is terminated by n=0. 
题目输出：
For each test case print a permutation of the integers 1 to n which is both antimonotonic and cyclic. In case there are multiple solutions, you may print any one. Separate all integers by whitespace characters. 
输入样例：
3
5
10
0

输出样例：
3 1 2
4 5 2 3 1
6 10 2 9 3 5 4 7 1 8

提示：




题目：Infinitemonkeytheorem(1178)
时间限制：1000 ms
空间限制：32768 ms
题目描述：
	Could you imaging a monkey writing computer programs? Surely monkeys are smart among animals. But their limited intelligence is no match for our human beings. However, there is a theorem about monkeys, and it states that monkeys can write everything if given enough time.The theorem is called “Infinite monkey theorem”. It states that a monkey hitting keys at random on a typewriter keyboard for an infinite amount of time will almost surely type any given text, which of course includes the programs you are about to write (All computer programs can be represented as text, right?).It’s very easy to prove this theorem. A little calculation will show you that if the monkey types for an infinite length of time the probability that the output contains a given text will approach 100%.However, the time used is too long to be physically reasonable. The monkey will not be able to produce any useful programs even if it types until the death of the universe. To verify this and ensure that our human beings are not replaceable by monkeys, you are to calculate the probability that a monkey will get things right.
题目输入：
There will be several test cases.Each test case begins with a line containing two integers n and m separated by a whitespace (2<=n<=26, 1<=m<=1000). n is the number of keys on the typewriter and the monkey will hit these keys m times. Thus the typewriter will finally produce an output of m characters.The following n lines describe keys on the typewriter. Each line has a lower case letter and a real number separated by a whitespace. The letter indicates what the typewriter will produce if the monkey hits that key and the real number indicates the probability that the monkey will hit this key. Two hits of the monkey are independent of each other (Two different hits have the same probability for a same key), and sum of all the probabilities for each key is ensured to be 1.The last line of the test case contains a word composed of lower case letters. The length of the word will be less than or equal to 10.The input will end with a line of two zeros separated by a whitespace. This line should not be processed.
题目输出：
For each test case, output one line containing the probability that the given word will appear in the typewriter’s output. The output should be in percentage format and numbers should be rounded to two digits after the decimal point
输入样例：
4 10
w 0.25
o 0.25
r 0.25
d 0.25
word
2 10
a 1.0
b 0.0
abc
2 100
a 0.312345
b 0.687655
abab
0 0

输出样例：
2.73%
0.00%
98.54%

提示：
The 35th ACM-ICPC Asia Regional Contest (Hangzhou)



题目：小坑坑玩神庙逃亡(1725)
时间限制：1000MS
空间限制：131072KB
题目描述：
	小坑坑觉得玩神庙逃亡太坑了，于是他破解了这个游戏。	众所周知神庙逃亡游戏是这样进行的:	玩家控制一名冒险者从起点开始不断的跑，其过程中不断收集金币和道具。而一旦玩家失误，冒险者就会被尾随其后的怪兽抓住，游戏就结束了。网络传言说神庙逃亡我们的冒险者一直跑下去终究会跑到终点，但是破解了这个游戏的小坑坑发现事实并非如此。	小坑坑对神庙逃亡的各种设定非常不满意，于是他对游戏的模式进行了一些修改：	小坑坑讨厌随机生成的地图，于是他每次用程序生成一张固定的地图，并为地图增加了终点。	由于冒险者一直受到怪物的追赶只能向前走，加之游戏跑重复的路线是非常无趣的，所以可以把地图看做是一张有N个点M条边的向无环图。（N <= 100， M <= 2000）	小坑坑在每个点上和每个边上都放置了一些宝箱，每个宝箱里有一定价值（Wi <= 1500）的宝物，冒险者在进过宝箱所在的点或边时可以选择是否拿走物品。当冒险者到达终点停下时，游戏会记录下这个冒险者所获得的宝物的总价值作为冒险者的分数；若不能到达终点，无论冒险者拿到多少宝物都不计分。	小坑坑觉得自己操作冒险者太坑了，于是他写了AI来进行游戏，久而久之他发现用一个冒险者进行游戏非常无聊，于是他准备让K（<= 15）个冒险者在同一张地图上同时进行游戏。	小坑坑想知道，他的所有冒险者一共最多能得多少分呢？
题目输入：
	题目有多组测试数据。	每组数据第一行有两个整数N，M	第二行有N个整数，Wi表示每个点上的宝箱宝物价值为Wi。	接下来有M行，每行有U,V,W三个整数表示（U,V）边上有宝箱权值为W。	最后一行有三个整数S、T、K，分别代表起点、终点编号和冒险者人数。	输入文件以EOF结尾。	
题目输出：
	对于输入的每组数据，输出Case序数和小坑坑所能得到的最高分数。
输入样例：
4 5 
5 -2 7 9
1 2 9
1 3 5
1 4 -2
2 4 3
3 4 2
1 4 1
输出样例：
Case 1: 28
提示：
None



题目：数木棒(1423)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
假设在一水平线上有N根木棒，木棒高度的取值区间为[1,N]，且这N根木棒的所有取值能构成[1,2,..N]的一个排列。
现在假设你从左边看去能看见X根木棒，从右边看去能看见Y根木棒，举个例子：
比如N=4，假设木棒按照高度的一个排列为  1 4 2 3  ，那么从左看去能看见高度为1 4 的两根木棒，（高度为2，3的看不到，因为其被高度为4的挡住了）。从右看去能看见高度为3 4的两根木棒(高度为2的木棒看不到，因为其被高度为3的木棒挡住了，同理高度1的被高度4的木棒挡住了)。所以在这种情况下： 
X=2,Y=2。
当然这只是满足条件的一个排列，也可能还存在其他满足条件的高度排列。
现在你的任务是：给定如上所述的N,X,Y。求满足条件的排列的方案数。结果可能会很大，所以只需要输出对1000000007取模的值即可。
题目输入：
第一行输入一个数T，代表下面共有T组测试数据。（T<=100000）
针对每组测试数据：首先输入三个数 N  M  P （1<=N<=100,1<=M,P<=1000000000）
X=SOLVE(M)%N+1
Y=SOLVE(P)%N+1  (%为取模运算符)，其中SOLVE函数的定义如下：
int SOLVE(int m)
{
     if(m==1)
                  return 0;
     if(m%2==0)
          return SOLVE(m/2)+1;
     else
          return SOLVE(3*m+1)+1;
}

题目输出：
针对每组测试数据，输出相应的答案。
输入样例：
2
1 2 2
1 1 1

输出样例：
1
1

提示：




题目：拼图(1842)
时间限制：3.0s
空间限制：256.0MB
题目描述：
　　给出一个n×m的方格图，现在要用如下L型的积木拼到这个图中，使得方格图正好被拼满，请问总共有多少种拼法。其中，方格图的每一个方格正好能放积木中的一块。积木可以任意旋转。
 

题目输入：
　　输入的第一行包含两个整数n, m，表示方格图的大小。评测用例规模与约定
　　在评测时将使用10个评测用例对你的程序进行评测。
　　评测用例1和2满足：1<=n<=30，m=2。
　　评测用例3和4满足：1<=n, m<=6。
　　评测用例5满足：1<=n<=100，1<=m<=6。
　　评测用例6和7满足：1<=n<=1000，1<=m<=6。
　　评测用例8、9和10满足：1<=n<=10^15，1<=m<=7。
题目输出：
　　输出一行，表示可以放的方案数，由于方案数可能很多，所以请输出方案数除以1,000,000,007的余数。
输入样例：
6 2
输出样例：
4
提示：
　　四种拼法如下图所示：



题目：CowXOR(1528)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
Farmer John is stuck with another problem while feeding his cows. All of his N (1 ≤ N ≤ 100,000) cows (numbered 1..N) are lined up in front of the barn, sorted by their rank in their social hierarchy. Cow #1 has the highest rank; cow #N has the least rank. Every cow had additionally been assigned a non-unique integer number in the range 0..(2^21 - 1). Help FJ choose which cows will be fed first by selecting a sequence of consecutive cows in the line such that the bitwise "xor" between their assigned numbers has the maximum value. If there are several such sequences, choose the sequence for which its last cow has the highest rank. If there still is a tie, choose the shortest sequence.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1: A single integer N Lines 2..N+1: N integers ranging from 0 to 2^21 - 1, representing the cows' assigned numbers. Line j describes cow of social hierarchy j-1.
题目输出：
Line 1: Three space-separated integers, respectively: the maximum requested value, the position where the sequence begins, the position where the sequence ends.
输入样例：
5
1
0
5
4
2
输出样例：
6 4 5
提示：
There are 5 cows. Cow #1 had been assigned with 1; cow #2 with 0; cow #3 with 5; cow #4 with 4; cow #5 with 2. 
4 xor 2 = 6 (001) xor (010) = (011)



题目：MusicCouple(1626)
时间限制：1000 ms
空间限制：30000 ms
题目描述：
Here are two equal-length integer arrays,each integer represents a tone,some music section(that is to say,a integer sequence such as a[i],a[i+1],a[i+2]……a[j] in the first array)in the first array may appear in the second array after increasing or decreasing a tone(in the second array they are b[p],b[p+1],b[p+2]……b[q],their values are a[i]+d,a[i+1]+d,a[i+2]+d,……a[j]+d,here d is an integer, d may be negative or positive or zero).We call these two sections Music Couples.Now you are expected to calculate the length of the longest Music Couples. If there are several longest Music Couples ,we expect the index i(the starting index in the first array) can be as small as possible,if several Music Couples's starting index in the first array—i ,equal to each other,we expect the starting index in the second array—p can be as small as possible.
题目输入：
line 1:one integer represents the length of array (1=<n<=20000)line 2:n space-seperated integers a[0],a[1]……a[n-1],represent the first array.(-127<=a[i]<=127)line 3:n space-seperated integers b[0],b[1]……b[n-1],represent the second array. (-127<=b[i]<=127)input ends with EOF
题目输出：
line 1:the length of the longest Music Coupleline 2:the first array's section of the Music Couple we expected as above in the first array,that is,a[i],a[i+1],a[i+2]……a[j].line 3:the second array's section of the Music Couple we expected as above in the first array,that is,b[p],b[p+1],b[p+2]……b[q].
输入样例：
10
2 2 3 4 5 6 7 8 9 10
0 1 3 4 7 1 2 3 9 9
输出样例：
3
2 3 4
1 2 3
提示：
None



题目：圆面积(1078)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
你的任务是编写一个程序。给你两个圆，计算出它们的公共面积，保留小数点后三位有效数字。 
 
题目输入：
在输入文件中每一行有实数x1,y1,r1,x2,y2,r2,之间用空格隔开。它们分别表示两圆的圆心和半径。
题目输出：
每个输出中必须包含一个实数，保留三位小数。
输入样例：
20.0 30.0 15.0 40.0 30.0 30.0
1.0 1.0 1.0 10.0 10.0 1.0

输出样例：
608.366
0.000

提示：




题目：Darkroads(1321)
时间限制：10000 ms
空间限制：65535 ms
题目描述：

Economic times these days are tough, even in Byteland. To reduce the 
operating costs, the government of Byteland has decided to optimize the road 
lighting. Till now every road was illuminated all night long, which costs 1 
Bytelandian Dollar per meter and day. To save money, they decided to no longer 
illuminate every road, but to switch off the road lighting of some streets. To 
make sure that the inhabitants of Byteland still feel safe, they want to 
optimize the lighting in such a way, that after darkening some streets at night, 
there will still be at least one illuminated path from every junction in 
Byteland to every other junction. 
What is the maximum daily amount of money the government of Byteland can 
save, without making their inhabitants feel unsafe? 
题目输入：
The input file contains several test cases. Each test case starts with two numbers m and n, the number of junctions in Byteland and the number of roads in Byteland, respectively. Input is terminated by m=n=0. Otherwise, 1 ≤ m ≤ 200000 and m-1 ≤ n ≤ 200000. Then follow n integer triples x, y, z specifying that there will be a bidirectional road between x and y with length z meters (0 ≤ x, y < m and x ≠ y). The graph specified by each test case is connected. The total length of all roads in each test case is less than 2^31. 
题目输出：
For each test case print one line containing the maximum daily amount the government can save. 
输入样例：
7 11
0 1 7
0 3 5
1 2 8
1 3 9
1 4 7
2 4 5
3 4 15
3 5 6
4 5 8
4 6 9
5 6 11
0 0
输出样例：
51
提示：




题目：ToBeanDreamArchitect(1179)
时间限制：3000 ms
空间限制：32768 ms
题目描述：
The “dream architect” is the key role in a team of “dream extractors” who enter other’s dreams to steal secrets. A dream architect is responsible for crafting the virtual world that the team and the target will dream into. To avoid the target noticing the world is artificial, a dream architect must have powerful 3D imagination.Cobb uses a simple 3D imagination game to test whether a candidate has the potential to be an dream architect. He lets the candidate imagine a cube consisting of n×n×n blocks in a 3D coordinate system as Figure 1. The block at bottom left front corner is marked (1, 1, 1) and the diagonally opposite block is marked (n, n, n). Then he tells the candidate that the blocks on a certain line are eliminated. The line is always parallel to an axis. After m such block eliminations, the candidate is asked to tell how many blocks are eliminated. Note that one block can only be eliminated once even if it is on multiple lines.Here is a sample graph according to the first test case in the sample input:
题目输入：
The first line is the number of test cases.
In each test case, the first line contains two integers n and m( 1 <= n <= 1000, 0 <= m <= 1000).，meaning that the cube is n x n x n and there are m eliminations.

Each of the following m lines represents an elimination in the following format:
axis_1=a, axis_2=b
where axis_i (i=1, 2) is ‘X’ or ‘Y’, or ‘Z’ and axis_1 is not equal to axis_2. a and b are 32-bit signed integers.


题目输出：
For each test case output the number of eliminated blocks.

输入样例：
2
3 2
Y=1,Z=3
X=3,Y=1
10 2
X=3,Y=3
Y=3,Z=3
输出样例：
5
19
提示：




题目：小坑坑做Codeforces(1726)
时间限制：4000MS
空间限制：131072KB
题目描述：
	小坑坑很喜欢玩CF---Codeforces，所以对CF上那些很牛逼的ID自然很熟悉，比如 tourist , petr，rng_58等等。一天，他想到了一个很有意思的问题，那就是对于给定的一些ID。如果前一个ID的最后那个字母跟后一个ID的第一个字母相同，那么就可以把这两个ID用一个'-'连起来。	例如：petr-rng_58	小坑坑想知道是不是对于所有给定的ID都可以连起来。为了简单，小坑坑选的那些ID都只包含小写字母，且不超过20个字母。小坑坑又发现，这样的连接可能不止一种，比如 petr 与reeep既可以连成petr-reeep也可以连成 reeep-petr。这个时候小坑坑注意到了rating这个东西。	于是他定义了一个score。假如有N个id从前往后连续输出，他们的rating分别为r1,r2,r3..rN。那么score = （r1^N + r2^(N- 1) +... rN），现在假如有多组连接方式，小坑坑希望输出的是score最大的那一种。比如petr的rating 是2828，reeep的rating是2020。那么我们的连接方式就是petr-reeep。小坑坑想知道怎么实现这个问题。于是他向你请教。
题目输入：
	第一行一个1 <= N <= 100000,表示有多少个ID。然后接下来N行每行包括一个ID及一个rating。ID只由小写字母组成，并且不大于20个字母，rating为<=300000的整数(每个人的rating都不相同)。
题目输出：
	如果可以按照上述的方式把这些ID连接起来。就输出这种连接方式。否则输出"I can't solve the problem!”
输入样例：
3
tourist 3000
teakt 1700
teas 2000
4
petr 2828
egor 2300
reset 1530
yeputons 2540
6
alolha 1530
ararchnid 2790
dog 1500
raaat 2000
gopher 1700
tiger 1400
输出样例：
tourist-teakt-teas
I can't solve the problem!
alolha-ararchnid-dog-gopher-raaat-tiger
提示：
None



题目：数字根(1424)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
话说我们定义一个数的“数字根”R(n)，表示将该数所有位数反复求和，直到剩下小于10的数，例如R(29876)=R(32)=R(5)。
现在输入一个数n，求F(n)的数字根，其中F(n)定义如下
F(n)=0                      n=0
F(n)=1                      n=1
F(n)=F(n-1)+F(n-2)            n>1
题目输入：
第一行输入T<10000，表示case数。每个case输入一个数n，0<=n<=10^18。
题目输出：
输出一个数，表示R(F(n))
输入样例：
2
1
10

输出样例：
1
1

提示：




题目：NameafterFish(1627)
时间限制：2000 ms
空间限制：65536 ms
题目描述：
	As we all know,Fish is a long-standing word,so many people name after it,such as Fishhead.	Now he wants to give all his things a name whose length is n using the four letter,that is 'F'、'i'、's'、'h'。	His mode of thought is very strange，if the inversion number of any four-length substring is not equal to a variable m，he can remember this name.The name cann't be remembered is invalid.Now he wants to know how many names can be structured(MOD 100000),this is your task.	
题目输入：
	Line 1:Two space-separated integers: m(0=<m<=6),n(1=<n<=2000000000)，representing the inversion number and the names's length.	Input ends with EOF.	
题目输出：
	Line 1:A integer represents the valid number can be structed(mod 100000).	
输入样例：
6 4
输出样例：
255
提示：
None



题目：Eliasgammacoding(1322)
时间限制：1000 ms
空间限制：65535 ms
题目描述：

The Elias gamma code is a simple code which can be used to encode a sequence 
of positive integers. We will use a modified code which is also able to encode 
zeros. To encode an integer n, do the following: 

  Let k be the number of bits of n 
  Write k-1 zeros followed by a 1 
  Write n in binary

  
  
    Examples
  
    Number
    Binary
    Number of bits
    Prefix
    Code
  
    0
    0
    1
    1
    10
  
    1
    1
    1
    1
    11
  
    2
    10
    2
    01
    0110
  
    3
    11
    2
    01
    0111
  
    4
    100
    3
    001
    001100
  
    5
    101
    3
    001
    001101
  
    6
    110
    3
    001
    001110
  
    7
    111
    3
    001
    001111
  
    8
    1000
    4
    0001
    00011000
A sequence of integers is encoded by writing the codes of the individual 
integers of the sequence in the same order as the integers appear in the 
sequence. The prefix of k additional bits before the binary 
representation of each integer is needed to be able to decode the encoded 
integers. So when reading the encoding of a sequence of integers, if we read 
k-1 zeros followed by a one, it means that there are 
k bits following which are the binary representation of the next 
encoded integer. 
If we want to shorten the length of the encoding of a sequence of integers, 
there may be still some room for improvement; we will consider the following two 
optimizations: 

  If there is a prefix which indicates that k bits are 
  following, but there is no integer in the sequence with k bits, 
  we can use this prefix to indicate that k+1 bits are following. 
  If there already was a prefix which indicates that k+1 bits are 
  following, this prefix is not needed anymore, and it can be used to indicate 
  that k+2 bits are following, and so on. 
  We can add a leading zero to the binary representation of all integers in 
  the sequence with k bits, which then become integers with 
  k+1 bits, and then the first optimization can be used. This 
  optimization seems especially useful if there are few integers with 
  k bits, but many integers with more than k bits. 
  
When we are minimizing the length of the encoding of a sequence of integers, 
we only care about how many integers in the sequence have a certain number of 
bits. Let ci denote the number of integers in a 
sequence with i bits. 
Let us look at the following example: c1 = 2, c2 
= 4, c3 = 0, c4 = 1 (which, for example, could 
correspond to a sequence 2, 1, 3, 8, 0, 2, 3). With the original 
elias gamma coding, the encoding of the sequence would have length 2 × (1 
+ 1) + 4 × (2 + 2) + 0 × (3 + 3) + 1 × (4 + 4) = 28. By using 
optimization 1 we can save 1 bit by using prefix 001 for the 
integer with 4 bits. Then, we could use optimization 2 and add leading zeros to 
the integers with 1 bit, making them use 2 bits. Then, we use optimization 1 and 
use prefix 1 for the integers with 2 bits, prefix 01 
for the integer with 4 bits, and we get the new length of 6 × (1 + 2) + 1 
× (2 + 4) = 24. 
Both optimizations can possibly be used several times. Note that for the 
second optimization, it is not easy to decide when and how to use it. The goal 
is to combine these two optimizations in the best possible way, that means we 
want to find an encoding of a given sequence of integers that has minimum length 
among all encodings using elias gamma coding with any combination of these two 
optimizations. 
题目输入：
The input file contains several test cases. Each test case starts with a line containing an integer n, (1 ≤ n ≤ 128). The next line contains the values c1, ..., cn (0 ≤ ci ≤ 10000). Input is terminated by n=0. 
题目输出：
For each test case print one line with the minimum length of an encoding of the given input sequence. 
输入样例：
4
2 4 0 1
5
9 4 2 4 3
11
44 56 96 26 73 80 77 50 33 16 78
0
输出样例：
24
99
5494
提示：
The first sample test case corresponds to the example given in the problem description.



题目：屠夫神钩(1079)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
messIDou很爱玩DOTA，尤其是屠夫，屠夫有一技能名为肉钩，钩子从屠夫这里沿着直线发出，在距离内如果碰到其他人，则钩中，且只能钩中第一个碰到的。messIDou每次玩这个英雄都很头疼，总是百钩不中。于是找到Food92，请教学习，虽然有所长进，但也还是很差，他能钩中目标吗？注意每个人都可以认为是一个圆面，只要碰到圆上或者圆内的任何一个位置，都算被钩中。
题目输入：
第一行输入整数t，表示有t个case( 0 < t < 100 )
每个case第一行输入整数n，表示有n个人，第二行输入屠夫的位置和能够钩中的距离，第三行输入钩子运动的方向向量，下面n行输入n(编号分别是1~n，0 < n < 10)个人的中心位置x，y，及其半径r。n个人所在的圆都不会相交，屠夫也不会在n个人的圆内。第一个人为屠夫的目标。(-100 < x,y < 100  0 < r <= 10)(所有人的位置坐标都为实数)

题目输出：
每个Case对应一行，如果messIDou能够钩中目标，则输出YES，否则输出MISS
输入样例：
2
2
0 0  3
0 1
0 4 2
5 0 1
2
0 0  1
0 1
0 4 2
5 0 1

输出样例：
YES
MISS

提示：




题目：地精工程师(1529)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
地精工程师 （goblin tech ）dota的一名智力型英雄，位于黎明酒馆。第三技能自杀攻击 (Suicide Squad Attack) [C]介绍：牺牲小我而成全大我，对一定范围内的非远古单位造成巨大的伤害。距离爆心较远的单位，受到的伤害也较少。　　伤害无视魔法免疫　　第一级 - 对200/500范围内的目标造成650/350点的伤害。　　第二级 - 对200/500范围内的目标造成850/400点的伤害。　　第三级 - 对200/500范围内的目标造成1150/450点的伤害。　　第四级 - 对200/500范围内的目标造成1550/500点的伤害。我们假定，我们现在要操控的地精工程师的自杀技能，对x1/x2范围内的目标造成y1/y2点的伤害。现在两方抱团正在展开激烈的击杀，已知地图上5名敌方英雄的位置和血量。地精工程师该选择哪点自杀，对敌方5名英雄的伤害总和最大，输出伤害最大值。

题目输入：
第一行：case数（<=1000）
 
 对于每一个case：
 第一行：x1 x2 y1 y2（绝对值<=1000）
 接下来5行，每一行：xi yi bi，（xi,yi）英雄位置，bi英雄血量。
 
题目输出：
每一个case输出一个整数。
输入样例：
1
60 80 300 200
0 0 1000
100 0 1000
0 100 1000
100 100 1000
-100 0 1000
输出样例：
800
提示：




题目：门禁系统(1843)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　涛涛最近要负责图书馆的管理工作，需要记录下每天读者的到访情况。每位读者有一个编号，每条记录用读者的编号来表示。给出读者的来访记录，请问每一条记录中的读者是第几次出现。

题目输入：
　　输入的第一行包含一个整数n，表示涛涛的记录条数。
　　第二行包含n个整数，依次表示涛涛的记录中每位读者的编号。评测用例规模与约定
　　1≤n≤1,000，读者的编号为不超过n的正整数。
题目输出：
　　输出一行，包含n个整数，由空格分隔，依次表示每条记录中的读者编号是第几次出现。
样例输入
输入样例：
5
1 2 1 1 3
输出样例：
1 1 2 3 1
提示：
None



题目：NationalDayParade(1180)
时间限制：1000 ms
空间限制：32768 ms
题目描述：
There are n×n students preparing for the National Day parade on the playground. The playground can be considered as a n×m grid. The coordinate of the west north corner is (1,1) , and the coordinate of the east south corner is (n,m).When training, every students must stand on a line intersection and all students must form a n×n square. The figure above shows a 3×8 playground with 9 students training on it. The thick black dots stand for the students. You can see that 9 students form a 3×3 square.After training, the students will get a time to relax and move away as they like. To make it easy for their masters to control the training, the students are only allowed to move in the east-west direction. When the next training begins, the master would gather them to form a n×n square again, and the position of the square doesn’t matter. Of course, no student is allowed to stand outside the playground.You are given the coordinates of each student when they are having a rest. Your task is to figure out the minimum sum of distance that all students should move to form a n×n square.
题目输入：
There are at most 100 test cases. 
For each test case: 
The first line of one test case contain two integers n,m. (n<=56,m<=200)
Then there are n×n lines. Each line contains two integers, 1<=Xi<=n,1<= Yi<=m indicating that the coordinate of the ith student is (Xi , Yi ). It is possible for more than one student to stand at the same grid point.

The input is ended with 0 0.


题目输出：
You should output one line for each test case. The line contains one integer indicating the minimum sum of distance that all students should move to form a n×n square.

输入样例：
2 168
2 101
1 127
1 105
2 90
0 0
输出样例：
41
提示：




题目：数字和(1425)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
输入A，B，S，求出区间[A,B]间有多少数满足各位数字之和等于S。
题目输入：
第一个数为T，表示case数，之后每个case输入A,B<10^15,S<=135
题目输出：
输出一个数，表示间[A,B]间有多少数满足各位数字之和等于S
输入样例：
2
1 9 5
1 100 10

输出样例：
1
9

提示：




题目：小坑坑贴广告(1727)
时间限制：1000MS
空间限制：131072KB
题目描述：
	小坑坑觉得贴广告太坑了，于是想要解决这个问题。	AD科技有N个连锁商店，现在GIN想通过在已有的M条道路之间选择一些路，在路上布置一些广告。这些路选择完后，任意两两分店之间均相通。在特定的分店i到分店j的路上放置广告需要c(i, j)的花费。要求布置的方案使得花费最小，现在GIN想知道是不是只有一种方案（若两个方案中有一条路的选择不相同，则视为不同的方案）？
题目输入：
	有多组测试数据，每组数据的第一行N（2 <= N <= 100），M(1 <= M <= 1000)。	接下来M行，以(i, j, c(i, j))的方式给出边，含义为题中所述。	并且每两个分店之间，最多只有一条路。	
题目输出：
	每组数据输出一行，"Yes"代表只有一种，"No"代表有多种方案。
输入样例：
4 4
1 2 2
2 3 2
3 4 2
4 1 2
输出样例：
No
提示：
None



题目：Searchingbox(1628)
时间限制：1000 ms
空间限制：65536 ms
题目描述：
	Zlly has been annoyed with Engish words for a long time even though he conquered it finally.These days he is devoting himself to Engish words searching box,he wants to make it convenient for searching Engish words.	Here is the rules:	There is a words library containing n words ,each word's length is no more than 20.	Here are m queries among the library ,each query is a string,he wants to output the first 8(if there are so many) words by increasing lexicographic whose prefixes match the given string.	if no words can be matched,just output the query string.	If there are not so many(eight) words in the library, just output all matched words.	All the words in the library and the query string are constructed by Lower case letters.Now he is so busy because something you don't know ,can you help him?	
题目输入：
	Line 1:One integer: n(n<=10000) represents the number of words in the library.	Next n lines :one string represents one word in the library.	Line n+2 :One integer: m (m<=10000) represents and the number of queries.	Next m lines :one string represents one query.	
题目输出：
	for each query,output one line ,the result of the query by increasing lexicographic,separate two words with a space.	if at least one word can match the query string, there is a space after the last word,else there isn't any space after the query string.
输入样例：
24
apple
banana
p
pa
peach
peach
orange
grape
pear
kiwi
papaya
mangoes
pineapple
watermelon
plum
strawberry
cherry
lemon
blueberry
litchi
persimmon
manggo
pawpaw
pomelo
10
p
pe
pa
pi
pl
o
u
ma
l
b
输出样例：
p pa papaya pawpaw peach peach pear persimmon 
peach peach pear persimmon 
pa papaya pawpaw 
pineapple 
plum 
orange 
u
manggo mangoes 
lemon litchi 
banana blueberry 
提示：
None



题目：Foodportionsize(1323)
时间限制：1000 ms
空间限制：65535 ms
题目描述：

The university canteen does not want any student to leave the canteen hungry. 
Therefore, as long as a student is hungry, he can get another portion of food 
for free. The canteen uses a fixed food portion size, because it would take too 
much time to first ask a student how much food he wanted. It can happen that a 
student doesn't finish his last portion of food and the remainder has to be 
thrown away. 
To minimize costs, the manager of the canteen wants to determine a food 
portion size S such that the amount of food that is wasted is 
small, but also the number of times the students have to fetch another portion 
of food is not too big. Note that these two goals can be conflicting: 

  By choosing a very small food portion size, one does not waste food, but 
  simultaneously the number of times the students have to fetch food is big. 
  By choosing a large food portion size, one can make sure each student has 
  to fetch only one portion, but at the same time it may happen that a large 
  quantity of food is wasted. 
The manager of the canteen has collected data about how many units of food 
each student eats. The problem to be solved can now be formulated mathematically 
as follows: Let x be the amount of food that is wasted, and 
y the number of times the students go to fetch food. Then, the 
goal is to minimize a × x + b × y, where a, b are 
weights that represent the relative importance of the two opposing goals. Note 
that x and y depend on the food portion size 
S and the quantities of food each student eats. We impose the 
additional constraint that no student should have to go more than 3 times to 
fetch food. 
题目输入：
The input file contains several test cases. Each test case starts with a line containing an integer n, (1 ≤ n ≤ 1000), the number of students eating in the canteen. The next line contains the values a and b (1 ≤ a, b ≤ 10). The third line of each test case consists of n integers y1, ..., yn (1 ≤ yi ≤ 100), where yi is the amount of food student i eats. Input is terminated by n=0. 
题目输出：
For each test case print one line containing the costs resulting from an optimal choice of the food portion size. Print each value as a reduced fraction. If the result is an integer, do not print the denominator 1. See the sample output for details. 
输入样例：
5
1 1
3 7 1 9 12
3
10 1
11 13 17
2
2 3
6 3
0
输出样例：
35 / 2
154 / 3
9
提示：
In the first sample input, the optimal food portion size is 4.5. Note that a food portion size of 3 would yield a smaller cost of 16, the 5th student, however, would have to fetch food 4 times.



题目：三角形(1080)
时间限制：1000 ms
空间限制：65535 kb
题目描述：
给你三角形的三边，判断是否为直角三角形。
题目输入：
第一行输入测试个数t。t<=100以下t行每行输入三个整数a，b，c
题目输出：
如果是直角三角形，输出Y，否则输出N
输入样例：
2
3  4  5
6  8  9
输出样例：
Y
N
提示：
None



题目：巨魔战将(1530)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
在近卫军团第一次集结时，那些巨魔战士们曾经是被大家认为是不开化并且很不可靠的。他们的自尊心因此受到伤害，很多人拒绝加入，有些甚至考虑加入天灾军团。只有一个叫做Jak`Rakal的年轻热血的巨魔战将加入了近卫军团。他之所以被巨魔们称做“眩目之斧”，是因为他挥舞斧头的速度令人眩目，并且具有让敌人失明的招牌技能。他那不可阻挡的狂暴力量早已在他的盟友中成为一个传说。但是，Jah`Rakal不是为了近卫军团而战斗，甚至不是为了守护世界之树，而仅仅是为了向精灵，人类，兽族以及其他一切种族证明，巨魔一族才是世界上最强的战士。

旋风飞斧 (E)巨魔战将是战斧大师，能在各种形态下运用战斧技能。当处于近程形态，能召唤魔法飞斧环绕自身，对周围的敌人造成伤害并致盲（60%概率攻击落空）；当处于远程形态，能对前方锥形区域投出大把飞斧，降低被命中敌人30%的移动速度并造成75点伤害。作用范围：450（近战形态）/900（远程形态） 冷却时间：12秒（近战形态）/20秒（远程形态） 魔法消耗：50等级1：近战形态造成125点伤害和4秒致盲效果；远程形态的减速效果持续3秒。等级2：近战形态造成175点伤害和5秒致盲效果；远程形态的减速效果持续3.75秒等级3：近战形态造成225点伤害和6秒致盲效果；远程形态的减速效果持续4.5秒等级4：近战形态造成275点伤害和7秒致盲效果；远程形态的减速效果持续5.25秒
如果巨魔战将要用远程形态下的飞斧，对前方锥形区域投出大把飞斧，我们假定是无作用范围，如果知道每个英雄的位置，和该锥形的张角，巨魔战将该以怎样的角度投出飞斧，使得被伤害到的英雄数量最多，输出最大数量。
题目输入：
第一行：Case数<=1000
 
 对于每一个case：
 第一行是：x y a。（(x,y)为巨魔战将的位置，a为锥形区域的张角（弧度））
 第二行N代表敌方英雄数量。 N<=1000
 接下来N行，每一行为第i个英雄的位置。
 
题目输出：
对于每个case输出最大英雄数量。
输入样例：
2
0 0 0.786
3
0 1
1 1
1 0
0 0 0.785
3
0 1
1 1
1 0
输出样例：
2
1
提示：




题目：Z字形扫描(1844)
时间限制：2.0s
空间限制：256.0MB
题目描述：
　　在图像编码的算法中，需要将一个给定的方形矩阵进行Z字形扫描(Zigzag Scan)。给定一个n×n的矩阵，Z字形扫描的过程如下图所示：
 　　对于下面的4×4的矩阵，
　　1 5 3 9
　　3 7 5 6
　　9 4 6 4
　　7 3 1 3
　　对其进行Z字形扫描后得到长度为16的序列：
　　1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3
　　请实现一个Z字形扫描的程序，给定一个n×n的矩阵，输出对这个矩阵进行Z字形扫描的结果。

题目输入：
　　输入的第一行包含一个整数n，表示矩阵的大小。
　　输入的第二行到第n+1行每行包含n个正整数，由空格分隔，表示给定的矩阵。评测用例规模与约定
　　1≤n≤500，矩阵元素为不超过1000的正整数。
题目输出：
　　输出一行，包含n×n个整数，由空格分隔，表示输入的矩阵经过Z字形扫描后的结果。
输入样例：
4
1 5 3 9
3 7 5 6
9 4 6 4
7 3 1 3
输出样例：
1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3
提示：
None



题目：Army(1181)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
			The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.				One needs exactly di years to rise from rank i to rank i + 1. Reaching a certain rank i having not reached all the previous i - 1 ranks is impossible.				Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.	
题目输入：
The first input line contains an integer n (2  ≤  n  ≤  100). The second line contains n - 1 integers di (1  ≤  di  ≤  100). The third input line contains two integers a and b (1  ≤  a  <  b  ≤  n). The numbers on the lines are space-separated.Process to end of file.
题目输出：
Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.
输入样例：
3
5 6
1 2
3
5 6
1 3

输出样例：
5
11

提示：
None



题目：调整排列(1426)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
给你一个正整数N,再给你两个N的全排列，现在你的任务是用最少的步骤把一个全排列调整为另一个全排列。调整的时候，可以把一个元素移动到该排列的任何一个位置。
比如N=4,下面给出两个N的全排列。1 2 3 4和 1 2 4 3，可以把第一个排列中的4移动到3前面，这样就变成了1 2 4 3和第二个排列一样了，那么答案就是1。
题目输入：
第一行包含一个数T(1<=T<=20)，代表下面共有T组测试数据。
针对每组测试数据：
第一部分输入一个数N，代表序列长度。（1<=N<=100000）
第二部分两行，分别为N的两个全排列。

题目输出：
针对每组测试数据，输出最少的移动步骤。
输入样例：
1
4
1 2 3 4
1 2 4 3

输出样例：
1
提示：




题目：小坑坑数鸡兔(1728)
时间限制：1000MS
空间限制：131072KB
题目描述：
	小坑坑觉得数鸡兔太坑了，然后破解了这个问题。	鸡兔同笼的问题是这样子的: 告诉你有多少个头，多少的腿，我就能解决出鸡和兔子分别的个数。	现在我们有一种新的方式，我们就数脚的个数。这些鸡和兔子都是受过训练的，一开始，所有的动物都是所有的脚都站在地上的，小坑坑每叫一声，所有的动物都会收一只脚，当然，如果没脚了，这只动物只能跪了，例如一开始鸡有2只，兔子有3只，然后小坑坑一共叫3次，那么一开始有16个脚，叫1次变成了11个脚，叫第2次变成了6个脚，然后鸡此时脚都收了，所以就跪了，叫第3次变成了3个脚。	现在小坑坑有很多种动物，这些动物都比较奇怪，我们暂且认为只是在做这个题目，不过这些动物里，每种动物的脚的数目都和其他类型动物不同，所以脚的数目一样的动物，它们必定是同类的，这些动物也都是训练有素的，现在小坑坑知道每种动物都有多少个。	小坑坑知道他一共养了n种动物，打算一共叫m次，就一共能够记录m+1次脚的数目，请问小坑坑能否仅根据这些条件知道每种动物的确切数目呢？
题目输入：
	第一行输入一个整数T(1 <= T <= 100)，代表Case个数。	每个Case输入有两行。	第一行两个整数n(1 <= n <= 1000)和m(1 <= m <= 1000)，表示有n种动物，一共会叫m次。	第二行输入m+1个整数ai(0 <= ai <= 10^4)，其中0<=i<=m，表示在叫第i次当前脚的数目，当i=0的时候就是一次都没叫的初始状态。
题目输出：
	对于每个Case，第一行输出"Case D:"，其中D是当前case数，见样例。	第二行输出"No Solution"，"Unique Solution"或者"Multiple Solutions"。	如果答案不存在，输出的是"No Solution"；如果答案被唯一确定，输出的是"Unique Solution"；如果答案有多解，输出的是"Multiple Solutions"。	如果答案被唯一确定，那么再输出n行，每行以"x y"这样的形式，表示有x个脚的动物一共有y支。
输入样例：
3
2 3
14 9 6 3
2 2
8 5 3
3 2
20 13 8
输出样例：
Case 1:
Unique Solution
1 2
4 3
Case 2:
No Solution
Case 3:
Multiple Solutions
提示：
小坑坑比较坑，所以有时会统计出错，或者考虑不够完善，因此会出现无解和多解的情况，当然这条提示对解决这个题目完全没有用。



题目：LuckyGuy(1629)
时间限制：1000 ms
空间限制：32768 ms
题目描述：
	Newfarking thinks he is a lucky guy because he has m lucky strings.Some day he is so bored,he wants to construct strings whose length is n.	He is lucky guy so he wants to guarantee each word contains at least k lucky string.Now he wants to know how many string he can construct only use the lower case letter.	He is lucky,so he needn't to calculate himself.Problem is his,as to answer,it's your turn.All the lucky stirngs only contain lower case letters too.The answers are expected to mod 8065501。	
题目输入：
	Line 1：Three space-separated integers:n(1<=n<=25),m(0<=m<=10),k represents the length of string to be constructed,the number of lucky strings,the least number of lucky strings should be contained.	The length of eacn string is no more than 10.	Input ends with EOF.	
题目输出：
	Output the number of strings can be constructed(mod 8065501).	
输入样例：
8 2 2
work
life
4 1 1
icpc
15 5 2
work
life
study
dota
tourist
输出样例：
2
1
7410737

提示：
None



题目：Generaterandomnumbers(1324)
时间限制：5000 ms
空间限制：65535 ms
题目描述：

John von Neumann suggested in 1946 a method to create a sequence of 
pseudo-random numbers. His idea is known as the "middle-square"-method and works 
as follows: We choose an initial value a0, which has a 
decimal representation of length at most n. We then multiply the 
value a0 by itself, add leading zeros until we get a 
decimal representation of length 2 × n and take the middle 
n digits to form ai. This process is 
repeated for each ai with i>0. In this 
problem we use n = 4. 
Example 1: a0=5555, 
a02=30858025, 
a1=8580,... 
Example 2: a0=1111, 
a02=01234321, 
a1=2343,... 
Unfortunately, this random number generator is not very good. When started 
with an initial value it does not produce all other numbers with the same number 
of digits. 
Your task is to check for a given initial value a0 
how many different numbers are produced. 
题目输入：
The input contains several test cases. Each test case consists of one line containing a0 (0 < a0 < 10000). Numbers are possibly padded with leading zeros such that each number consists of exactly 4 digits. The input is terminated with a line containing the value 0. 
题目输出：
For each test case, print a line containing the number of different values ai produced by this random number generator when started with the given value a0. Note that a0 should also be counted. 
输入样例：
5555
0815
6239
0

输出样例：
32
17
111

提示：
Note that the third test case has the maximum number of different values among all possible inputs.



题目：Pear(1081)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
给出三个点，求所能确定的外接圆的圆心和半径


题目输入：
第一行输入测试个数n
接下来n行每行输入三个点p1,p2,p3 ,分别表示为坐标p1.x,p1.y,p2.x,p2.y,p3.x,p3.y

题目输出：
如果三点共线，输出“no such a circle”；反之，输出圆心坐标和半径（保留两位小数）（数与数之间用一个空格分开，如下的测试用例）



控制两位小数输出的方法：
(c++)
#include < iomanip >（注意去掉空格！）
double d;
cout << setiosflags(ios::fixed) << setprecision(2) << d << endl;
或 printf("%.2lf\n",d);
输入样例：
2
0 0 1 0 0 1
0 0 1 1 2 2

输出样例：
0.50 0.50 0.71
no such a circle

提示：
控制两位小数输出的方法：
(c++)
double d;
cout<
            



题目：DOTA森林(1531)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
我们看到dota游戏地图中以树为主，各处长满了密密麻麻的树，我们以河道中心为整个地图的中心点（0,0），将所有的树都包含起来，包成B个独立的凸多边形。每个凸多边形：（1） 包含中心点（2） 至少包含有三个点（3） 互相之间除中心点之外无其他交叉处！求出以合适的方法使得B个凸多边形面积总和最小，输出最小的面积。	
题目输入：
第一行为Case数。对于每个case，第一行：B，N。N为树的个数，(2 <= B <= 50 且 2B+1 <= N <= 101)。接下来N行：X Y 树的坐标。保证：（1）没有重合的点（2）没有三点共线
题目输出：
一个实数，精确到小数点后两位。
输入样例：
2
2 4
9 4
-8 8
-10 -2
4 -8

2 5
3 6
-5 7
-4 -6
10 -10
3 5
输出样例：
92.00
74.00
提示：
None



题目：集合竞价(1845)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　某股票交易所请你编写一个程序，根据开盘前客户提交的订单来确定某特定股票的开盘价和开盘成交量。
　　该程序的输入由很多行构成，每一行为一条记录，记录可能有以下几种：
　　1. buy p s 表示一个购买股票的买单，每手出价为p，购买股数为s。
　　2. sell p s 表示一个出售股票的卖单，每手出价为p，出售股数为s。
　　3. cancel i表示撤销第i行的记录。
　　如果开盘价为p0，则系统可以将所有出价至少为p0的买单和所有出价至多为p0的卖单进行匹配。因此，此时的开盘成交量为出价至少为p0的买单的总股数和所有出价至多为p0的卖单的总股数之间的较小值。
　　你的程序需要确定一个开盘价，使得开盘成交量尽可能地大。如果有多个符合条件的开盘价，你的程序应当输出最高的那一个。
题目输入：
　　输入数据有任意多行，每一行是一条记录。保证输入合法。股数为不超过108的正整数，出价为精确到恰好小数点后两位的正实数，且不超过10000.00。评测用例规模与约定
　　对于100%的数据，输入的行数不超过5000。
题目输出：
　　你需要输出一行，包含两个数，以一个空格分隔。第一个数是开盘价，第二个是此开盘价下的成交量。开盘价需要精确到小数点后恰好两位。
输入样例：
buy 9.25 100
buy 8.88 175
sell 9.00 1000
buy 9.00 400
sell 8.92 400
cancel 1
buy 100.00 50
输出样例：
9.00 450
提示：
None



题目：Blinds(1182)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
			The blinds are known to consist of opaque horizontal stripes that can be rotated thus regulating the amount of light flowing in the room. There are n blind stripes with the width of 1 in the factory warehouse for blind production. The problem is that all of them are spare details from different orders, that is, they may not have the same length (it is even possible for them to have different lengths)				Every stripe can be cut into two or more parts. The cuttings are made perpendicularly to the side along which the length is measured. Thus the cuttings do not change the width of a stripe but each of the resulting pieces has a lesser length (the sum of which is equal to the length of the initial stripe)				After all the cuttings the blinds are constructed through consecutive joining of several parts, similar in length, along sides, along which length is measured. Also, apart from the resulting pieces an initial stripe can be used as a blind if it hasn't been cut. It is forbidden to construct blinds in any other way.				Thus, if the blinds consist of k pieces each d in length, then they are of form of a rectangle of k × d bourlemeters.				Your task is to find for what window possessing the largest possible area the blinds can be made from the given stripes if on technical grounds it is forbidden to use pieces shorter than l bourlemeter. The window is of form of a rectangle with side lengths as positive integers.	
题目输入：
The first output line contains two space-separated integers n and l (1  ≤  n, l ≤  100). They are the number of stripes in the warehouse and the minimal acceptable length of a blind stripe in bourlemeters. The second line contains space-separated n integers ai. They are the lengths of initial stripes in bourlemeters (1 ≤  ai  ≤  100).Process to end of file.
题目输出：
Print the single number — the maximal area of the window in square bourlemeters that can be completely covered. If no window with a positive area that can be covered completely without breaking any of the given rules exist, then print the single number 0.
输入样例：
4 2
1 2 3 4
5 3
5 5 7 3 1

Hit:
In the first sample test the required window is 2 × 4 in size and the blinds for it consist of 4 parts, 
each 2 bourlemeters long. One of the parts is the initial stripe with the length of 2, the other one
is a part of a cut stripe with the length of 3 and the two remaining stripes are parts of a stripe with 
the length of 4 cut in halves.


输出样例：
8
15

提示：
None



题目：钟点数(1427)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
话说小A在圣诞节收到了圣诞老人的礼物，打开一看，是N个画角的仪器，每个仪器都有一个角度，只能画这个角度的角，这时候，小A想，能不能用这些仪器画出其他角度的角。当然，其他角度可以由这些角度相加或者相减得来，当然也可以多次用同一个画角器,，而且大于180°的都可以转化成锐角或钝角。
题目输入：
第一行输入T，表示case数。
每个case输入两个数，0<n<=10，0<m<100，表示收到了n个画角器，并想要进行m个查询。
下一行输入n个数，表示n个画角器的角度(角度在0--180之间，取不到0，180)。
再下一行输入m个数，表示想要进行查询的角度（角度在0--180之间，取不到0，180）。

题目输出：
  对于每个查询，如果角度能够画出，输出Yes，否则输出No。
输入样例：
2
2 2
30 40
10 5
1 1
70
30

输出样例：
Yes
No
Yes

提示：
第2组样例中，30=(70+70+70)%180。



题目：小坑坑玩刀战(1729)
时间限制：1000MS
空间限制：131072KB
题目描述：
	小坑坑很喜欢玩CF。尤其喜欢玩刀战。一天小坑坑跟别人单挑。小坑坑技术没别人好。正面干不过别人。但是小坑坑很狡猾，他打算先跑到别人家里躲起来，等别人没有找到小坑坑返回的时候乘其不备干掉他。	游戏开始的时候小坑坑在A点（A即是小坑坑的家），别人在B点（B是别人的家）。别人对自己的技术很自信。游戏一开始就会找一条最短的路径直接去小坑坑家干掉小坑坑。小坑坑也要找一条最短的路径去别人家埋伏，以防在路上遇见别人被干掉，小坑坑不能跟别人走相同的路段（忽略交点相遇的可能性），小坑坑开挂了，事先已经知道别人会走哪条路。问小坑坑能不能完成埋伏。	
题目输入：
	第一行 N, M, A, B。N个交点（交点编号从1开始, A != B），M条边（2 <= N <= 100， M <= 20000 ), A,B如上所述。	接下来的M行每行三个整数  u, v, c，(1<=u , v <= N)表示在 u 跟 v之间有一条路距离为c<=1000000000的路径(保证u,v之间不出现多条相等路径)。
题目输出：
	如果可以完成埋伏输出"YES"，否则输出"NO"。	
输入样例：
6 8 1 6
1 2 1 
3 2 1 
3 4 1 
1 3 2 
4 2 2 
4 5 1 
5 6 1 
4 6 2
4 3 1 4
1 2 3
2 3 4
3 4 5
4 4 1 4
1 2 3
2 3 4
3 4 5
4 1 11
输出样例：
YES
NO
NO
提示：
None



题目：Hotelbooking(1325)
时间限制：30000 ms
空间限制：65535 ms
题目描述：
A transport company often needs to deliver goods from one city to another city. The transport company has made a special deal with a hotel chain which allows its drivers to stay in the hotels of this chain for free. Drivers are only allowed to drive up to 10 hours a day. The transport company wants to find a route from the starting city to the destination city such that a driver can always spend the night in one of the hotels of the hotel chain, and that he needs to drive at most 10 hours from one hotel to the next hotel (or the destination). Of course, the number of days needed to deliver the goods should also be minimized.
题目输入：
The input file contains several test cases. Each test case starts with a line containing an integer n, (2 ≤ n ≤ 10000), the number of cities to be considered when planning the route. For simplicity, cities are numbered from 1 to n, where 1 is the starting city, and n is the destination city. The next line contains an integer h followed by the numbers c1, c2, ..., ch indicating the numbers of the cities where hotels of the hotel chain are located. You may assume that 0 ≤ h ≤ min(n, 100). The third line of each test case contains an integer m (1 ≤ m ≤ 10^5), the number of roads to be considered for planning the route. The following m lines describe the roads. Each road is described by a line containing 3 integers a, b, t (1 ≤ a, b ≤ n and 1 ≤ t ≤ 600), where a, b are the two cities connected by the road, and t is the time in minutes needed by the driver to drive from one end of the road to the other. Input is terminated by n = 0. 
题目输出：
For each test case, print one line containing the minimum number of hotels the transport company has to book for a delivery from city 1 to city n. If it is impossible to find a route such that the driver has to drive at most 10 hours per day, print -1 instead. 
输入样例：
6
3 2 5 3
8
1 2 400
3 2 80
3 4 301
4 5 290
5 6 139
1 3 375
2 5 462
4 6 300
3
0
2
1 2 371
2 3 230
0
输出样例：
2
-1
提示：




题目：LightOperation(1630)
时间限制：1000 ms
空间限制：131072 ms
题目描述：
	There are n lights along the street,they stand in a line,are numbered 1,2,3……n.Each light can be on or off.Here is a light controller which can do three operations:	1. 1 x:make the light numbered x remain on-status.	2. 2 x:query the maximum number of continuous off-lights('continuous' means their numbers are adjacent to each other) which contain the light numbered x.	3. 3 x:make the light numbered x remain off-status.	Here x is sure to between 1 to n including 1 and n.At first all the lights are off.	 
题目输入：
	line 1:two space-separated integers n,m(n,m<=50,000),represent the number of lights and the number of operations respectively.	next m lines,each line is two space-separated integers c,d, c represents the type of operation and d represents light number associated with the operation.	Input ends with EOF.	 
题目输出：
	For each operation whose type is 2,output one line represents the query result.
输入样例：
7 10
1 4
2 3
2 4
1 3
1 6
2 5
2 1
3 2
3 4
2 4
输出样例：
3
0
1
2
2
提示：
 

	 




题目：拒绝七年之痒(1082)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
messIDou和他的女友恩恩爱爱已经五年，但他的舍友yxcwudi出于羡慕嫉妒恨，老是诅咒他们会"七年之痒"，所以messIDou对“7”这个数字格外反感。即使买彩票的时候，与7有关的数字他也不会选。“与7有关”有如下定义：
1、数字的每一位的和含有7或为7的倍数（例：数字158.每一位的和1+5+8=14，是7的倍数）
2、数字本身含有7或为7的倍数（例：数字27.数字本身含有7）
我们知道，彩票有很多不同的玩法。对于n选m玩法即从1-n之间选择m个数。聪明的你，请帮messIDou算出，他到底有多少种不同的买法,与7有关的数可不在他的考虑范围内哦。
题目输入：
第一行为t。表示下面有t组输入。
n，m（n和m均为正整数，且n≤40，m≤5）{哇！好小的数，甚至能直接把所有与7有关的数写出来}
题目输出：
拒绝“与7有关”的数，有多少种购买彩票方案
输入样例：
4
1 1
7 3
7 5
3 5

输出样例：
1
20
6
0


提示：




题目：萨尔(1532)
时间限制：1000 ms
空间限制：65535 ms
题目描述：


英雄技能：动能力场 (E)

预言者用动态能量建立一个球形的屏障，阻止敌人进入或离开。
可见围的敌方英雄越多越好！我们现在已知圈形的位置，且各个敌方英雄的位置，求敌方英雄围成的凸包（包含所有敌方英雄的最小凸多边形）和萨尔的圈形的相交面积。
题目输入：
第一行：case(<=100)。对于每一个case，第一行：萨尔圈形的圆心及半径 x y r；第二行：N。敌方英雄数量 (N<=100)。接下来N行，敌方英雄的坐标。
题目输出：
对于每个case输出相交面积，精确到小数点后两位。
输入样例：
2
0 0 2
4
0 0
0 2
2 0
2 2
0 0 2
3
0 0
0 2
2 0
输出样例：
3.14
2.00
提示：




题目：最优灌溉(1846)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　雷雷承包了很多片麦田，为了灌溉这些麦田，雷雷在第一个麦田挖了一口很深的水井，所有的麦田都从这口井来引水灌溉。
　　为了灌溉，雷雷需要建立一些水渠，以连接水井和麦田，雷雷也可以利用部分麦田作为“中转站”，利用水渠连接不同的麦田，这样只要一片麦田能被灌溉，则与其连接的麦田也能被灌溉。
　　现在雷雷知道哪些麦田之间可以建设水渠和建设每个水渠所需要的费用（注意不是所有麦田之间都可以建立水渠）。请问灌溉所有麦田最少需要多少费用来修建水渠。

题目输入：
　　输入的第一行包含两个正整数n, m，分别表示麦田的片数和雷雷可以建立的水渠的数量。麦田使用1, 2, 3, ……依次标号。
　　接下来m行，每行包含三个整数ai, bi, ci，表示第ai片麦田与第bi片麦田之间可以建立一条水渠，所需要的费用为ci。评测用例规模与约定
　　前20%的评测用例满足：n≤5。
　　前40%的评测用例满足：n≤20。
　　前60%的评测用例满足：n≤100。
　　所有评测用例都满足：1≤n≤1000，1≤m≤100,000，1≤ci≤10,000。
题目输出：
　　输出一行，包含一个整数，表示灌溉所有麦田所需要的最小费用。
输入样例：
4 4
1 2 1
2 3 4
2 4 2
3 4 3
输出样例：
6
提示：
　　建立以下三条水渠：麦田1与麦田2、麦田2与麦田4、麦田4与麦田3。



题目：Chess(1183)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
			Two chess pieces, a rook and a knight, stand on a standard chessboard 8 × 8 in size. The positions in which they are situated are known. It is guaranteed that none of them beats the other one.				Your task is to find the number of ways to place another knight on the board so that none of the three pieces on the board beat another one. A new piece can only be placed on an empty square.	
题目输入：
The first input line contains the description of the rook's position on the board. This description is a line which is 2 in length. Its first symbol is a lower-case Latin letter from a to h, and its second symbol is a number from 1 to 8. The second line contains the description of the knight's position in a similar way. It is guaranteed that their positions do not coincide.Process to end of file.
题目输出：
Print a single number which is the required number of ways.
输入样例：
a1
b2
a8
d4

输出样例：
44
38

提示：
None



题目：最多1(1428)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
这是一个很简单的问题，给你一个N*M的01矩阵，现在你需要去找最长斜相邻1的长度，和这样最长斜相邻的组数。
斜相邻是指，如果当前点坐标是(x,y)，那么(x+1,y+1),(x-1,y-1)都与其相邻。
题目输入：
第一行包含一个数T(1<=T<=20)，代表下面共有T组测试数据。
针对每组测试数据：
第一部分 N M，代表01矩阵的大小。（1<=N,M<=2000）
第二部分 一个N*M的01矩阵。

题目输出：
 针对每组测试数据，每行输出相应的最长斜相邻1的长度，及相应的组数。
输入样例：
2
5 5
1 1 1 1 1
1 0 0 1 1
0 1 1 1 1 
0 1 0 1 0
0 0 0 1 1

2 3
1 1 1
1 1 1

输出样例：
3 2
2 2

提示：




题目：小坑坑玩远古守卫战(1730)
时间限制：2000MS
空间限制：131072KB
题目描述：
	小坑坑觉得玩远古守卫战太坑了，于是他破解了这个游戏。	众所周知远古守卫战游戏是这样进行的:	10个玩家平均分成两方，每个玩家控制一个英雄互相拼杀，不断Gank、Push、Farm，以摧毁对方的主基地为游戏目的。众所周知，远古守卫战中英雄可以携带五花八门的装备，而好的装备配置有着左右战局的作用。树枝，游戏中最便宜的装备（带上它确保一场好局:D），有着单位价格最高的能力提升，但是由于英雄最多只能携带六项装备，所以携带100个树枝拯救世界的事情也是不可能发生的啦。	小坑坑讲游戏破解之后对游戏的各项参数进行了系统的研究，他总结出一项参数可以代表游戏的走势，即团队资源，而配备装备会改变团队资源的数值。	小坑坑把装备大致分为两类，一类是传奇武器，一类是配件道具。	配件道具的作用是用来合成传奇武器的，购买每一件配件道具都需要消耗一定的团队资源。	传奇武器的有着各种增益效果（BUFF），配备它们会增加一定的团队资源。传奇武器由唯一的武器卷轴和卷轴指定的若干件配件道具合成而来（有的传奇武器只需要购买卷轴，不需要配件:D），购买武器卷轴也是需要消耗一定的团队资源的。	小坑坑觉得买装备实在是太麻烦了，所以他写了一个作弊器，使得他可以复制任意多个他已经购买过的物品。由于多把相同传奇武器的BUFF是无法叠加的，所以小坑坑是不会给自己的英雄配置相同的传奇武器的（所以也不要出六把狂战斧啦:D）。	给定游戏中可以购买的所有装备的信息，小坑坑想知道他所操纵英雄最多能获得多少团队资源。
题目输入：
	题目有多组测试数据。	每组数据第一行有两个整数N，M，表示传奇装备的总数和配件装备的总数。（N <= 20, M <= 30)	第二行有N个整数A1...An,其中Ai表示购买第i种传奇装备的卷轴消耗团队资源。(Ai <= 2500)	第三行有M个整数B1...Bn,其中Bi表示购买第i种配件道具消耗的团队资源。(Bi <= 2500)	接下来N行，每行有若干个整数：	其中第一个整数Ki，表示第i种传奇武器由多少种配件道具合成。（可能为0）	接下来Ki个数对x、y，表示需要第x种配件道具y个。	最后一行有N个整数C1...Cn，其中Ci表示装备第i种传奇装备所增加的团队资源。(Ci <= 2500)		输入文件以EOF结尾。
题目输出：
	对于输入的每组数据，输出Case序数和小坑坑所能得到的最多的团队资源。	
输入样例：
4 5
0 5 10 5
50 20 20 50 100
2 1 1 2 1
2 1 1 4 1
1 4 1
1 5 1
50 100 50 20
输出样例：
Case 1: 65
提示：
None



题目：棋盘覆盖问题(1083)
时间限制：1000 ms
空间限制：65535 ms
题目描述：

在一个2k×2k(1<=k<=8)个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格(红色表示)，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。四种骨牌从左至右依次编号为1、2、3、4，要求在棋盘上填写所放骨牌的编号


题目输入：
含有多个测试用例
第一行为用例个数T(1 <= T <= 32)
每个用例输入两行
第一行：输入k
第二行：输入x，y(1 <= x,y <= 2^k)，表示特殊方格的位置坐标（如：图中特殊方格坐标为1,2）

题目输出：
随后是对每个用例输出一个2^k×2^k矩阵，表示填充后的棋盘，特殊方格用0表示。
每个用例后输出一个空行。

输入样例：
1
2
1 2

输出样例：
3 0 2 2
3 3 4 2
3 4 4 4
3 3 4 4

提示：




题目：Catchstars(1631)
时间限制：1000 ms
空间限制：65536 ms
题目描述：
	WAVwind fell in love with a pretty girl several months before and he regards her as his precess.You know ,as a high-EQ and high-IQ boy,	the precess's requests are all pieces of cake to WAVwind.Someday,the precess said "Give me the stars,dear!".Eventhough WAVwind dislikes those	unreliable things ,he doesn't want to disappoint his girl friend.He decides to make it today!Then he goes home to have a sleep for about half an hour.	In his dreams,he is standing in the sky and sees many stars which add up to N(0<N<=500),he thinks if he can fetch at least C(0<C<=N) stars,the precess will be happy.	These stars are all in the coordinate axis painted by WAVwind.Then he decides to make a square to fetch the stars.The sides of the squares can only be	paralleled to the axises.The stars exactly in the square is viewed as fetched by WAVwind.That is to say,be careful,these stars will escape when landing in the edge of the square,others cases they keep still.Then here is the question,	what's the smallest befitting length of square's sides?Because WAVwind didn't take along the computer when flied,he calls to you for help now.	
题目输入：
	Line 1:Two space-separated integers: C and N(0<C<=N<=500)	Lines 2...N+1:Each line contains two space-separated integers that are the X,Y coordinates of a star.	
题目输出：
	Line 1: A single line with a single integer that is length of edge of the minimum size square that can fetch at least C stars.	
输入样例：
2 2
1 2
2 1
输出样例：
2
提示：
None



题目：TankBattle(1326)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
       When WAVwind is writing AI for Turing Cup, he comes across a problem: a tank is a square of four units in the map. He knows both positions of his and the enemies’ tank, also, he know the information of the whole map. WAVwind want to approach the enemies’ tanks as soon as possible, but because of the actions of enemies being unsure, he suppose their tanks are static. Please find the minimum steps of the way from present location to the enemy’s location and the direction which should be selected if you choose the minimum way.(“UP” represents moving up, “DOWN” represents moving down, “LEFT” represents moving left, “RIGHT” represents moving right.If  the  direction is  nonunique ,print the one which is the max("UP">"DOWN">"LEFT">"RIGHT" ) ). Attention please, the tank can only moves up, down, left, right only one unit.
题目输入：
     The fist line is the case number.
     For each case, the first line contains two integers n, m, where n represents row and m represent column (10<=n,m<=20). The followed line is a n*m matrix, 1 represents blank area that the tank can move on it, 0 represents river or brick that the tank can not get across. The final 4 integers x1,y1,x2,y2 mean the coordinate of WAVwind’s tank (x1,y1) and the enemy’s tank (x2,y2).(The coordinate is the top left position of the tank, we ensure that the input are all validate, which means no two tanks has the same coordinate ).

题目输出：
      Output the minimum steps from self to the enemy, following a line represents the first direction to move.Print a word “fail” if there is no way.
输入样例：
2
4 4
1111
1111
1111
1111
0 0 2 2
4 6
110011
111111
110011
111111
2 0 0 4

输出样例：
4
DOWN
fail

提示：




题目：虚空假面(1533)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
时间结界: 
虚空假面撕裂时空创造的结界，使其中不论敌我任何单位甚至是防御塔都处于静止，他自己却可以凭借和这个结界的神秘联系而行动自如。施法时间1秒。（能显示隐身单位）只要一接触虚空的球，将任由虚空左右！无论我方还是敌方英雄！现在已知我方和敌方英雄的位置。要想使所有的英雄都冻结，虚空的结界的半径至少为多少？（题目本意：冻结敌方英雄数减去冻结我方英雄数最大！） 

题目输入：
第一行：case
第二行：N 英雄数量(<=1000)      
接下来N行 x y为英雄的位置
题目输出：
对于每一个case输出一个实数，球的半径，精确小数点后两位。
输入样例：
1
5
5 0 0
-5 0 0
0 3 4
4 -3 0
2 2 -2
输出样例：
5.00
提示：




题目：货物调度(1847)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　某公司要处理一个周期性的物流问题。
　　有n个城市，第i个城市在每周的第j(1≤j≤7) 天会生产aij吨某种货物，同时需要消耗bij吨该种货物。已知每周的产量等于消耗量（即aij之和等于bij之和）。
　　城市之间有m条道路，第k条道路连接了城市sk和tk。一条道路上运输1吨货物有一个固定的成本ck。道路都可以双向使用。每天运输的货物量没有限制。城市之间的距离并不远，货物可以从任意一个城市运输到任意另一个城市并且在当天到达。
　　货物如果在当天没有被消耗掉，就需要存放在仓库里过夜。第i个城市的仓库容量为vi，存放1 吨货物过一夜所需的成本是wi。
　　请你计算该公司如果每周循环性地按照一个固定的流程调度货物的话，该公司在最优方案下每周需要为货物的运输和存储消耗多少成本。

题目输入：
　　输入的第一行有两个正整数n和m，即城市的个数和道路的条数。
　　接下来有n行，每行包含16个整数，用以描述第i个城市的相关数据。其中第i行包含的数为ai1, ai2, ai3, ai4, ai5, ai6, ai7, bi1, bi2, bi3, bi4, bi5, bi6, bi7, vi, wi。
　　接下来有m行，每行包含3个整数，用以描述一条道路的相关数据。其中第k行包含的数为sk, tk和ck。
　　输入数据中城市的编号均为1到n之间。输入数据的每行的行首行尾均保证没有空格，两个数之间恰好被一个空格隔开。评测用例规模与约定
　　对于100%的数据，1≤n≤100，1≤m≤500，0≤aij,bij,vi≤100，1≤wi,ck≤100。
题目输出：
　　你只需要输出一个数，即最优方案下每周的支出。
输入样例：
3 3
0 0 0 0 5 0 0 0 0 0 0 0 0 0 2 4
0 0 0 0 0 0 0 2 0 0 0 0 0 0 2 1
0 0 0 0 0 0 0 0 0 3 0 0 0 0 2 5
1 2 1
1 3 5
2 3 1
输出样例：
67
提示：
样例说明
　　城市1 每周五生产5 吨货物，把其中2 吨运到存储费用低廉的城市2 存储，把1 吨运到城市3 存储，剩下的2 吨留在城市1。
　　在次周一的时候城市2 会消耗掉存放在那里的2 吨货物。为了节约存储成本，将囤放在城市1 的货物运到城市2 存放。周三再将所有货物运到城市3 以满足该城市的需求。
　　在此方案下，每周的运输成本为8，每周的存储成本为59，因此每周的总支出为67。



题目：潘多拉星球的棒球比赛(1084)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
潘多拉星球的棒球比赛和地球的比赛很类似。在游戏场地，有4个基地分别被命名为“大本营”，“一垒”，“二垒”和“三垒”。在开始的时候，没有人是在基地。有两个小组，一个是进攻队，另一个是防守球队。进攻队的所有球员一个接一个去大本营击打防守球队抛出的球。
 
有四种击打可能的结果：
 
1. “out”。在这种情况下，击球手没击中球，所以他是不称职的，并离开游戏。
 
2.“bingo”。在这种情况下，击球手击到球，但球没有飞出场地界外。然后，击球手可以前进到一垒，以及已经在基地上的进攻球员可以前进到下一个基地（第三个基的人可以跑到大本营）。如果球员返回到大本营，得分1点他的球队。
 
3.“Allrun”。在这种情况下，击球手把球击打出界外，然后所有进攻球员（包括击球的球员）可以跑到大本营，每个人为他的球队得一分。因此，在这种情况下，进攻队至少得1点，最多得4分。
 
4.“Sacrifice”。在这种情况下，击球者选择不击打并且离开场地。根据规则在这种情况下，仍然在基地的球员可以前进到下一个基地。所以，这种情况有队员到达大本营球队加一分。但是，如果之前已经有两个击打者得到“out”或“sacrifice”，“sacrifice”将立即结束游戏，攻击球队在这一轮不得分。
 
根据规则，球员在他为球队得分以后他必须立即离开场地。当进攻球队的每个队员都击打过一次或者当他们总共有3次“out”或者“sacrifice”，比赛结束。
现在给你进攻队的每个队员的表现，让你算出这支队的得分。
题目输入：
输入包含多个用例。
第一行包含一个整数T代表用例个数。
每个测试案例始于一整数n（1 <= n<= 30），代表进攻球队球员的数目。然后有n整数，第i个整数表示第i个球员的表现。

以下是每个击打结果的代号：

0表示结果是“out”

1代表结果是“sacrifice”

2是指结果是“bingo”

3是指结果是“Allrun”


题目输出：
对于每个测试用例，输出一行包含“Case #x: y”，其中x是用例号和y是球队的进攻将分。
输入样例：
3
4
0 1 2 3
10
1 2 2 1 2 1 2 2 1 3
6
2 2 1 1 1 3

输出样例：
Case #1: 2
Case #2: 1
Case #3: 1

提示：




题目：最佳旅游路线(1429)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
有N个城市,编号从1到N，他们之间通过N-1条双向道路相连，虽然只有N-1条道路，却能保证任何两个城市能相互到达。现在SA来到了标号为X的城市，他手里有张地图，地图上是一个城市集m1,m2,m3…mj，其中每个城市都是不同的，并且与X也不同。现在SA想从X开始访问完所有的城市，当然正如你说想的那样，每条道路都有一个花费，现在的问题当然是想让总的花费最小。
即将参加ChengDu Regional的童鞋们，能帮忙解决这个问题么？
题目输入：
第一行包含两个数N，X，意义如上所述。（2<= N<=50000，1 <=X<=N）
接下来下面N-1行，每行包含3个整数 A B C，代表A城市和B城市直接相连，费用为C。（1<= A,B<= N，1<= C<= 1000）
	接下来一个数j（1<= j <= N - 1），代表城市集上共有j个城市。
接下来一行，包含j个不同的整数m1,m2,m3…mj，代表SA想去的城市。
注意：SA的访问顺序不一定按照m1,m2,m3…mj的顺序进行。

题目输出：
 输出最小费用
输入样例：
4 2
1 2 1
4 2 2
2 3 3
2
1 3

输出样例：
5
提示：




题目：小坑坑的称号(1731)
时间限制：1000MS
空间限制：131072KB
题目描述：
	小坑坑很喜欢玩CF---CROSS FIRE。CF里面有很多称号，例如玩挑战模式玩的很好会有挑战之王称号，玩爆破玩的很好会有爆破之王的称号等。小坑坑是只奇葩，在CF里建了个工会，可惜没人加入，于是他打算自己申请小号加入，于是他申请了很多的QQ号，可是CF有个规定，一个ID必须得有至少一个称号才能加入工会，于是小坑坑这只奇葩就天天换着号来玩CF。。。终于把所有的小号都加进去了，但是他又发现一个问题，所有的帐号都用一个密码实在不安全，各不一样又不好记（小坑坑申请了1000个QQ号。）。于是他。他决定按照称号来分配密码。一个称号分配一个密码。然后他又发现一个问题，有些小号获得了不止一个称号。比如ID为 CF1的小号获得了两个称号“挑战之王”与“爆破之王”，到底该怎么来改CF1的密码？小坑坑希望把密码都改好后使得拥有帐号最多的那个密码的帐号数目最少。然后他问你，帐号最多的那个密码的拥有的帐号数目最少是多少。
题目输入：
	一个整数（1 <= N <= 1000）表示小Q的帐号数，一个整数（1 <= M <= 500）表示称号总数。接下来N行，每行开始包括一个ID（长度<=15的英文字符和数字组成，每个ID都不一样）一个整数K，然后K个称号（长度<= 15的英文字符和数字组成，每个称号都不一样），以“0 0 ”结束输入。
题目输出：
	把每个帐号分配好密码后，拥有帐号最多的那个密码的帐号数目。
输入样例：
3 2
CF1 2 Killer Fire
CF2 1 Fire
CF3 1 Fire
5 4
CF4 3 Sorry CROSS ACM
CF5 2 TK Sorry
Asian 3 TK CROSS ACM
littleQ 2 Sorry CROSS
bigQ 2 TK CROSS
0 0
输出样例：
2
2
提示：

	样例一有两种分配密码的方式：


	第一种： CF1 CF2 CF3 都分配Fire称号的密码。


	第二种： CF1 分配Killer 称号的密码， CF2 CF3分配Fire称号的密码。


	显然第二种符合题意。拥有帐号最多的那个密码的帐号数目是2(CF2, CF3)。




题目：VasyatheArchitect(1184)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
			Once Vasya played bricks. All the bricks in the set had regular cubical shape. Vasya vas a talented architect, however the tower he built kept falling apart.				Let us consider the building process. Vasya takes a brick and puts it on top of the already built tower so that the sides of the brick are parallel to the sides of the bricks he has already used. Let's introduce a Cartesian coordinate system on the horizontal plane, where Vasya puts the first brick. Then the projection of brick number i on the plane is a square with sides parallel to the axes of coordinates with opposite corners in points ( xi ,  1 , yi ,  1 ) and ( xi ,  2 , yi ,  2 ). The bricks are cast from homogeneous plastic and the weight of a brick a × a × a is a3 grams.				It is guaranteed that Vasya puts any brick except the first one on the previous one, that is the area of intersection of the upper side of the previous brick and the lower side of the next brick is always positive.				We (Vasya included) live in a normal world where the laws of physical statics work. And that is why, perhaps, if we put yet another brick, the tower will collapse under its own weight. Vasya puts the cubes consecutively one on top of the other until at least one cube loses the balance and falls down. If it happens, Vasya gets upset and stops the construction. Print the number of bricks in the maximal stable tower, that is the maximal number m satisfying the condition that all the towers consisting of bricks 1, 2, ..., k for every integer k from 1 to m remain stable.	
题目输入：
The first input file contains an integer n (1  ≤  n  ≤  100) which is the number of bricks. Each of the next n lines contains four numbers xi1, yi1, xi2, yi2 (xi1  ≠  xi2, | xi1  -  xi2| = |yi1  -  yi2|) which are the coordinates of the opposite angles of the base of the brick number i. The coordinates are integers and their absolute value does not exceed 50.The cubes are given in the order Vasya puts them. It is guaranteed that the area of intersection of the upper side of the brick number i - 1 and the lower side of the brick number i is strictly strictly greater than zero for all i  ≥  2.Process to end of file.
题目输出：
Print the number of bricks in the maximal stable tower.
输入样例：
2
0 0 3 3
1 0 4 3
2
0 0 3 3
2 0 5 3
3
0 0 3 3
1 0 4 3
2 0 5 3

输出样例：
2
1
3

提示：
None



题目：Tree-最短点对(1632)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	Give a tree with nvertices,each edge has a length(positive integer less than 1001). Define cost(u,v)=The min edge in the path which from node u to node v .Give an integer k,for every pair (u,v) of verticesis called valid if and only if cost (u,v) not exceed k. Write a program that will count how many pairswhich are valid for a given tree. 
题目输入：
	The input contains several test cases. Thefirst line of each test case contains two integers n, q. (n<=10000,q<= 100) The following n-1 lines each containsthree integers u,v,l, which means there is an edge between node u and v oflength l. Then following q lines each contains one integer k(k>=0). End of by EOF. 
题目输出：
	For each k output the answer on a singleline.
输入样例：
5 2
1 2 3
1 3 1
1 4 2
3 5 1
4
0

输出样例：
10
0

提示：
None



题目：Indreaming3000(1327)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
     In the team of dreaming3000, between Bearjie, xiaoyoulei and zlly ,there exists one kind of strange debt relations: Bearjie owes xiaoyoulei 1000RMB, xiaoyoulei owes zlly 1000RMB, zlly owes Bearjie 1000RMB.One day, they met. Driven by their unwise mind and desperate desire for wanting the money back,  they decide to deal with it in a race . At first, the three respectively stand at the corresponding vertex of an equilateral triangle with its side length maesuring L. At a certain time , they simultaneously start the uniform motion at the speed V . Their movement's direction is like this: At every moment, the Bearjie movement's direction aims at the xiaoyoulei, xiaoyoulei movement's direction aims at the zlly, zlly movement's direction aims at Bearjie. In brief, all the time, the three are trying to approaching as fast as possible the person who owes to themselvs respectively the debt. Finally, they arrive at the identical spot, and has solved this conflict through peaceful talks. After WAVwind learns about this matter,he wants to write a report to publicize it. He needs to know S ,the length of the path for each person as well as the time T to get to the same point. 
题目输入：
     There are two lines for input. The first line is a real number L(0<=L<=10^100).The second  line is a real number V(0<=V<=10^100).
题目输出：
There are two lines for output. The first line is a real number S, accurate to one digital after the point. The second line is a real number T , also accurate to one digital after the point.  
输入样例：
13.05 
0.56 
输出样例：
8.7 
15.5 
提示：
You can use printf("%.1lf\n",ans); to print a real number "ans" with only one digital.



题目：都是无聊的题啊！！！(1534)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
求小于等于n，且包含“13”数字组合，且能被13整除的数的个数。n的范围：n<1000000000
题目输入：
第一行：case(<=100)。接下来case行，每行一个n
题目输出：
对于每一个case输出满足条件的数的个数。
输入样例：
3
100
13
100000
输出样例：
1
1
307
提示：




题目：图像旋转(1848)
时间限制：5.0s
空间限制：256.0MB
题目描述：
旋转是图像处理的基本操作，在这个问题中，你需要将一个图像逆时针旋转90度。
计算机中的图像表示可以用一个矩阵来表示，为了旋转一个图像，只需要将对应的矩阵旋转即可。
题目输入：
输入的第一行包含两个整数n, m，分别表示图像矩阵的行数和列数。接下来n行每行包含m个整数，表示输入的图像。评测用例规模与约定
　　1 ≤ n, m ≤ 1,000，矩阵中的数都是不超过1000的非负整数。
题目输出：
输出m行，每行包含n个整数，表示原始矩阵逆时针旋转90度后的矩阵。
输入样例：
2 3
1 5 3
3 2 4
输出样例：
3 4
5 2
1 3
提示：
多组输入输出数据，以EOF结尾



题目：Let'sGoRolling!(1185)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
			On a number axis directed from the left rightwards, n marbles with coordinates x1 , x2 ,  ... , xn are situated. Let's assume that the sizes of the marbles are infinitely small, that is in this task each of them is assumed to be a material point. You can stick pins in some of them and the cost of sticking in the marble number i is equal to ci, number ci may be negative. After you choose and stick the pins you need, the marbles will start to roll left according to the rule: if a marble has a pin stuck in it, then the marble doesn't move, otherwise the marble rolls all the way up to the next marble which has a pin stuck in it and stops moving there. If there is no pinned marble on the left to the given unpinned one, it is concluded that the marble rolls to the left to infinity and you will pay an infinitely large fine for it. If no marble rolled infinitely to the left, then the fine will consist of two summands:							the sum of the costs of stuck pins;							the sum of the lengths of the paths of each of the marbles, that is the sum of absolute values of differences between their initial and final positions.						Your task is to choose and pin some marbles in the way that will make the fine for you to pay as little as possible.	
题目输入：
The first input line contains an integer n (1  ≤  n  ≤  3000) which is the number of marbles. The next n lines contain the descriptions of the marbles in pairs of integers xi,ci ( - 10^9  ≤  xi, ci  ≤  10^9). The numbers are space-separated. Each description is given on a separate line. No two marbles have identical initial positions.Process to end of file.
题目输出：
Output the single number — the least fine you will have to pay.
输入样例：
3
2 3
3 4
1 2
4
1 7
3 1
5 10
6 1

输出样例：
5
11

提示：
None



题目：LoveStoryI(1430)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Once upon, there was a famous couple between on earth, just because the girl was a fairy coming from the sky and the boy was just a farmer whose unique property was an old bull. A talented poet had written a poem for them, saying that,” Clouds float like works of art. Stars shoot with grief at heart. Across the Milky Way, the cowherd meets the maid, when autumn’s golden wind embraces dew of jade. All the love scenes on earth, however many fade. Their tender love flows like a stream. This happy date seems but a dream. Can they bear a separate homeward way? If love between both sides can last for age, why need they stay together night and day?”Even though the boy’s mother-in-law was extremely cruel, she reluctantly allowed her daughter and her son-in-low meeting once in one year along the Milky Way. The boy was perturbed and moved between two locations in a straight line, back and forth at a fixed speed. The girl was eager to see her husband, so she would pick the straightway road which is a line and fly to her sweetheart at a maximal speed. Now they wanted to know whether they could have a date successfully. If their minimal distance was longer than their eyesight distance, they would miss each other, so it’s your job to calculate their minimal distance. Be careful that they started at the same time.
题目输入：
Input contains multiple test cases. Each test case contains two lines in the following format.
bx1 by1 bx2 by2 bv
gx1 gy1 gx2 gy2 gv
(bx1, by1) means the start position of the boy, (bx2, by2) is another position of the line, and bv is his speed. (gx1, gy1) and (gx2, gy2) won’t be the same at one time.
(gx1, gy1) is the start position of the girl and (gx2, gy2) is one point on her direction, and gv is her speed.
All numbers in the input are floating numbers.(-500000000 <= bx1, by1, bx2, by2, gx1, gy1, gx2, gy2 <= 500000000, 0 <= bv, gv <= 20000)

题目输出：
For each case just output one line contains the minimal distance in exactly 5 digits.


输入样例：
-5002 2349.1 23434.234 234 4
-238 0 341 13 43

输出样例：
5311.68211
提示：




题目：2012大逃亡(1085)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
       传说中的2012快到来了，为了逃避灾难，鱼头找到了一个安全地带。可是当他带领acm集训队的同学们来到时，发现因为地震和火山爆发，许多地方已经不能通行了。还好鱼头有先见之明，在一些地方放置了传送门。可不幸的是，传送门同样应为地震，部分功能已经失灵。现在知道：传送门是一对对的，其中一个是主门，另一个是副门，只能从主门传送到副门，不能反过来。因损坏，只要当人走到主传送门上时，它就会不受控制的将人传到副门。因为传送需要能量，所以对某个固定的传送门只能传送固定次数。同时不能走出所在区域（外面不安全）。现已知此处的地图和传送门坐标，鱼头想知道最少几步能从起点走到目的地？ 

题目输入：
第一行是一个整数t，表示测试数据个数。
对每组数据：
	第一行2个整数n，m，表示地图边长。0 < n、m<=10(地图坐标从1算起)
	接下来n行每行m个元素，’.’表示此处安全，’#’表示此处危险（走上去就挂了），’s’表示鱼头所在位置，’e’表示目的地。地图外区域均为’#’。
	接下来一个整数k，表示传送门数目。0<=k<=8;
	接下来k行每行5个整数，x1,y1,x2,y2,s对应主传送门坐标和副传送门坐标,s为次传送门一共能传送几次。0 < s <= 2
任意2个主传送门坐标不可能相同，主传送门不会是目的地。1 <= x1 <= n,1 <= y1 <= m。
	鱼头每次只能走向相邻的4个坐标中，每移动一次需1的时间，传送一次需1的时间。

题目输出：
鱼头从所在位置走到安全地带所需时间，无法到达或走出地图输出-1。
输入样例：
2
2 2
s.
.e
0
3 3
s.#
.#.
.#e
1
1 2 2 3 2

输出样例：
2
3

提示：




题目：大神(1732)
时间限制：3000MS
空间限制：131072KB
题目描述：
	此题不是小坑坑系列，因此题目不是“小坑坑大神”。	Shangke7788是集训队的队长，因此他想认识更多的大神（也有大神想认识Shangke7788）。不过这是要付出时间和精力的。现在有N个大神（包括Shangke7788），他们都有自己想认识的人，因为各人的脾气不同，每个大神i对每个想要认识的大神j付出的代价不完全相同，记为c(i,j)。	同样作为大神的你，了解M个他们所有人的想法，请你安排一个方案，使得某一个大神可以直接或间接的认识到所有人（例如a想认识b，b想认识c，那么我们可以认为a也想认识c），并且总的代价和最小。
题目输入：
	输入有多组数据。每组数据第一行是一个整数N（N <= 100），M(M <= 10000)。	接下来M行，每行以格式s1, s2, c给出。	s1 大神A的名字（名字的长度不会超过20个字符）	s2 大神A想认识的牛人B的名字	c  认识的代价
题目输出：
	每组数据输出最小的代价，如果不存在这样的方案，输出“Poor Shangke7788”。
输入样例：
3 2
shangke7788 tsfn 1
tsfn watashi 2
3 1
bob alice 1
输出样例：
3
Poor Shangke7788
提示：
None



题目：数字排序(1849)
时间限制：1.0s
空间限制：256.0MB
题目描述：
给定n个整数，请统计出每个整数出现的次数，按出现次数从多到少的顺序输出。
题目输入：
输入的第一行包含一个整数n，表示给定数字的个数。
第二行包含n个整数，相邻的整数之间用一个空格分隔，表示所给定的整数。评测用例规模与约定
　　1 ≤ n ≤ 1000，给出的数都是不超过1000的非负整数。
题目输出：
输出多行，每行包含两个整数，分别表示一个给定的整数和它出现的次数。按出现次数递减的顺序输出。如果两个整数出现的次数一样多，则先输出值较小的，然后输出值较大的。
输入样例：
12
5 2 3 3 1 3 4 2 5 2 3 5
输出样例：
3 4
2 3
5 3
1 1
4 1
提示：
None



题目：简单题面(1633)
时间限制：2000 ms
空间限制：65536 ms
题目描述：
给一串大于0的数列。求出连续的子串和大于等于x（int型）的个数。
题目输入：
	第一行两个整数 c （0 < c <= 1000000）, x 分别表示有多少个数字，和上文中的x第二行有c个正整数（每个数字小于100）。	
题目输出：
	每个case一行，包含一个整数 ， 大于等于x的字串的个数。
输入样例：
2  4
2  3

输出样例：
1
提示：
None



题目：dodecahedron(1328)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Just calculate the volume of a dodecahedron.
题目输入：
A integer n (0
            
题目输出：
A number , the volume of the dodecahedron , which should be accurated to two numbers after the point. See the sample output.
输入样例：
3
31
56
29
输出样例：
228291.98
1345766.30
186895.81

提示：




题目：无聊的题目(1535)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
如图，有很多羊！！！图中小黑圈，这些位置也是他们爱呆的点！现在要分成一些扇形，扇形的半径无穷大，每个扇形内必须大于等于K个羊（题目另一个版本：扇形的圆心角不能超过A（单位弧度）且不能低于B ），一个扇形里面的羊只能在这个扇形里面活动，这个扇形里面的食物都在这个扇形最右边的那条射线上（图中最黑）。我们认为每个羊去吃食物的耗费为它所在的射线到放食物射线的圆心角如果a1,a2,a3。现在我们如何分组使得所有羊去吃食物的耗费总和最小！简单化，我们认为中心点（0,0）不存在羊。且所有的羊都在第一二象限中！	
题目输入：
第一行：case数（<=1000）。对于每一个case：第一行：K。第二行：N：羊的个数（<=1000）接下来N行：x y z, 表示羊的位置
题目输出：
一个实数，精确到小数点后2位！
输入样例：
1
2
2
1 0
0 1
输出样例：
1.57
提示：
None



题目：LoveStoryII(1431)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
Have you ever read the poem wrote by Nalanxingde? Were love always the same as the first view, why abandoned the fan when autumn wind blew? How heartless you changed your affection, but blaming me of quick fading emotion. Midnight till we finished talk in Lishan Mount, no resentment even if tears falling beyond count. Remembering fresh the pledge of love you sworn, flying together and joining branches tight but a wish forgone.In these words, a couple was mentioned. In Tang Dynasty, there was an emperor named Longji Li, his favorite concubine was Yuhuan Yang. What is a pity that Lady Yang died in a conspiracy caused by Lushan An who wanted to take place of Li for himself. In the end, Lady Yang became a fairy settled down in Penglai Mount. Longji Li missed her very much and wanted to meet her in dreams. However, Lady Yang was angry for Li didn’t save her before his soldiers, so she refused to see Li. Li was very repentant and he paid the visit to Yang many times. Finally, Yang ordered her maid to open the door.Let’s simplify this mode. There are N stations in Penglai Mount which numbered from 1 to N. Yang’s palace is numbered S, while the station numbered T is Li’s start place. There’ are M directed sideways connecting the stations. Li had to arrive at Yang’s palace for K times and he couldn’t take the total same path each time, but he could take the same sideways for many times and he can also include the same station twice or more even it is S or T. Absolutely, the shorter Li had walked the happier and more satisfied he would be. Now, as his manservant, you should design the path each time to make the sum as short as possible and tell Li how long is it. Li had to come to Yang’s palace once and back and again and back and so on until she was willing to see him. Be careful that S isn’t equal to T.

题目输入：
Input contains multiple test cases. The first line contains two integer numbers N and M (1 <= N <= 1000, 0 <= M <= 100000). The second line contains three integer numbers S, T and K(1 <= S, T <= N, 1 <= K <= 1000). Then, each of the following M lines contains three integer numbers A, B and L(1 <= A, B <= N, 1 <= L <= 1000000000). It shows that there is a directed sideway from A to B which length is L.
题目输出：
For each case just output one line contains the minimal sum. If you cannot find K different paths, you should just output “-1” (without quotes) instead.
输入样例：
3 6
3 1 2
1 2 1 
2 1 2
1 3 3
3 1 4
2 3 5
3 2 6

输出样例：
13
提示：
In this sample, Li’s path is like the following: 1 -> 3 -> 1 -> 2 -> 3 or 1 -> 3 -> 1 -> 2 -> 1 -> 3, and the sum is 13.



题目：WatchTV(1186)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
As is known to all,the Activity Room of our acm team moved to the Optical&Electronic Lab this year,and the TV signal is really bad here,so fishhead ask the Captain panda,to fix the radio wave receiver so that it can find the satellite quickly.
so panda came up with a new idea on finding the satellite using the interference phenomenon. He put the radio wave receiver h meter above the surface of a water pool(it's very big). When a satellite rising, it detects maxima successively due to interference of radio waves from the satellite, and its reflection waves from the water. The wavelength of the waves is λ centimeters. Panda wants to find stars as soon as possible. Can you help him?
题目输入：
multiply test cases.
Each line contains h and λ separated by a space.
题目输出：
Print the minimum altitude angle of the satellite in degree. The value should be accurate to two decimal points. (There may be several result for one case, but only output the minimum altitude angle!)
输入样例：
0.5 20.0
20.0 0.5

Hit:
Notice: When light reflected from a medium having an index of refraction greater than that of the medium in which it is traveling, 
a 180°phase change (or λ/2 shift ) occurs.
输出样例：
5.74
0.00

提示：
Notice: When light reflected from a medium having an index of refraction greater than that of the medium in which it is traveling, a 180°phase change (or λ/2 shift ) occurs.



题目：小坑坑玩魔方(1733)
时间限制：1000MS
空间限制：131072KB
题目描述：
	小坑坑觉得转魔方太坑了，于是破解了它。	小坑坑发现，在拧三阶魔方时，有个公式为：U,  R,  U', R', U', F', U, F	U的意思为顺手拧上面，R的意思为顺手拧右面，F为顺手拧前面，相应的U',R',F'为逆手拧。	顺手拧（右手），效果为	1 2 3	4 5 6	7 8 9	变为：	7 4 1	8 5 2	9 6 3	起初，魔方六面每面颜色均一样，任选一面对着自己为前面，运用上述公式。请编程输出最少运用多少次此公式可将魔方还原为每面颜色一样，如果总不能达到要求，输出Impossible.(一旦初始时对着自己的面确定，之后每次运用公式都不能旋转魔方，即总是这面对着自己)	
题目输入：
	没有输入数据。
题目输出：
这个不能告诉你~猜吧~
输入样例：
None
输出样例：
O(∩_∩)O~
提示：
大坑题



题目：配水方案(1086)
时间限制：1000 ms
空间限制：65535 ms
题目描述：

    Snow是ACM队里的小朋友，但他思维敏捷，让fishhead十分赏识，于是会经常让他帮忙解决一些问题。一天，fishhead做一份项目时遇到了问题。如上图所示，为水流运送模型，最底层为最终用户。最高点为总水量。每一个节点向下分配水的时候可以随意选择给左边多少，给右边多少，但一定要分配完。且最终用户收到的水量至少为1.现在告诉你总共的水量和最终用户的数量。问有多少种不同的构造配水方案。
题目输入：
第一行为整数t，代表t组测试数据
下面的t行分别有两个正整数sum和n，分别代表总水量和最终用户数量.且sum ＜ 1，000，000;n ＜ 1，000，000

题目输出：
每一个测试数据给出一个整数，为配水方案个数ans.因为最后的结果很大，所以请对输出结果ans%1，000，000，007
输入样例：
5
5  3
16  5
15  4
31556  15
500  150

输出样例：
2
1
24
81126713
0


提示：




题目：节日(1850)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　有一类节日的日期并不是固定的，而是以“a月的第b个星期c”的形式定下来的，比如说母亲节就定为每年的五月的第二个星期日。
　　现在，给你a，b，c和y1, y2(1850 ≤ y1, y2 ≤ 2050)，希望你输出从公元y1年到公元y2年间的每年的a月的第b个星期c的日期。
　　提示：关于闰年的规则：年份是400的整数倍时是闰年，否则年份是4的倍数并且不是100的倍数时是闰年，其他年份都不是闰年。例如1900年就不是闰年，而2000年是闰年。
题目输入：
　　输入包含恰好一行，有五个整数a, b, c, y1, y2。其中c=1, 2, ……, 6, 7分别表示星期一、二、……、六、日。评测用例规模与约定
　　所有评测用例都满足：1 ≤ a ≤ 12，1 ≤ b ≤ 5，1 ≤ c ≤ 7，1850 ≤ y1, y2 ≤ 2050。

题目输出：
　　对于y1和y2之间的每一个年份，包括y1和y2，按照年份从小到大的顺序输出一行。
　　如果该年的a月第b个星期c确实存在，则以"yyyy/mm/dd"的格式输出，即输出四位数的年份，两位数的月份，两位数的日期，中间用斜杠“/”分隔，位数不足时前补零。
　　如果该年的a月第b个星期c并不存在，则输出"none"（不包含双引号)。
输入样例：
5 2 7 2014 2015
输出样例：
2014/05/11
2015/05/10
提示：
None



题目：南理工007(1634)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
	C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子xiaoyoulei和他手下Bearjie又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地(一开始的时候工兵营地都只有K个人驻守), xiaoyoulei和Bearjie的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，而且是连续的兵营增加相同的人数，可能增加若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以xiaoyoulei要随时向Bearjie汇报某一段连续的工兵营地一共有多少人,例如xiaoyoulei问:“Bearjie,马上汇报第3个营地到第10个营地共有多少人!” Bearjie就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而xiaoyoulei每次询问的段都不一样，所以Bearjie不得不每次都一个一个营地的去数，很快就精疲力尽了，xiaoyoulei对Bearjie的计算速度越来越不满:"你个死肥仔，算得这么慢，我炒你鱿鱼!” Bearjie想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Bearjie只好打电话向计算机专家dreaming3000求救, dreaming3000说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!” Bearjie说："我知错了。。。"但dreaming3000已经挂掉电话了。Bearjie很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Bearjie还是会受到xiaoyoulei的责骂的.
题目输入：
	第一行一个整数T, 表示有T组数据。	每组数据第一行一个正整数N（N< = 50000），K（1< = K< = 50 ）。,表示敌人有N个工兵营地。一开始所有的工兵营地都有K个人驻守。接下来每行有一条命令，命令有4种形式： (1) 1  i j  c  , i，j，c为正整数,表示第i个营地到第j个营地增加c个人,(i< = j, c 不超过30） (2) 2  i  j     ,i和j为正整数,i< = j，表示询问第i到第j个营地的总人数; (3) 0          表示结束，这条命令在每组数据最后出现;
题目输出：
	对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数这个数最多不超10 ^9
输入样例：
1
10 2
1 2 3 5
2 2 3
1 2 5 4
2 1 10
0

输出样例：
Case 1:
14
46

提示：
None



题目：POSTMAN(1329)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Sam is a postman of the city X, his job is to deliver mails to their destinations. There are N destinations (labeled from 1 to N), one post office (always labeled with 0), and M streets connecting these destinations and the post office. Every day Sam start from the post office at time 0, carrying all the mails he should deliver on that day, and then deliver them along the streets. When he reaches a destination at the first time, he will hand the mail to the person at that destination immediately.
The dissatisfaction of one person is the time he should wait until he receives his mail. Sam wants to design a route in order to minimize the total dissatisfaction of these N persons.
题目输入：
The first line is an integer T indicating the number of test cases.

Next T block, each block is a test case.

First line of each block is two integers N, M (1 <= N <= 15, 0 <= M <= 200)

Followed by M lines, each line is three integers A B C, indicating that there is a street whose length is C between A and B. (0 <= A, B <= N, 0 < C < 10,000)


题目输出：
If Sam can deliver all these N mails to their destinations output the minimum dissatisfaction, otherwise output -1.


输入样例：
1
3 6
0 1 1
0 2 4
0 3 3
1 2 2
1 3 2
2 3 10

输出样例：
11

提示：




题目：RareOrder(1536)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	A rare book collector recently discovered a book written in an unfamiliar language that used the same characters as the English language. The book contained a short index, but the ordering of the items in the index was different from what one would expect if the characters were ordered the same way as in the English alphabet. The collector tried to use the index to determine the ordering of characters (i.e., the collating sequence) of the strange alphabet, then gave up with frustration at the tedium of the task.	You are to write a program to complete the collector's work. In particular, your program will take a set of strings that has been sorted according to a particular collating sequence and determine what that sequence is.	
题目输入：
	The input consists of an ordered list of strings of uppercase letters, one string per line. Each string contains at most 20 characters. The end of the list is signalled by a line with the single character `#'. Not all letters are necessarily used, but the list will imply a complete ordering among those letters that are used.	
题目输出：
	Your output should be a single line containing uppercase letters in the order that specifies the collating sequence used to produce the input data file.	
输入样例：
XWY
ZX
ZXY
ZXW
YWWX
#
输出样例：
XZYW
提示：
None



题目：LoveStoryIII(1432)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
There is a famous piece of music called “Butterfly Lovers” which everyone has heard. Its gentle and soft tune can affect everybody’s mood and hold the breath. In ancient times, girls were not allowed to go to study in schools. A beautiful and talented girl named Yingtai Zhu had to disguise as a boy to study, and she became bosom friends with Shanbo Liang. Liang didn’t knowing that Zhu was a girl, but he admired the clever guys very much and had a good impression on her. Before returning home, Zhu implied to Liang that she would be his wife. Knowing that Zhu was a girl, the delighted Liang hurried to her home, only to find that her family had betrothed her to someone else against her will. Under the pressure of the patriarchal clan rules and feudal ethics, they died for love and return into a pair of butterflies. The moving tragic legend extols pure love and freedom of love. Once a sunny day in their school and after class, they played a game. Zhu would like Liang to compute integer powers P of numbers quickly and they just kept around two work variables for intermediate results. The first of the two work variables was initialized to the number x for which they were calculating its power (x doesn’t appear in the input), the other was initialized to 1. Liang could only multiply or divide any pair of the work variables and store the result in any work variable, and all operations were in integers, especially division. Liang wanted to prove that he is clever enough to match Zhu. So he would like to solve this problem in minimum number of operations.
题目输入：
Input contains multiple test cases. The first line contains one integer number P (0 <= P <= 20000).
题目输出：
For each case just output one line with a single integer that is the minimum number of operations it requires to compute the power. 
输入样例：
31
输出样例：
6
提示：
In this sample, one way to perform the calculation is: 

                                              V1  V2

                                      Start:   x    1

          Multiply first by first, store in second:   x   x^2

                  Multiply second by second:   x   x^4

                  Multiply second by second:   x   x^8

                  Multiply second by second:   x   x^16

                  Multiply second by second:   x   x^32

                      Divide second by first:   x   x^31




题目：Dinner(1734)
时间限制：2s
空间限制：131072KB
题目描述：
	Tomorrow, Our institute held a party. Our institute has 100 people.We hold a circle to have dinner evenly. But not any one came to the party. Alice wanted to charge. But he didn't know how many people came. He had two friends, Bob and Caca. So he already knew three positions:(Bob’s, Caca’s and himself). He wanted to know at least how many people came.		
题目输入：
			Multiple cases, end with EOF.				Each case consists of three lines, each of them contains a pair of numbers: (x, y), the position. All the numbers are in the range of [-200.0, 200.0].			
题目输出：
			The minimum number of people who came to the party. If impossible, output "NO" in one line	
输入样例：
0.0   0.0
1.0   0.0
0.0   1.0
输出样例：
4
提示：
None



题目：多边形游戏(1087)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
    给定N(2<=N<=100)个顶点的多边形，每个顶点标有一个整数，每条边上标有+(加)或是×(乘)号，并且N条边按照顺时针依次编号为1~N。下图给出了一个N＝4个顶点的多边形。


游戏规则
(1) 首先，移走一条边。
(2) 然后进行下面的操作：
选中一条边E，该边有两个相邻的顶点，不妨称为V1和V2。对V1和V2顶点所标的整数按照E上所标运算符号(+或是×)进行运算，得到一个整数；用该整数标注一个新顶点，该顶点代替V1和V2 。持续进行此操作，直到最后没有边存在，即只剩下一个顶点。该顶点的整数称为此次游戏的得分(Score)。

任务：给定一个多边形，顶点和边已按上述方式进行标注。问：按照游戏规则，最高得分(最优值)是多少？对应该最高得分，按照什么顺序移走边(最优解)？


下图对应的输入为：


4
t        -7      t        4       x       2       x       5
 


题目输入：
含多个测试用例
第一行为测试用例个数t
下面是t组用例
每个用例有两行：
第一行是一个整数N
第二行按照
边顶点边顶点…边顶点
的顺序以此存放了N个顶点和N条边的标注信息。其中字符t表示+，字符x表示×。

题目输出：
每个用例输出两行数据：
第一行是该游戏可能的最高得分。
第二行列出第一次移走哪条边(可能有多个, 如果是多个，则按照递增顺序排列)，会导致最高得分的出现。

输入样例：
1
4
t	-7	t	4	x	2	x	5

输出样例：
33
1 2
提示：




题目：Serial(1187)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
有一天，Panda发现了一个很有趣的数列1. a1的长度一直为12. a2的长度自己确定3. an (n > 2) = 2*a2*(an-1)-(an-2)于是他想问求前n项和。结果可能很大，模除m1 <= a2,m <= 10^9, 2 <= n <= 10^9
 
题目输入：
第一个数 case数量
下面每行3个数，a2,n,m


题目输出：
rt
输入样例：
3
2 3 100
1 4 1000
3 3 1000000000

输出样例：
54
4
299

提示：




题目：网络延时(1851)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　给定一个公司的网络，由n台交换机和m台终端电脑组成，交换机与交换机、交换机与电脑之间使用网络连接。交换机按层级设置，编号为1的交换机为根交换机，层级为1。其他的交换机都连接到一台比自己上一层的交换机上，其层级为对应交换机的层级加1。所有的终端电脑都直接连接到交换机上。
　　当信息在电脑、交换机之间传递时，每一步只能通过自己传递到自己所连接的另一台电脑或交换机。请问，电脑与电脑之间传递消息、或者电脑与交换机之间传递消息、或者交换机与交换机之间传递消息最多需要多少步。
题目输入：
　　输入的第一行包含两个整数n, m，分别表示交换机的台数和终端电脑的台数。
　　第二行包含n - 1个整数，分别表示第2、3、……、n台交换机所连接的比自己上一层的交换机的编号。第i台交换机所连接的上一层的交换机编号一定比自己的编号小。
　　第三行包含m个整数，分别表示第1、2、……、m台终端电脑所连接的交换机的编号。评测用例规模与约定
　　前30%的评测用例满足：n ≤ 5, m ≤ 5。
　　前50%的评测用例满足：n ≤ 20, m ≤ 20。
　　前70%的评测用例满足：n ≤ 100, m ≤ 100。
　　所有评测用例都满足：1 ≤ n ≤ 10000，1 ≤ m ≤ 10000。

题目输出：
输出一个整数，表示消息传递最多需要的步数。
输入样例：
4 2
1 1 3
2 14 4
1 2 2
3 4 4 4
输出样例：
44
提示：
样例说明
　　样例的网络连接模式如下，其中圆圈表示交换机，方框表示电脑：
 
　　其中电脑1与交换机4之间的消息传递花费的时间最长，为4个单位时间。样例说明　　样例的网络连接模式如下：
 
　　其中电脑1与电脑4之间的消息传递花费的时间最长，为4个单位时间。



题目：BirthdayGift(1330)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
At zlly's 20-th birthday party, WAVwind shows him a fancy sequence A1, A2, ..., AN. zlly is allowed to select NO MORE than M successive parts as his birthday gift.
It is natural that he wants to know the greatest sum of the selected elements. CAN YOU HELP HIM?
题目输入：
Line 1: two integers N (1 ≤ N ≤ 105) and M (0 ≤ M ≤ 105), the length of sequence and the number of parts can be selected.
Line 2: N integers A1, A2, ..., AN (0 ≤ |Ai| ≤ 104), the sequence.

题目输出：
An integer, the greatest sum.
输入样例：
5 2 
2 -3 2 -1 2

输出样例：
5
提示：




题目：任务调度1(1635)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
	ZLLY在公司实习的，有一个需求就是他们的项目需要有一个调度算法，来安排运行所需任务的运行顺序，以保证能把所有的程序能全部运行，当然也有一些程序是不能运行的。毕竟计算资源是有限的。现在要知道是不是能够让所有的任务都运行起来。需求场景是：项目运行的集群的有m个存储单元，每一任务i运行时需要占R[i]个空间，储存计算结果则需要占据O[i]个空间（其中O[i]<R[i]）。ZLLY想了想，就是不知道怎么做，于是求救于他的队友xiaoyoulei。Xiaoyoulei大叫一声：这都不会，你应该向NJUST_ACMers求救的。于是嘿嘿…ZLLY向你们求help来啦！！！
题目输入：
	为了保证让ZLLY老大信服。ZLLY要测试很多数据。所以第一行有一个正整数T(0<T<=100)表示有多少组测试数据。对于每一组数据第一行有2个整数N（0<=N<=10^6），M(0<=M<=10^9)表示（有N个任务，M表示有M个存储单元），接着有2行，每一行有N个整数.第1行整数表示相应任务的运行时需要占R[i]个空间，第2行表示相应任务的储存计算结果需要占O[i]个空间。
题目输出：
	对于每一组测试数据输出一行；如果能全部任务运行输出YES，否则NO。
输入样例：
2
2 14
8 10
5 6
2 10
5 10
4 6

输出样例：
YES
NO

提示：
None



题目：Squares(1537)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	A children's board game consists of a square array of dots that contains lines connecting some of the pairs of adjacent dots. One part of the game requires that the players count the number of squares of certain sizes that are formed by these lines. For example, in the figure shown below, there are 3 squares-2 of size 1 and 1 of size 2. (The ``size" of a square is the number of lines segments required to form a side.)						Your problem is to write a program that automates the process of counting all the possible squares.	
题目输入：
	The input file represents a series of game boards. Each board consists of a description of a square array ofn2 dots (where 2 <= n <= 9) and some interconnecting horizontal and vertical lines. A record for a single board with n2 dots and m interconnecting lines is formatted as follows:		Line 1:    n  the number of dots in a single row or column of the array	Line 2:     m  the number of interconnecting lines	Each of the next m lines are of one of two types:	H i j  indicates a horizontal line in row i which connects	the dot in column j to the one to its right in column j + 1	or	V i j  indicates a vertical line in column i which connects	the dot in row j to the one below in row j + 1		Information for each line begins in column 1. The end of input is indicated by end-of-file. The first record of the sample input below represents the board of the square above.	
题目输出：
			For each record, label the corresponding output with ``Problem #1", ``Problem #2", and so forth. Output for a record consists of the number of squares of each size on the board, from the smallest to the largest. lf no squares of any size exist, your program should print an appropriate message indicating so. Separate output for successive input records by a line of asterisks between two blank lines, like in the sample below.		
输入样例：
4
16
H 1 1
H 1 3
H 2 1
H 2 2
H 2 3
H 3 2
H 4 2
H 4 3
V 1 1
V 2 1
V 2 2
V 2 3
V 3 2
V 4 1
V 4 2
V 4 3
2
3
H 1 1
H 2 1
V 2 1
输出样例：
Problem #1

2 square (s) of size 1
1 square (s) of size 2

**********************************

Problem #2

No completed squares can be found.
提示：
None



题目：Apple的爱好(1088)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Apple勤奋学习，尤其对数字很感兴趣。如4=2^2，8=2^3，9=3^2等，因此他很想知道在不超过n的范围内有多少个这样的数m，m可以写成a^b (b>1)。你能帮助他吗？
题目输入：
第一行输入T个测试样例
以下T行每行输入一个数n（0 < n <= 10^8）

题目输出：
对于每个测试样例，输出相应的测试结果。
输入样例：
2
4
10

输出样例：
2
4

提示：




题目：Fish(1735)
时间限制：3000MS
空间限制：131072KB
题目描述：
	There're n fishes in a river holding a swimming match. The river just looks like x-axis, each fish has it's own start coordinate Xi, and heads towards the positive direction with the constant speed Vi. Between the match, transcendence will happen, it's specific definition is that: there're two fishes whose names are A and B, at a moment, A is ahead of B, but after a while, A is after B, that we call it transcendence. Now you need to calculate how many times does transcendence happen.	
题目输入：
	Multiple cases, end with EOF.		In each case, the first line is an integer n (1 < n < 10001), following with n lines, each line contains of two positive integers Xi, Vi (type of 32-bit signed integer), means the start point of each fish and its speed.	
题目输出：
	Print just one line for each case, means the times of transcendence.	
输入样例：
2

2 2

1 3

3

3 4

2 3

1 2

输出样例：
1


0

提示：
None



题目：LoveStoryIV(1433)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
In the Western Zhou Dynasty, there was an emperor called King You of Zhou. He had a concubine named Si Bao who was a stunning beauty. King You loved her very much, but she never smiled and just looked like an ice sculpture. On these days, there were also many nobles living on the country whose responsibilities were protecting their king. As the frontier was very vast, they were moving around different places. They used fireworks to send messages. One day, King You was very boring and wanted to play a trick to make Bao happy. The trick was played as following.There were N cities in the country, which are numbered from 1 to N. Some cities were separated by mountains and they were not connected. Those cities could reach to each other that we talked that there was an undirected path between the two cities for simplicity and the path had a value. Be careful there was exact one path between two different cities. The fireworks had an exact range of influence. When one firework was set out, the cities which included in the circle which center was the firework city were affected only if there was a path between the two cities.Now, King You wanted to affect all cities by the fireworks and he would to use minimum fireworks. It’s your job to calculate it and tell King You.
题目输入：
Input contains multiple test cases. The first line contains two integer N (1 < N <= 1000) and L (0 < L <= 10000) which is the firework’s affection radius. The following N – 1 lines each contains three integers u, v, l (1 <= u, v <= N, 0 < L <= 10000), which means there is path between city u and city v of length l.
题目输出：
For each case just output one line with a single integer that is the minimum number of fireworks.

输入样例：
3 1
1 2 2
1 3 1

输出样例：
2
提示：
We choose 1 and 2 in this case.



题目：开锁(1188)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
有一天，胡新杰听说鱼头办公室里有一本《魏冬冬难题》，想要去鱼头办公室里去拿，结果因为长得太抽象而被鱼头拒绝，当时胡新杰太饥渴那本书，于是顿时一想，想去偷，结果发现鱼头的锁很特别，锁是由一个环形的的字符串组成的，当然钥匙也是一个环形的只有当锁和钥匙的上的字符一一对应时，门才能打开，钥匙插上后，胡新杰可以旋转钥匙。胡新杰在一个地方配了一把这样的钥匙，现在胡新杰想知道他手上的钥匙能不能打开鱼头的门，拿到《魏冬冬难题》，由于这个时间的原因，所以他想让你帮帮他。
题目输入：
给你 2 个字符串 S1 , S2 ( 0 < 长度 < = 10^6 );(字母在 A ~ Z  );S1表示鱼头锁上面的字符串的相对顺序，S2表示胡新杰手上的钥匙上面的字符串的相对顺序。有多组case，每组case占2行。第一行是S1，第二行是S2。
题目输出：
如果胡新杰手上的钥匙可以打开门，输出YES，否则输出NO。

输入样例：
ABCA
AABC
AC
AB

输出样例：
YES
NO

提示：
take care of the length of the strings



题目：最小花费(1852)
时间限制：4.0s
空间限制：256.0MB
题目描述：
　　C国共有n个城市。有n-1条双向道路，每条道路连接两个城市，任意两个城市之间能互相到达。小R来到C国旅行，他共规划了m条旅行的路线，第i条旅行路线的起点是si，终点是ti。在旅行过程中，小R每行走一单位长度的路需要吃一单位的食物。C国的食物只能在各个城市中买到，而且不同城市的食物价格可能不同。
　　然而，小R不希望在旅行中为了购买较低价的粮食而绕远路，因此他总会选择最近的路走。现在，请你计算小R规划的每条旅行路线的最小花费是多少。
输入格式
题目输入：
　　第一行包含2个整数n和m。
　　第二行包含n个整数。第i个整数wi表示城市i的食物价格。
　　接下来n-1行，每行包括3个整数u, v, e，表示城市u和城市v之间有一条长为e的双向道路。
　　接下来m行，每行包含2个整数si和ti，分别表示一条旅行路线的起点和终点。评测用例规模与约定
　　前10%的评测用例满足：n, m ≤ 20, wi ≤ 20；
　　前30%的评测用例满足：n, m ≤ 200；
　　另有40%的评测用例满足：一个城市至多与其它两个城市相连。
　　所有评测用例都满足：1 ≤ n, m ≤ 105，1 ≤ wi ≤ 106，1 ≤ e ≤ 10000。
题目输出：
　　输出m行，分别代表每一条旅行方案的最小花费。
输入样例：
6 4
1 7 3 2 5 6
1 2 4
1 3 5
2 4 1
3 5 2
3 6 1
2 5
4 6
6 4
5 6
输出样例：
35
16
26
13
提示：
样例说明
　　对于第一条路线，小R会经过2->1->3->5。其中在城市2处以7的价格购买4单位粮食，到城市1时全部吃完，并用1的价格购买7单位粮食，然后到达终点。



题目：<。)#)))≦(1331)
时间限制：1000 ms
空间限制：65535 ms
题目描述：

Recently, fishhead gave a hard question to his son :here are a bunch of matches and please figure out the number of the matches.Hower the son was just in kindergarten so he could only count from 1 to 50.Because he was well cultivated from childhood and heard about the story of Hanxin and he knew you could do so as Hanxin.So he separated the matches with each pile of M matches and found that the number of the remaining matches was A.He tried N times with  different M value,and all the values of M and A were recorded.He came happily to ask you to help him figure out the number of the matches.
题目输入：
The first line is T indicating the number of test cases.
Each case contains N on the first line, Mi(1 <= i <= N) on the second line, and corresponding Ai(1 <= i <= N) on the third line.
All numbers in the input and output are integers.
1 <= T <= 100, 1 <= N <= 6, 1 <= Mi <= 50, 0 <= Ai < Mi

题目输出：
For each case output the least positive integer X which  he  was counting in the sample output format. if he was wrong ,output -1. 
输入样例：
2
2
14 57
5 56
5
19 54 40 24 80
11 2 36 20 76

输出样例：
Case 1: 341
Case 2: 5996

提示：




题目：任务调度2(1636)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
	正如大家所知项目一般是分为几期完成的，在Q1的时候ZLLY只要判断任务能不能全部完成，不过到了Q2的时候boss把难度变大了，他说每个任务是有收益的，存储单元是有限，那你们怎么安排这些任务去运行使得我们能得到最大的收益？能不能判断全部能运行ZLLY都不会，这个就更加难了，于是他又要向你们求助了！ 
题目输入：
	为了保证让ZLLY老大信服。ZLLY还是要测试很多数据。所以第一行有一个正整数T(0<T<=50)表示有多少组测试数据。对于每一组数据第一行有2个整数N（0<=N<=10^3），M(0<=M<=10^4)表示（有N个任务，M表示有M个存储单元），接着有3行，每一行有N个整数.第1行整数表示相应任务的运行时需要占R[i]个空间，第2行表示相应任务的储存计算结果需要占O[i]个空间。第3表示运行这个任务能收到的收益P[i].
题目输出：
	对于每一组测试数据输出一行；输出最大收益，如果不能运行任何任务输出0。
输入样例：
2
2 14
10 8
5 6
10 12
2 10
5 10
4 6
12 1

输出样例：
22
12

提示：
None



题目：RepeatingDecimals(1538)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
		The decimal expansion of the fraction 1/33 is  , where the   is used to indicate that the cycle 03 repeats indefinitely with no intervening digits. In fact, the decimal expansion of every rational number (fraction) has a repeating cycle as opposed to decimal expansions of irrational numbers, which have no such repeating cycles.			Examples of decimal expansions of rational numbers and their repeating cycles are shown below. Here, we use parentheses to enclose the repeating cycle rather than place a bar over the cycle.					 																					Write a program that reads numerators and denominators of fractions and determines their repeating cycles.							For the purposes of this problem, define a repeating cycle of a fraction to be the first minimal length string of digits to the right of the decimal that repeats indefinitely with no intervening digits. Thus for example, the repeating cycle of the fraction 1/250 is 0, which begins at position 4 (as opposed to 0 which begins at positions 1 or 2 and as opposed to 00 which begins at positions 1 or 4).																
题目输入：
	Each line of the input file consists of an integer numerator, which is nonnegative, followed by an integer denominator, which is positive. None of the input integers exceeds 3000. End-of-file indicates the end of input.	
题目输出：
	For each line of input, print the fraction, its decimal expansion through the first occurrence of the cycle to the right of the decimal or 50 decimal places (whichever comes first), and the length of the entire repeating cycle.	In writing the decimal expansion, enclose the repeating cycle in parentheses when possible. If the entire repeating cycle does not occur within the first 50 places (count from the first digit after  '(' ), place a left parenthesis where the cycle begins - it will begin within the first 50 places - and place ``...)" after the 50th digit.	Print a blank line after every test case.	
输入样例：
76 25
5 43
1 397
输出样例：
76/25 = 3.04(0)
   1 = number of digits in repeating cycle

5/43 = 0.(116279069767441860465)
   21 = number of digits in repeating cycle

1/397 = 0.(00251889168765743073047858942065491183879093198992...)
   99 = number of digits in repeating cycle
提示：
None



题目：IWannaMaximizetheProfit(1736)
时间限制：3000MS
空间限制：131072KB
题目描述：
	I am an employee of a processing plant. Every day, I go to the Smith’s and buy raw materials we need. But Mr. Smith sell his things with a strange style, which is, he only sell his customers a whole set of things, even those things are really strange when they match each other.		However, goods in Mr. Smith’s are really cheap and of high-quality. That’s why my boss wants me to buy things here. But my boss does not satisfy this. Every day he asks me, “How do these things match so we can make maximum profit?” Then I need to calculate the boring problem again and again. What’s worse, sometimes I make mistakes so that the profit does not come to the maximum. My boss gets very angry when this happens as if I have stolen his money. So I need a program to help me, or else I may be dismissed.		Mr. Smith always sell things like this: He gives me 3 kinds of materials A, B and C and each of them weighs a, b and c. Then I have to find which products our plant can produce using the three materials, and calculate how to maximize the profit.	
题目输入：
	There are about 100 test cases.		For each case, first line comes an integer n (n<50), which means there’re n kinds of products satisfying the material.		Then comes n lines, for each line there are four real numbers ai, bi, ci, di, which means one unit of the ith kind of product need ai A’s, bi B’s and ci C’s, and once it’s produced, there’re di income.		The last line of each case comes three real numbers a, b and c.(0<a, b, c<1e+9)		Input ends with n=0. All of the numbers will be positive and not exceed 1000, a, b, c, n excluded.	
题目输出：
	For each case, output one line including a real number representing the maximum profit, rounding up to two digits after the decimal point.
输入样例：
1
1 1 1 1
1 1 1
2
1 2 3 100
3 2 1 1
3 3 3
0

输出样例：
1.00
100.00

提示：
None



题目：迷宫抢救(1089)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
dreaming3000里的张大侠每次都会去他的女朋友那去，每次要发费很多钱，渐渐的他国库空虚，情急之下，在一个现实迷宫游戏公司当任一门电话导航员：在游客求救时，电话指导游客走出迷宫，当然被困游客如果能越早走出,对电话导航员的评价越高，那么他的奖金也就越高，张大侠不愧是参加过ACM的人，他想了想，这个可以写一个程序，但是他忙于dreaming3000的一个项目，没空去写，于是就向你求救。
迷宫设计者在迷宫的每一个地方设计了求救电话；当游客PLMM迷路时，可以通过电话进行求救，并且求救中心可以根据电话号码和这个求救时间得图1这种图形。并显示在电话导航员的电脑上，现在张大侠要知道这位游客PLMM在他的指导下最少要多少步才能走出迷宫，不能走出的话，请告诉他"Impossible"！
如果是通的话，游客在每一处都可以有8个方向选择去走。
现在电脑导航员的图片是如“图1”所示。
/*加图1*/

当然事先你要进行迷宫处理；美女位置用字符‘2’表示，不能走的地方用字符‘1’表示，能走的则用‘0’表示。处理后称之为 迷宫“012”图  。迷宫最多99行99列；
例如：
/*加图2*/

处理之后为：
0101010
1000101
1100010
1001201
1010110
1000001
0100100
题目输入：
第1行输入一个整数 n是表示PLMM求救人数，（测试n次）
下面是迷宫“012”图
以‘#’表示迷宫图处理完了。
题目输出：
对任意不大于99行99列的迷宫；能走出去的话输出最少步数；否则，请输出"Impossible",每一次求救，输出占一行；
输入样例：
3
0101010
1000101
1100010
1001201
1010110
1000001
0100100
#
011111
110201
101011
111111
#
1020110000001
0100111100000
#

输出样例：
The least step is:2
Impossible
The least step is:0
提示：




题目：LoveStoryV(1434)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
Daiyu Lin and Baoyu Jia are two principal characters of A Dream in Red Mansions. Lin is a well-educated and intelligent young woman who is portrayed in a highly sympathetic light. The romance between Daiyu and Baoyu forms one of the main threads of the book and in many readers' eyes, Lin is the book's leading lady. She hates excessive etiquette, so does Baoyu. Both Lin and Jia are same interest and dream, and they have been honesty to love.Today, they are playing the chess with a chessboard of N * M in size. They must obey the following rules: At first, some black pieces are put on the chessboard. The player should put the white pieces on the empty cells. Each time one should choose a circuit and put white pieces to occupy it. Be careful one cell doesn’t mean a circuit. At last, the chessboard will be full of pieces and has no empty cells. It’s guaranteed that it doesn’t contain an empty cell which is unreachable. They want to know how many ways to solve it.
题目输入：
Input contains multiple test cases. The first line contains two integers N and M (1 <= N, M <= 10). Each of the next N lines contains M numbers (either 0 or 1) separated by a space. Number 0 means a cell which is placed black piece and number 1 means an empty cell.
题目输出：
For each case just output one line with the number of ways. It’s guaranteed that it does not exceed 2^63 – 1.
输入样例：
6 3
1 1 1
1 0 1
1 1 1
1 1 1
1 0 1
1 1 1

输出样例：
3
提示：




题目：集训队专业杀系列-珂神(1189)
时间限制：20000 ms
空间限制：65535 ms
题目描述：
最近小柯柯同学发现三国杀很好玩，就用它的YY神功YY了一套集训队专业杀。今天，让我们看看其中的一个人物： 千王之王——张珂。（见下图:）

他有两个技能：
智囊：将连续一段牌抽出再放入第K张牌后面。比如牌堆总共8张牌1,2,3,4,5,6,7,8，牌堆初始的时候一定是顺序排的，现在张珂用第一个技能：ZHINANG  3  5  4,即把3~5位置的牌抽出，牌堆为1,2,6,7,8，再放到第4张牌后面，牌堆变为1,2,6,7,3,4,5,8。
神机：将连续一段牌反序，例如在上面的基础上运用第二招技能SHENJI  2 6，即把2~6位置的牌反置，变为1,4,3,7,6,2,5,8。
现在，我们的小柯柯用了好多次技能后，不知道牌堆变成什么了。你能帮他解决吗？
题目输入：
 第一行为两个整数N,M，表示牌堆有N张牌，小柯柯共用了M次技能。（1< = N , M < = 300000）。下面接着M行，每行是一次技能使用，ZHINANG  a  b  c,
1 < = a< = b < = n, 0 < = c < = n - ( b - a + 1 ).    或者 SHENJI  a  b  1< = a < = b < = n。
N = M = -1 表示输入结束。

题目输出：
一行，M次技能后将牌堆的牌输出，具体见样例。

输入样例：
8 2
ZHINANG 3 5 4
SHENJI 2 6
-1 -1

输出样例：
1 4 3 7 6 2 5 8

提示：




题目：ARR3(1853)
时间限制：None
空间限制：None
题目描述：
定义一个数组类ARR，求一个整型数组所有元素中最大值以及该最大值在数组中的下标（从0开始），具体要求如下：（1）私有成员：int n;//数组实际元素个数int a[100];//存放数组元素int Max,MaxIndex;//存放数组元素的最大值和最大值下标。（2）公有成员：ARR(int x[],int size);//构造函数，用参数size初始化n，用x数组初始化a数组。void FindMax();//求整型数组元素中的最大值及最大值的序号。void Show();//输出整型数组元素中的最大值及最大值的序号。（3）在主函数完成对该类的测试。
题目输入：
第一行输入一个t，代表t组测试数据，输入一个n，代表数组的大小，然后输入n个数。
题目输出：
输出整型数组元素中的最大值及最大值的序号
输入样例：
173 4 6 8 10 34 2
输出样例：
34 5
提示：
None



题目：MealsonWheelsRoutingSystem(1539)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	The Meals on Wheels program has the responsability for providing hot meals to homebound senior citizens within the city. Volunteer drivers deliver the meals in a timely manner to ensure that they are still hot on arrival. The list of customers for meals and the number of available drivers varies on a daily basis. For each day, management tries to assign drivers routes so that allocation of customers is as even as possible among the routes.	An algorithm for developing the daily routes involves sorting the addresses of the meal customers based on the directions of their locations relative to the Meals on Wheels headquarters and dividing this sorted list among the available drivers. The Meals on Wheels headquarters is considered to be located at the origin on a cartesian grid of square city blocks. Each customer's address has been converted into the number of city blocks in the x and y directions from the Meals on Wheels facility. For example, a customer living at location (3,-2) would be living 3 blocks east and 2 blocks south of the Meals on Wheels headquarters.	Write a computer program to determine routing for several different days. For each day, your program will read in the number of drivers (routes) and number of customers followed by sets of names and locations for the customers. Allocate customers to routes using the following strategy.	Find the polar coordinate of each customer's location. Consider 0  to be due east and 90  to be due north.	Sort the sets of polar coordinates by angle and then divide the customers as equally as possible among the available routes starting at the angle of smallest measure.	Routes with customers at high degree angles should not have more customers than those for customers of lower degree angles.	If two customers are at the same angle, then assign the customer nearer to the Meals on Wheels headquarters before you assign the one further away.	The difference in the number of customers assigned to any two routes may not exceed one.	Your program will determine not only the route for each driver but also the total length of each route. The length of any route includes the sum of the distances from the Meals on Wheels headquarters to the first customer, plus the distances between subsequent customers, plus the distance back to the headquarters from the last customer on the route. Note that a block may not be traversed diagonally, and all city blocks are squares.	
题目输入：
	Input consists of multiple data sets in which the first line is a data set ID and the second line contains the number of routes followed by the number of customers. The remaining lines of the data set are arranged in pairs, one pair per customer. The first line of each pair is the customer's name and the second line contains the x and y coordinates of where that customer lives. Assume that no two customers live on the same position and that no customer lives in (0,0). So each data set is arranged in the following manner.		Line l: data set ID             (string - maximum length 50 characters)	Line 2: n m (1<=n,m<=100000) (number of routes  number of customers - positive integers)	The next 2m lines come in pairs:	Line 3: customer name           (string - maximum length 25)	Line 4: x-coordinate y-coordinate (x and y coordinates for the preceding customer - integers)		Assume the input is correct and the number of routes does not exceed the number of customers. The end of input is indicated by end-of-file.	
题目输出：
	For each data set your output should include the data set ID, the number of customers, the number of routes, the routes of customers in order along with their corresponding route lengths, and the total route length for all routes in this data set. Print a row of asterisks between output for successive data sets.	
输入样例：
Sample Route List 1
4 10
able
1 2
baker
-3 6
charlie
-4 -5
donald
4 -7
eloise
3 4
frank
2 2
gertrude
5 9
horace
-2 -5
inez
5 -3
james
0 1
Sample Route List 2
1 1
charlie
1 1

输出样例：
Sample Route List 1
Number of Customers: 10         Number of Routes: 4

Route ==> 1
Customer: frank
Customer: eloise
Customer: gertrude
Route Length ==> 28

Route ==> 2
Customer: able
Customer: james
Customer: baker
Route Length ==> 22

Route ==> 3
Customer: charlie
Customer: horace
Route Length ==> 18

Route ==> 4
Customer: donald
Customer: inez
Route Length ==> 24

Total Route Length ==> 92
***********************************
Sample Route List 2
Number of Customers: 1          Number of Routes: 1

Route ==> 1
Customer: charlie
Route Length ==> 4

Total Route Length ==> 4

提示：
None



题目：士兵出击(1637)
时间限制：5000 ms
空间限制：65535 ms
题目描述：
			ZLLY从小就有一个梦想:就是想要去参军，当然现在看来是不可能了。不过ZLLY还是没有放弃这个想法，一天晚上他看完电视睡觉的时候，做了一个梦，他参军啦，而且还是一个参谋，并且被任命了一个很重要的任务，就是在一排很长升高参差不齐的队伍里选出一个支升高有序并且战斗力之和最大的队伍是参加联合军演。由于士兵有恋旧的情节，如果士兵A一开始排在士兵B的后面且A,B都能选上的话，A还是要在B的后面，（即A,B的相对顺序不变）。当然出去军演，面子和实力多很重要，所以ZLLY的上司就想在选出队伍身高不减的情况下选出一个支战斗力最强的队伍出来，并且让他的参谋们（ZLLY就是其中一个）给出他们能选出战斗力最大的值。作为NJUST ACMer出身的ZLLY不由的暗暗惊喜，还好当年大学无聊去参加了ACM，没让自己白过。不过从军多年，ZLLY已经不知道怎么去写程序了，所以他向现在还是NJUST ACMers求救，来帮助他完成，好让他能在上司面前表现一番。 	
题目输入：
	军队是个很严的组织，不允许任何差错，所以ZLLY想了很多数据来测试你们帮他写的程序，这样保证他不会在他上司面前出丑。	第一行是一个正整数T(0<T<50),表示有ZLLY为你们准备多少组的数据，嘿嘿。对于每一组数据。第一行有一个正整数N(0<=N<10^6)表示有一列由N个士兵的组成的队伍让你去选择。接下来有2行由N个正整数Hi(0<Hi<10^8 nm)，Fi（0<Fi<10^9）分别表示第i个士兵的身高和战斗力。
题目输出：
	对于每一组测试数据，你要输出你能选择出要求的最大战斗力的值(所选士兵战斗力之和)。每组占一行。
输入样例：
2
4
10 20 30 40
1 2 3 4
3
10 40 2
15 16 20

输出样例：
10
31

提示：
None



题目：Thegreatestsum(1332)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
There is a sequence A1, A2, ..., AN. You can only select a successive part. Then what is the greatest sum of the select part.
题目输入：
Line 1: A integer N (1 ≤ N ≤ 10^6)), the length of sequence
Line 2: N integers A1, A2, ..., AN (-100<=Ai<=100), the sequence.

题目输出：
An integer, the greatest sum. 
输入样例：
10
-1 8 -1 8 -3 2 -4 4 -7 6

输出样例：
15

提示：




题目：LoveStoryVI(1435)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
We all have watched the famous TV series “Princess Pearl”, and I won’t summarize the story as I think it is very nc.One day, Yongqi and Xiaoyanzi are riding horses on the prairies. Xiaoyanzi commands Yongqi to build a fence. A closed fence in the plane is a set of non-crossing, connected line segments with N corners. The corners or vertices are each distinct and are listed in counter-clockwise order in an array {xi, yi} (1 <= I <= N). Every pair of adjacent vertices defines a side of the fence. Thus {xi, yi, xi+1, yi+1} is a side of the fence for all i in (1..N). When N+1 = 1, the first and last vertices make the fence closed. Yongqi wants to know the ordered list of vertices {xi, yi} to build a fence whether it is a valid fence. Xiaoyanzi wants to find the set of fence sides that herself (ignoring her height) who is standing in the plane at position (x, y) can "see" when looking at the fence. The location (x, y) may fall anywhere not on the fence.A fence side can be seen if there exists a ray that connects (x, y) and any point on the side, and the ray does not intersect any other side of the fence. A side that is parallel to the line of sight is not considered visible.
题目输入：
Input contains multiple test cases. The first line contains one integer N which is the number of corners in the fence. The second line contains two integers x and y which is the location of Xiaoyanzi. The next n lines all contains two integers x and y, that are the location of the fences. The pairs are given in counterclockwise order. Both integers are no larger than 1000 in magnitude.
题目输出：
If the sequence is not a valid fence, the output is a single line containing the word "NC".
Otherwise, the output is a listing of visible fence segments, one per line, shown as four space-separated integers that represent the two corners. Express the points in the segment by showing first the point that is earlier in the input, then the point that is later. Sort the segments for output by examining the last point and showing first those points that are earlier in the input. Use the same rule on the first of the two points in case of ties.

输入样例：
13
5 5
0 0
7 0
5 2
7 5
5 7
3 5
4 9
1 8
2 5
0 9
-2 7
0 3
-3 1 

输出样例：
7
0 0 7 0
5 2 7 5
7 5 5 7
5 7 3 5
-2 7 0 3
0 0 -3 1
0 3 -3 1

提示：




题目：PlaytheDice(1737)
时间限制：2000 MS
空间限制：65535 MB
题目描述：
There is a dice with N sides, which are numbered from 1,2,...,n and have the equal possibility to show up when one rolls a dice. Each side has an integer Ai on it. Now here is a game that you can roll this dice once, if the i-th side is up, you will get Ai yuan. What's more, some sids of this dice are colored with a special different color. If you turn this side up, you will get once more chance to roll the dice. When you roll the dice for the second time, you still have the opportunity to win money and rolling chance. Now you need to calculate the expectations of money that we get after playing the game once.
题目输入：
Input consists of multiple cases. Each case includes two lines. End with EOF.The first line is an integer N (2<=N<=200), following with N integers Ai(0<=Ai<200)The second line is an integer M (0<=M<=N), following with m integers Bi(1<=Bi<=n), which are the numbers of the special sides to get another more chance.
题目输出：
Just a real number which is the expectations of the money one can get, rounded to exact two digits. If you can get unlimited money, print "inf" a line without double quotes.
输入样例：
6 1 2 3 4 5 6
0
4 0 0 0 0
1 3

输出样例：
3.50
0.00

提示：
None



题目：NamePK(1090)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Name PK is a funny game on the Internet. The game will calculate a person's characteristic according to his name.Now we're simulating a simple Name PK game. Each person has a parameter “attacking” which represents his ability to attack others.For a name with length N, name[i] is the i-th letter of the name.We define F(c). Suppose c is a lowercase letter, and F(c) is the ordinal rank of c in the alphabet. For example F(‘a’) = 1 , F(‘b’) = 2, and so on…Attacking =	Now you will be given two names, your task is to calculate their attacking ability and tell me who will win.
题目输入：
The input consists of several test cases. The first line is an integer T (T ≤ 1000), indicating the number of test cases. Each test case is on a separate line, including two strings separated by a whitespace, indicating the name of each person.Each name contains only lowercase letters in English with the length between 1 and 20.
题目输出：
For each case, output two lines. In the first line, please report the attacking ability of each person respectively, remaining the same order as the input. In the second line, output the result of the first person: “win”, “lose” or “tie”.
输入样例：
1
dalong chiara
输出样例：
14 46
lose
提示：
None



题目：种花(1333)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
         最近xiaoyoulei迷恋上了种花，他在活动室外面的小花圃里开辟了n*m块花地，每块地大小5*5cm，（1cm*1cm用一个字母表示）。他买了2种不同种类的花来种。第一种花占一块地(5*5cm)，能带来a点的芳香值，第二种花占地2*4块(10*20cm)，能带来b点的芳香值，但只能种在左上角坐标为（2*p+1，4*q+1）的土地上（花圃左上角坐标为（1,1））。因土地的土壤不同，不是每块地都能种花。1号土地表明只适合种第一种花，2号土地表明只适合种第二种花，3号土地表明2种花都能种。0号土地表明不适合种花。现在xiaoyoulei要使整个花圃的芳香值最大，他想知道如何安排，使花圃芳香值最大。若芳香值同样大，使第二种花尽量多。
一块土地(5*5cm)用
=====
=====
=====
=====
=====
表示
第一种花为
.*. 
 *** 
  V  
/\|/\
  |  
  |  
种在1块(5*5cm)土地上，效果为
.*.
=***=
==V==
/\|/\
==|==
==|==
 
第二种花为
         {@}
      {@} * {@}
   {@} * {@} * {@}
{@}* {@} * {@} * {@}
 \ {@} * {@} * {@} /
    \ \ \ l / / /
     \\ \ Y / //
       \\ l //
        \\Y// 
         >=<  
        //*\\
种在2*4块(10*20cm)土地上，效果为
         {@}        
======{@}=*={@}=====
==={@}=*={@}=*={@}==
{@}*={@}=*={@}=*={@}
=\={@}=*={@}=*={@}=/
====\=\=\=l=/=/=/===
=====\\=\=Y=/=//====
=======\\=l=//======
========\\Y//=======
=========>=<========
========//*\\=======
题目输入：
多组测试数据
每组数据如下
2个整数100>=n>=1,100>=m>=1，代表土地大小，n%2==0，m%4==0。1*1为一块土地
2个整数100>a>0,100>b>0，代表芳香值。
N*m的矩阵，描述土地的土壤情况，i表示是第i种土壤。 

题目输出：
花圃的方案，一个5n*5m或(5n+1)*5m的矩阵
每组数据后输出一行空行

输入样例：
4 4
1 8
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
4 4
1 8
2 2 2 2
2 2 2 2
0 0 0 0
0 0 0 0
4 4
1 8
0 1 2 3
3 2 1 0
3 2 2 2
2 2 2 2
4 4
1 8
0 0 0 0
3 2 2 3
3 3 3 3
3 0 3 3


输出样例：
 .*.                
=***================
==V=================
/\|/\===============
==|=================
==|=================
====================
====================
====================
====================
====================
====================
====================
====================
====================
====================
====================
====================
====================
====================
====================

         {@}        
======{@}=*={@}=====
==={@}=*={@}=*={@}==
{@}*={@}=*={@}=*={@}
=\={@}=*={@}=*={@}=/
====\=\=\=l=/=/=/===
=====\\=\=Y=/=//====
=======\\=l=//======
========\\Y//=======
=========>=<========
========//*\\=======
====================
====================
====================
====================
====================
====================
====================
====================
====================
====================

      .*.       .*. 
======***=======***=
=======V=========V==
=====/\|/\=====/\|/\
=======|=========|==
=.*.===|===.*.===|==
=***=======***======
==V=========V=======
/\|/\=====/\|/\=====
==|=========|=======
==|======{@}|=======
======{@}=*={@}=====
==={@}=*={@}=*={@}==
{@}*={@}=*={@}=*={@}
=\={@}=*={@}=*={@}=/
====\=\=\=l=/=/=/===
=====\\=\=Y=/=//====
=======\\=l=//======
========\\Y//=======
=========>=<========
========//*\\=======

====================
====================
====================
====================
=.*.============.*.=
=***============***=
==V==============V==
/\|/\==========/\|/\
==|==============|==
=.*.==.*.==.*.==.*.=
=***==***==***==***=
==V====V====V====V==
/\|/\/\|/\/\|/\/\|/\
==|====|====|====|==
=.*.===|===.*.==.*.=
=***=======***==***=
==V=========V====V==
/\|/\=====/\|/\/\|/\
==|=========|====|==
==|=========|====|==



提示：
1输出时下面的花能挡住上面的花
2把样例粘贴到记事本中看比较清楚




题目：最长递增点序列(1190)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
有一个2维坐标系(0 < x  < = 20, 0 < y < = 20  )，现在给你n ( 0 < n < = 100000 ) 个整数点组成的一个排列，要求求出n个点的一个子集。子集中的点相对位置不能变，且前一个点要小于后一个点。点p1 < 点p2 当且仅当p1.x < = p2.x && p1.y <= p2.y。要求输出这个子集包含的最大点个数。
题目输入：
第一行输入测试数据数目T。
对于每组数据：
3个整数x,y,n
接下来n行每行2个数pi.x,pi.y(都大于等于0，且在方格内）)

题目输出：
子集包含的最大点个数。
输入样例：
1
3 3 5
1 1
2 2
1 2
2 1
2 2

输出样例：
3

提示：




题目：Firetruck(1540)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	The Center City fire department collaborates with the transportation department to maintain maps of the city which reflects the current status of the city streets. On any given day, several streets are closed for repairs or construction. Firefighters need to be able to select routes from the firestations to fires that do not use closed streets.	Central City is divided into non-overlapping fire districts, each containing a single firestation. When a fire is reported, a central dispatcher alerts the firestation of the district where the fire is located and gives a list of possible routes from the firestation to the fire. You must write a program that the central dispatcher can use to generate routes from the district firestations to the fires.	
题目输入：
	The city has a separate map for each fire district. Streetcorners of each map are identified by positive integers less than 21, with the firestation always on corner #1. The input file contains several test cases representing different fires in different districts.	The first line of a test case consists of a single integer which is the number of the streetcorner closest to the fire.	The next several lines consist of pairs of positive integers separated by blanks which are the adjacent streetcorners of open streets. (For example, if the pair 4 7 is on a line in the file, then the street between streetcorners 4 and 7 is open. There are no other streetcorners between 4 and 7 on that section of the street.)	The final line of each test case consists of a pair of 0's.	
题目输出：
							For each test case, your output must identify the case by number (CASE #1, CASE #2, etc). It must list each route on a separate line, with the streetcorners written in the order in which they appear on the route. And it must give the total number routes from firestation to the fire. Include only routes which do not pass through any streetcorner more than once. (For obvious reasons, the fire department doesn't want its trucks driving around in circles.)				Output from separate cases must appear on separate lines.				The following sample input and corresponding correct output represents two test cases.							
输入样例：
6
1 2
1 3
3 4
3 5
4 6
5 6
2 3
2 4
0 0
4
2 3
3 4
5 1
1 6
7 8
8 9
2 5
5 7
3 1
1 8
4 6
6 9
0 0
输出样例：
CASE 1:
1 2 3 4 6
1 2 3 5 6
1 2 4 3 5 6
1 2 4 6
1 3 2 4 6
1 3 4 6
1 3 5 6
There are 7 routes from the firestation to streetcorner 6.
CASE 2:
1 3 2 5 7 8 9 6 4
1 3 4
1 5 2 3 4
1 5 7 8 9 6 4
1 6 4
1 6 9 8 7 5 2 3 4
1 8 7 5 2 3 4
1 8 9 6 4
There are 8 routes from the firestation to streetcorner 4.
提示：
None



题目：ARR2(1854)
时间限制：None
空间限制：None
题目描述：
定义一个类ARR，求一个整型数组中正数和负数的个数，具体要求如下：（1）私有成员：int n;//数组实际元素个数int a[100];//存放数组元素int pos;//存放数组中正数的个数int neg;//存放数组中负数的个数（2）公有成员：ARR(int x[],int size);//构造函数，用参数size初始化n，用x数组初始化a数组，将pos和neg初始化为0void Num();//求正数和负数的个数void Show();//输出正数和负数的个数（3）在主函数内完成对该类的测试。
题目输入：
第一行输入一个t，代表t组测试数据，接下来输入一个n，代表数组x的大小，然后输入n个数
题目输出：
输出正数和负数的个数
输入样例：
251 2 -3 -4 54-1 2 -3 4
输出样例：
3 22 2
提示：
None



题目：图像识别(1638)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
	某熊掌公司的文字搜索再国内做的不错，一天，ZLLY和xiaoyoulei讨论图像搜索是不是也应该会慢慢发展起来，当然对于水平很水的ZLLY和xiaoyoulei来说，比较难得图像搜索是不会的。他们讨论啊讨论啊，对于图像的精确匹配这个比较简单的问题都还是没有解决方案，于是ZLLY跟xiaoyoulei夸下海口，给他一定时间，他能实现图像精确匹配。虽然海口夸出去了，不过ZLLY还是不能解决。于是他一想，不怕，他有强大的后援团-NJUST ACMers，于是他向你们求救。你们能帮帮他吗？	图像精确匹配：如果图像A是图像B的一部分或者和B是一样的，则说明A精确匹配B。
题目输入：
	大家都知道图像其实是由一个像素组成，像素的值和排列的序列决定了图像的外观，方便你们处理，ZLLY将图片转换成一个对应的2维字符串表，方便你你们处理。因为有多组图片，于是第一行是一个正整数n，表示有多少组。然后输出2个正整数tn和tm，表示图像B是由一个tn行tm列的字符串矩阵表示。接着tn行来输出这个字符串矩阵。接着是2个正整数pn,pm. 示图像A是由一个pn行pm列的字符串矩阵表示。接着输出图像A的信息。	    1<n<=100;1<tn,tm,pn,pm<1024,字符串矩阵由‘a’-‘z’字符组成。
题目输出：
	对于每一对图像，如果图像A是图像B的一部分，则输出YES，否则输出NO。
输入样例：
2
3 4
qwer
asde
qwer
1 2
sd
2 2
aa
bb
2 1
a
c

输出样例：
YES
NO

提示：
None



题目：LoveStoryVII(1436)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
Xian Xu and Suzhen Bai met each other in a rainy day and fell in love at the first time. Although West Lake is very beautiful in rainy days, but it is not convenient for these ones who want have a date.You are the God of Wind. By moving a big cloud around, you can decide the weather: it invariably rains under the cloud, and the sun shines everywhere else. But you are a benign God: your goal is to give enough rain to every field in the countryside, and sun to markets and festivals. To simplify this problem, this field is constituted of 4 x 4 square areas, denoted by their numbers (from 1 to 16 from left to right and from first line to the last). Your cloud is of size 2 x 2, and may not cross the borders of the country. You are given the schedule of the couples’ date time. On each of the following days, you may move your cloud by 1 or 2 squares in one of the four cardinal directions (North, West, South, and East), or leave it in the same position. Diagonal moves are not allowed. All moves occur at the beginning of the day. On the first day of the period, it is raining in the central areas (6-7-10-11), independently of the schedule. 
You should not leave an area without rain for a full week (that is, you are allowed at most 6 consecutive days without rain). You don't have to care about rain on days outside the period you were given: i.e. you can assume it rains on the whole field the day before the period, and the day after it finishes. 

题目输入：
Input contains multiple test cases. A data set gives the number N of days (no more than 365) in the period on a single line, followed by N lines giving the schedule. The i-th line gives the schedule for the i-th day. It is composed of 16 numbers, either 0 or 1, 0 standing for a normal day, and 1 a date day. The field which is 1 cannot rain when you prepare it. The numbers are separated by one or more spaces. 
题目输出：
The answer is a 0 or 1 on a single line for each data set, 1 if you can satisfy the couple, 0 if there is no way to do it.
输入样例：
15
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0
0 0 1 1 0 0 0 0 0 1 0 0 0 0 0 0
1 1 0 0 0 0 0 0 0 0 1 0 0 1 0 0
0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0
1 0 0 1 1 0 0 0 0 1 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0
0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0

输出样例：
1
提示：




题目：TWONODES(1738)
时间限制：10000 MS
空间限制：65535 KB
题目描述：
	Suppose that G is an undirected graph, and the value of  stab is defined as follows:		Among the expression, G-i,-j  is the remainder after removing node i, node j and all edges that are directly relevant to the previous two nodes.cntCompent(X)  is the number of connected components of X independently.	Thus, given a certain undirected graph G, you are supposed to calculating the value of stab .
题目输入：
	Input consists of multiple cases.	The input will contain the description of several graphs. For each graph, the description consist of an integer N for the number of nodes, an integer M for the number of edges, and M pairs of integers for edges (3<=N,M<=5000).	Please note that the endpoints of edge is marked in the range of [0,N-1], and input cases ends with EOF.
题目输出：
	For each graph in the input, you should output the value of  stab.
输入样例：
4 5
0 1
1 2
2 3
3 0
0 2

输出样例：
2

提示：
None



题目：Addnumber(1091)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Employees of Baidu like to play a game called Making Numbers. It goes like this: there are two players in the game, one is called little A, the other little B. There are some cards with a number on each one of them, little A chooses a number X from 1 to N randomly, while little B has to choose some cards, the sum of which equals X. Now there are already M cards with numbers, and K blank cards. At the beginning of the game, little B is allowed to write numbers on the blank cards. Now little B wants to know, if it is possible to write some numbers that will assure him of the victory, that is to say, if it is possible for him to make up any number from 1 to N with the cards.
题目输入：
The input consists of several test cases. The first line is an integer T , in the second line of each case are 3 numbers, N M K, the second line shows the number that is already written on M cards. 0
题目输出：
If little B can make it, output "YES", else output "NO".
输入样例：
3 
15 0 4
12 3 2
3 3 3
13 3 2
3 3 3
输出样例：
YES
YES
NO
提示：
None



题目：robots(1334)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
After many years, robots have become very intellective and popular. Dreaming3000 Corporation is a big company that produces service robots. In order to guarantee the safety of production, each robot has an unique number (each number is selected from 1 to N and will be recorded when the robot is produced). 
 But one day we found that N+1 robots have been produced in the range of 1 to N , that’s to say one number has been used for 2 times. Now the president of Dreaming3000 Corporation hopes to find the reused number as soon as possible. 
 
题目输入：
N represents the maximum number.  The next line has N +1 numbers. (All numbers are between 1 to N, and only two of them are the same.) (1 <= N <= 10 ^ 6) 
题目输出：
Output the reused number. 
输入样例：
2
2 1 2

输出样例：
2
提示：




题目：Choosethefriends(1191)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
SB J准备进行一场party。但是名额有限，他的朋友甚多，他想让这场party的娱乐度最高，想你帮他得出一种最优方案。他的朋友中有B个男生，G个女生。每一个人都有一个值，代表参加将会给party带来的娱乐值。但是还有一个问题，有些男生个女生不能同时来，由于某些特殊的关系。
题目输入：
第一行，case 数（<=10）
对于每一个case：
B,G<=100
第一行：B，G男生数（编号1……B），和女生数（编号1……G）。
第二行有B个数正整数，分别为B个男生的娱乐度
第三行有G个数正整数，分别为G个女生的娱乐度
第四行一个整数M
接下来M行每行两个整数a，b，代表编号为a的男生和编号为b的女生不能同时来。
(M个中不包含重复的约束)

题目输出：
每一个case一行：最高娱乐值。
输入样例：
2
1 1
2 
3
1
1 1
2 2  
1 2  
3 4 
2 
1 2 
2 1  

输出样例：
3
7


提示：




题目：TriangularVertices(1541)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	Consider the points on an infinite grid of equilateral triangles as shown below:						Note that if we number the points from left to right and top to bottom, then groups of these points form the vertices of certain geometric shapes. For example, the sets of points {1,2,3} and {7,9,18} are the vertices of triangles, the sets {11,13,26,24} and {2,7,9,18} are the vertices of parallelograms, and the sets {4,5,9,13,12,7} and {8,10,17,21,32,34} are the vertices of hexagons.	Write a program which will repeatedly accept a set of points on this triangular grid, analyze it, and determine whether the points are the vertices of one of the following ``acceptable" figures: triangle, parallelogram, or hexagon. In order for a figure to be acceptable, it must meet the following two conditions:		1)	Each side of the figure must coincide with an edge in the grid.		2)	All sides of the figure must be of the same length.	
题目输入：
	The input will consist of an unknown number of point sets. Each point set will appear on a separate line in the file. There are at most six points in a set and the points are limited to the range 1..32767.	
题目输出：
	For each point set in the input file, your program should deduce from the number of points in the set which geometric figure the set potentially represents; e.g., six points can only represent a hexagon, etc. The output must be a series of lines listing each point set followed by the results of your analysis.	
输入样例：
1 2 3
11 13 29 31
26 11 13 24
4 5 9 13 12 7
1 2 3 4 5
47
11 13 23 25
输出样例：
1 2 3 are the vertices of a triangle
11 13 29 31 are not the vertices of an acceptable figure
26 11 13 24 are the vertices of a parallelogram
4 5 9 13 12 7 are the vertices of a hexagon
1 2 3 4 5 are not the vertices of an acceptable figure
47 are not the vertices of an acceptable figure
11 13 23 25 are not the vertices of an acceptable figure
提示：
None



题目：Array(1855)
时间限制：None
空间限制：None
题目描述：
试定义一个类Array，对一个数组中的元素按其绝对值从大到小排序，并选取其中前m个元素输出。具体要求如下：（1）私有成员：int *p,n;//p为数组的首地址，n为数组元素的个数。（2）公有成员：Array(int *t,int m);//构造函数，用数组t的m个元素初始化数据成员p，用m初始化数据成员nvoid fun();//将数组p的元素按其绝对值从大到小排序。void print(int m);//输出数组p的前m个元素~Array();//析构函数，释放构造函数动态开辟的存储空间。（3）在主函数中对类Array进行测试。
题目输入：
第一行输入一个t，代表t组数据，接下来输入一个n，代表数组的大小，然后输入n个数，在输入一个m，代表要输出的m个数
题目输出：
输出数组p的前m个元素
输入样例：
28-5 -4 -3 -2 1 6 7 8531 -2 32
输出样例：
8 7 6 -5 -43 -2
提示：
None



题目：LoveStoryVIII(1437)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
We all know the story between Houyi and Chang'e. The following story you may not know.One day Houyi organized a running team consists of N (1 <= N <= 20) runners. They wish to determine a race strategy which will get one of them across the finish line as fast as possible. They run in packs because that's the most efficient way to beat the wind. While travelling at x laps/minute (x is always an integer), the head of the pack expends x*x energy/minute while the rest of pack drafts behind him using only x energy/minute. Switching leaders requires no time though can only happen after an integer number of minutes. Of course, they can drop out of the race at any time. They have entered a race D (1 <= D <= 100) laps long. Each one has the same initial energy, E (1 <= E <= 100). What is the fastest possible finishing time? Only one has to cross the line. The finish time is an integer. Overshooting the line during some minute is no different than barely reaching it at the beginning of the next minute (though the one must have the energy left to cycle the entire minute). N, D, and E are integers.
题目输入：
A single line with three integers: N, E, and D 
题目输出：
A single line with the integer that is the fastest possible finishing time for the fastest possible person. Output 0 if they are not strong enough to finish the race. 
输入样例：
3 30 20
输出样例：
7
提示：




题目：文件编译依赖(1639)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
ZLLY最近在写一个C语言项目，因为条件所限，买不起微软的IDE编译环境和操作系统，他只能在免费的开源liunx上开发项目，没有图形界面来管理项目，ZLLY看代码很不方便。在写文件包含很让他头疼，他会发现他写的项目在编译的时候，机器会死机，找别人一问，才知道是文件包含死循环了，即A文件要包含B，B文件又要包含A文件。这样会出现死循环，，ZLLY很害怕这种情况，于是ZLLY找到了被ACM搞的你，帮他写一个程序来判断他的文件包含的情况，如果有文件包含死循环了，你要给ZLLY一个大大的NO。否则你可以给他一个大大的YES安慰他伤心的心灵。
题目输入：
	 	听说了ZLLY想你们求救的时候，ZLLY很多同学是新手，所以顺便也想让ZLLY帮他们测下他们们的项目，所以ZLLY给你的输入文件，第一行是一个整数n表示有那个项目要你的程序帮忙测试。(case 数)	文件包含的信息ZLLY写了一个简单的程序把文件的位置和文件依赖的文件输出来了，对于每一个项目第一行输出一个整数num，表示这个项目有num个文件包含信息。对于每一个文件包含信息，第一行（SonLile）一个文件的路径和名字（整个长度不会超过255个字节），第二行是其所要包含文件的数目整数DependentFileNumber,接下来有DependentFileNumber行表示其包含文件的路径和名字(FatherLine)（当然ZLLY写的代码不是很好，可能会出现一个文件或者文件夹是不存在的，你要忽略哦）。方便理解我们写一个列子。 	/home/zhuli/src/main.h  -----------SonLine  	3 	/home/zhuli/include/a1.h ------------ FatherLine 	/home/zhuli/include/a2.idl ------------ FatherLine 	/home/zhuli/include/afile/b.h ------------ FatherLine 	表示文件main.h 要包含a1.h,a2.idl,b.h文件 	 		Ps:  1.文件的表示格式为: /+”文件名”+…+/文件名  	例子：/home/zhuli/src/main.h 	     2.文件夹是由‘a’-‘z’ 和‘A’-‘Z’组成，文件夹是由‘a’-‘z’，‘A’-‘Z’，‘.’组成，而且有且只有一个‘.’组成，并且‘.’不能在第一个和最后一个位置。 	       3.文件，文件夹的区别要加上绝对路径，比如文件/home/a.h 和文件/home/zhuli/a.h不是一个文件。 	4.这里的文件包含可能会是一个文件夹 这样这个文件夹下的文件和子文件夹（递归的）下面的文件都会包含进去， 	比如文件夹/home/zhuli/include ：下面有文件a1.h，a2.idl 和文件夹afile 	文件夹afile：下面有文件b.h和文件夹bfile 	                     文件夹bfile：有文件c.h 	               关系图为： 	如果包含文件为 /home/zhuli/include 则表该文件要包含文件 a1.h,a2.idl,b.h,c.h 	              5.也支持“*”的哦，表示包含该文件夹下所有的文件（不包含子文件夹）: 	       如果包含文件为 /home/zhuli/include/*则表该文件要包含文件 a1.h,a2.idl. 	              6.如果在SonLlie出现了和之前相同的文件，那你要把文件包含信息合并，ZLLY写的很输出程序很龊。在一个某个SonLlie下的FatherLine出现同名的 你要把同名忽略哦。 	              7.所有文件都是在home文件夹下或者子文件夹下。 	              8.文件数目，文件夹的数目都不超过100个。 	 	
题目输出：
	对于每一个项目你应该输出一行，如果这个项目存在包含死循环，你输出”NO”,否则输出”YES”.
输入样例：
3
2	
/home/zhuli/include/a.h
2
/home/zhuli/include/b.h
/home/zhuli/include/b.h
/home/zhuli/include/b.h
0
5
/home/zhuli/src/a.h
2
/home/zhuli/include/b.h
/home/zhuli/include/*
/home/zhuli/include/b.h
0
/home/zhuli/include/c.h
0
/home/zhuli/src/a.h
1
/home/zhuli/src/c.h
/home/zhuli/src/c.h
0
2
/home/zhuli/src/a.h
2
/home/zhuli/src/b.h
/home/zhuli/src/c.h
/home/zhuli/src/b.h
0

输出样例：
YES
YES
YES

提示：
None



题目：Segments(1092)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
There are some segments on the plane, we assume there 4 possible position concepts for every 2 segments: no common point, countless common points, one common point and the point is also the endpoint of either segment, one common point but the point is not the endpoint of either segment.
题目输入：
The first line of the input is an integer T, which represents that there are T test cases.An integer n indicating the number of segmentsn line follows, 4 integers per line, x1, y1, x2, y2, representing the coordinates of the endpoints of both segments .(1<=n<=100)
题目输出：
For each test case, please output 4 line, 1 integer per lineFor the first line, please output the number of pairs of segments that have no common pointFor the second line, please output the number of pairs of segments that have countless common pointFor the third line, please output the number of pairs of segments that have 1 common point and the point is also the endpoint of either segmentFor the fourth line, please output the number of pairs of segments that have 1 common point and the point is not the endpoint.After each case output a blank line include the last case。
输入样例：
2
3
-1 0 1 0
0 -1 0 1
-1 2 1 2
3
1 0 3 0
2 0 4 0
4 0 5 0
输出样例：
2
0
0
1
1
1
1
0
提示：
None



题目：CountTheCarries(1739)
时间限制：3000 Ms
空间限制：65535 Kb
题目描述：
	One day, Implus gets interested in binary addition and binary carry. He will transfer all decimal digits to binary digits to make the addition. Not as clever as Gauss, to make the addition from a to b, he will add them one by one from a to b in order. For example, from 1 to 3 (decimal digit), he will firstly calculate 01 (1)+10 (2), get 11，then calculate 11+11 (3)，lastly 110 (binary digit), we can find that in the total process, only 2 binary carries happen. He wants to find out that quickly. Given a and b in decimal, we transfer into binary digits and use Implus's addition algorithm, how many carries are there？
题目输入：
	About 100000 cases, end with EOF.	Two integers a, b（0<=a<=b<1000000000).
题目输出：
	For each case, print one integers representing the number of carries per line.
输入样例：
1 2
1 3
1 4
1 6

输出样例：
0
2
3
6

提示：
None



题目：DT坦克逃生(1192)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
在为星姐进行图灵杯复赛平台测试的时候，SmallBear队的坦克DT曾经遇到过这样的情况，DT为了吃一个金币，进入了对手LX这只埋地雷的坦克设置的迷宫陷阱，而迷宫只有一个口可以被DT的伙伴——另一只坦克SX打掉。那时坦克只占据一个格子。迷宫的每一个格子都埋上了炸弹，但是埋下的炸弹只有在被坦克触碰后的下一秒才会启动（启动后，在地雷上的坦克将爆炸）。而DT在迷宫里每走过一个格子都费时一秒，所以DT不能在任何一格停留，也不可能往回走。而SX打通的迷宫出口也会在下一秒被LX的另一只坦克堵上，所以DT必须在打通的那一秒走到出口然后才能逃离
现在题目给的是迷宫的大小和出口打开的时间，问你DT能否在迷宫逃生。能就输出YES，否则NO。


左图要走7步，显然超过了时间，所以NO。右图则只要5步，正好时间出去，所以YES。

左图要走7步，显然超过了时间，所以NO。右图则只要5步，正好时间出去，所以YES。

题目输入：
输入是多组测试数据。第一行给出的是三个整数，分别是N,M,T（1
            
题目输出：
对于每个测试，只要打印“YES”代表DT可以逃出来，或者“NO”就可以了。


输入样例：
4 4 5
S.X.
..X.
..XD
....
3 4 5
S.X.
..X.
...D
0 0 0

输出样例：
NO
YES

提示：
根据上述条件，我们走过的路是不能重复走也不能靠停在某个点来凑逃生时间的。



题目：TheFallingants(1335)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
There are several ants moving on a log which is 1m long, with the speed of either 1cm/s or 0. The ants move in only two directions: to the left or to the right. If two ants bump into each other, they exchange their velocities (both directions and speeds) and move on. If three antis should meet together, then the one in the middle remains still and the other two exchange velocities. If the ants move to the rim of the log, which is at 0cm or 100cm, then they will fall off the log. 
At a time, the ants are all located in different positions on the log, right on the point of integral length (that is, 1, 2, 3, ..., 99cm). There is one and only one ant named A that is not moving (with speed 0), while all the other ants are moving to the left or to the right (with speed 1cm/s). Given the positions and initial speed and direction of all the ants, try to find how long it will take before ant A falls off.
题目输入：
The first line has a integer N (2 ≤ N ≤ 99) indicating the number of ants, followed by N lines, each of which describe the initial status of an ant. Each status has two integers with a space in between. The first integer indicates the initial position P in cm (1 ≤ P ≤ 99), and the second integer indicates the initial direction: -1 means left, 1 means right, 0 means not moving.
题目输出：
How many seconds it is from the start to the time when ant A falls off. If ant A cannot fall off, print "Cannot fall!"
输入样例：
4
10 1
90 0
95 -1
98 -1

输出样例：
98
提示：




题目：ProblemA(1640)
时间限制：1000 MS
空间限制：65535 KB
题目描述：
给你几个整数，输出最大构成的组合的数。
题目输入：
多case，每个case第一行一个m ( 0<m<=1000 )，第二行m个正整数（int范围内）。
题目输出：
每个case输出一行
输入样例：
3
123 456 78

输出样例：
78456123

提示：
None



题目：NUM(1856)
时间限制：None
空间限制：None
题目描述：
定义一个NUM类，求100以内所有的无暇素数，所谓无暇素数是指其本身是素数，其逆序数也是素数，例如17是素数，71也是素数，所有17和71都是无暇素数，具体要求如下：（1）私有成员：int a[20];//整型数组，用来存储100以内的无暇素数int count;//整型变量，用来记录无暇素数的个数（2）公有成员函数：NUM();//构造函数，将count初始化为0int reverse(int n);//求取并返回n的逆序数int isPrime(int n);//判断n是否为素数，若是素数返回1，否则返回0void fun();//求100以内的所有无暇素数，并存放在数组a内void print();//输出100以内的无暇素数的个数和所有无暇素数。（3）在主函数内对NUM类进行测试。
题目输入：
没有输入
题目输出：
输出100以内的无暇素数的个数和所有无暇素数。
输入样例：
None
输出样例：
132 3 5 7 11 13 17 31 37 71 73 79 97
提示：
None



题目：TheDominoEffect(1542)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	A standard set of Double Six dominoes contains 28 pieces (called bones) each displaying two numbers from 0 (blank) to 6 using dice-like pips. The 28 bones, which are unique, consist of the following combinations of pips:	Bone #   Pips    Bone #   Pips    Bone #   Pips    Bone #   Pips		1    0 | 0       8     1 | 1      15    2 | 3      22    3 | 6	2    0 | 1       9     1 | 2      16    2 | 4      23    4 | 4	3    0 | 2      10    1 | 3      17    2 | 5      24    4 | 5	4    0 | 3      11    1 | 4      18    2 | 6      25    4 | 6	5    0 | 4      12    1 | 5      19    3 | 3      26    5 | 5	6    0 | 5      13    1 | 6      20    3 | 4      27    5 | 6	7    0 | 6      14    2 | 2      21    3 | 5      28    6 | 6	All the Double Six dominoes in a set can he laid out to display a 7 x 8 grid of pips. Each layout corresponds at least one ``map" of the dominoes. A map consists of an identical 7 x 8 grid with the appropriate bone numbers substituted for the pip numbers appearing on that bone. An example of a 7 x 8 grid display of pips and a corresponding map of bone numbers is shown below.	7 x 8 grid of pips             map of bone numbers		6  6  2  6  5  2  4  1         28 28 14  7 17 17 11 11	1  3  2  0  1  0  3  4         10 10 14  7  2  2 21 23	1  3  2  4  6  6  5  4          8  4 16 25 25 13 21 23	1  0  4  3  2  1  1  2          8  4 16 15 15 13  9  9	5  1  3  6  0  4  5  5         12 12 22 22  5  5 26 26	5  5  4  0  2  6  0  3         27 24 24  3  3 18  1 19	6  0  5  3  4  2  0  3         27  6  6 20 20 18  1 19	Write a program that will analyze the pattern of pips in any 7 x 8 layout of a standard set of dominoes and produce a map showing the position of all dominoes in the set. If more than one arrangement of dominoes yield the same pattern, your program should generate a map of each possible layout.	
题目输入：
	The input file will contain several of problem sets. Each set consists of seven lines of eight integers from 0 through 6, representing an observed pattern of pips. Each set is corresponds to a legitimate configuration of bones (there will be at least one map possible for each problem set). There is no intervening data separating the problem sets.
题目输出：
	Correct output consists of a problem set label (beginning with Set #1) followed by an echo printing of the problem set itself. This is followed by a map label for the set and the map(s) which correspond to the problem set.	Multiple maps should be output in an increasing order. Just like :						You may amuse the number of maps of each case will be no more than 300.	After all maps for a problem set have been printed, a summary line stating the number of possible maps appears.	three lines are skipped between the output from different problem sets while at least one line separates the labels, echo printing, and maps within the same problem set.	A sample input file of two problem sets along with the correct output are shown.	
输入样例：
5 4 3 6 5 3 4 6
0 6 0 1 2 3 1 1
3 2 6 5 0 4 2 0
5 3 6 2 3 2 0 6
4 0 4 1 0 0 4 1
5 2 2 4 4 1 6 5
5 5 3 6 1 2 3 1
4 2 5 2 6 3 5 4
5 0 4 3 1 4 1 1
1 2 3 0 2 2 2 2
1 4 0 1 3 5 6 5
4 0 6 0 3 6 6 5
4 0 1 6 4 0 3 0
6 5 3 6 2 1 5 3
输出样例：
Layout #1:

   5   4   3   6   5   3   4   6
   0   6   0   1   2   3   1   1
   3   2   6   5   0   4   2   0
   5   3   6   2   3   2   0   6
   4   0   4   1   0   0   4   1
   5   2   2   4   4   1   6   5
   5   5   3   6   1   2   3   1

Maps resulting from layout #1 are:

    6  20  20  27  27  19  25  25
    6  18   2   2   3  19   8   8
   21  18  28  17   3  16  16   7
   21   4  28  17  15  15   5   7
   24   4  11  11   1   1   5  12
   24  14  14  23  23  13  13  12
   26  26  22  22   9   9  10  10

There are 1 solution(s) for layout #1.



Layout #2:

    4   2   5   2   6   3   5   4
    5   0   4   3   1   4   1   1
    1   2   3   0   2   2   2   2
    1   4   0   1   3   5   6   5
    4   0   6   0   3   6   6   5
    4   0   1   6   4   0   3   0
    6   5   3   6   2   1   5   3

Maps resulting from layout #2 are:

   16  16  24  18  18  20  12  11
    6   6  24  10  10  20  12  11
    8  15  15   3   3  17  14  14
    8   5   5   2  19  17  28  26
   23   1  13   2  19   7  28  26
   23   1  13  25  25   7   4   4
   27  27  22  22   9   9  21  21

   16  16  24  18  18  20  12  11
    6   6  24  10  10  20  12  11
    8  15  15   3   3  17  14  14
    8   5   5   2  19  17  28  26
   23   1  13   2  19   7  28  26
   23   1  13  25  25   7  21   4
   27  27  22  22   9   9  21   4

There are 2 solution(s) for layout #2.
提示：
None



题目：YourRideIsHere(1439)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
It is a well-known fact that behind every good comet is a UFO. These UFOs often come to collect loyal supporters from here on Earth. Unfortunately, they only have room to pick up one group of followers on each trip. They do, however, let the groups know ahead of time which will be picked up for each comet by a clever scheme: they pick a name for the comet which, along with the name of the group, can be used to determine if it is a particular group's turn to go (who do you think names the comets?). The details of the matching scheme are given below; your job is to write a program which takes the names of a group and a comet and then determines whether the group should go with the UFO behind that comet. Both the name of the group and the name of the comet are converted into a number in the following manner: the final number is just the product of all the letters in the name, where "A" is 1 and "Z" is 26. For instance, the group "USACO" would be 21 * 19 * 1 * 3 * 15 = 17955. If the group's number mod 47 is the same as the comet's number mod 47, then you need to tell the group to get ready! (Remember that "a mod b" is the remainder left over after dividing a by b; 34 mod 10 is 4.) Write a program which reads in the name of the comet and the name of the group and figures out whether according to the above scheme the names are a match, printing "GO" if they match and "STAY" if not. The names of the groups and the comets will be a string of capital letters with no spaces or punctuation, up to 6 characters long. Examples: Input        OutputCOMETQ       GOHVNGATABSTAR       STAYUSACO
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  An upper case character string of length 1..6 that is the name of the comet.  Line 2:  An upper case character string of length 1..6 that is the name of the group.
题目输出：
A single line containing either the word "GO" or the word "STAY".
输入样例：
COMETQ
HVNGAT
输出样例：
GO
提示：




题目：快速定位(1095)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
很多年后的一天，fishhead想起了多年前的董成城（dccmx）大牛，于是开始想去找董成城信息，回忆回忆，但是经过多年的时间，我们集训队一届又一届的过后，人数也越来越多，鱼头那的资料也越来越多，不过细心的张珂队长早就想到了这一点，他每次整理资料是都把每个人都标了唯一一个ID，而且按ID的升序放好了。注意ID不一定连续哦。(因为每个集训队队员都会有一个ID,逐次递增，但由于每年集训队都有淘汰或退队，因此到最后正常退役的队员的ID不是连续的)
虽然如此，鱼头现在不想多费时间去找，告诉你dccmx的ID，想要你告诉dccmx资料的位置。当然鱼头说的ID不一定存在，记忆的可能不是很清楚。
题目输入：
第一行1个数t，表示测试的次数。
接下来有t行，每行行有n+2个数(n<=10^8)，第一个是所有ID的个数，接着是n个ID，最后是要查找的ID；
每组输入之间有一个空行
题目输出：
对于每一个查找的ID，如果存在输出其在相应ID序列里的位置下标（下标从0开始），如果不存在，输出"-1".
输入样例：
2
4 1 2 3 5 5
 
2 5 7 10

输出样例：
3
-1
提示：




题目：DesignaGardenBorder(1740)
时间限制：3000 Ms
空间限制：65535 Kb
题目描述：
	One day you realize your dream and become a fabulous designer. A project manager comes to find you to do some businesses. Due to your wonderful experiences and designing skills, he decides to make a gigantic investment to design a garden border. Now it is your turn to make that happen. For the sake of his contentment, you must follow all his requirements that he mentions:	1. The garden is a convexpolygon. The garden is inside the border and is line-parallel to the border. Between the border and the garden stands the corridor around. The width of the corridor is D (D>=0).	2. The area of the convexpolygon consisting of all the borders must be at least S. (remember the convexpolygon’s area contains the garden’s area inside)	3. On the borders, the manager wants to place a water spray, which has an R spray range. He announces that in your design you must make sure that every point on the borders where the water spray sets can cover all the garden area to make the garden watered.	4. He will give you the garden point by point in random order, totally N points.	(we assure that no three points in one line and these points are all vertexes) He will also show you the base requirement: S, R. And you must give the range of D.	This is a picture to help you to better understand the design. If legal D does not exist, puts a single line: no appropriate design	
题目输入：
	Multiple cases, end with EOF;	In each case, an integer N, 3<=N<=10000;	Following N lines: (Xi, Yi)     |Xi|<109 |Yi|<109	Two floating-point numbers: S(109 >S>=0),R(109 >R>=0);	
题目输出：
	D’s range:	Two floating-point numbers, split by blank, just rounded the answers to three digits(the error of answers in range of 0.001 will be accepted), smaller one comes first.
输入样例：
4
(0,0)
(1,1)
(1,0)
(0,1)
1.000 2.829
4
(1,0)
(1,1)
(0,1)
(0,0)
1 1

输出样例：
0.000 1.000
no appropriate design

提示：
None



题目：TheGame(1193)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
This is quite a simple game!
The game takes place on a rectangular board consisting of w * h squares. Each square might or might not contain a game piece, as shown in the picture. 
You only need to find out whether two game pieces can be connected by a path which satisfies the two following properties: 
1.     It consists of straight segments, each one being either horizontal or vertical. 
2.     It does not cross any other game pieces. (It is allowed that the path leaves the board temporarily.) 

Here is an example: 
The game pieces at (1,3) and at (4, 4) can be connected. The game pieces at (2, 3) and (3, 4) cannot be connected; each path would cross at least one other game piece. The part of the game you have to write now is the one testing whether two game pieces can be connected according to the rules above.
 




题目输入：
The input contains descriptions of several different game situations. The input contains descriptions of several different game situations. The first line of each description contains two integers w and h (1 <= w,h <= 75), the width and the height of the board. The next h lines describe the contents of the board; each of these lines contains exactly w characters: a "X" if there is a game piece at this location, and a space if there is no game piece. 

Each description is followed by several lines containing four integers x1, y1, x2, y2 each satisfying 1 <= x1,x2 <= 10, 1 <= y1,y2 <= 10. These are the coordinates of two game pieces. (The upper left corner has the coordinates (1, 1).) These two game pieces will always be different. The list of pairs of game pieces for a board will be terminated by a line containing "0 0 0 0". 

There are several test cases.

题目输出：
For each board, output the line "Board #n:", where n is the number of the board. Then, output one line for each pair of game pieces associated with the board description. Each of these lines has to start with "Pair m: ", where m is the number of the pair (starting the count with 1 for each board). Follow this by "k segments.", where k is the minimum number of segments for a path connecting the two game pieces, or "impossible.", if it is not possible to connect the two game pieces as described above. 
Output a blank line after each board.


输入样例：
10 10
XXXXXXXXXX
X        X
X        X
X     XXXX
XXXX  XXX 
XXXX  XX X
XXXXX   XX
XXXXXXXXXX
XXXXXXXXXX
XXXXXXXXXX
1 4 7 6
10 7 10 4
7 6 7 10
0 0 0 0
5 4
XXXXX
X   X
XXX X
 XXX 
2 3 5 3
1 3 4 4
2 3 3 4
0 0 0 0
0 0

输出样例：
Board #1:
Pair 1: 3 segments.
Pair 2: 3 segments.
Pair 3: impossible.

Board #2:
Pair 1: 4 segments.
Pair 2: 3 segments.
Pair 3: impossible.

提示：




题目：Magicianfishhead(1336)
时间限制：1000 ms
空间限制：65535 ms
题目描述：

NJUST ACM training coach, fishhead, is versatile.He is not only a singer, dancer, pianist, but also a magician. He has 50 magic cards, each card has some magical numbers. As long as you think about a number and told him the number of cards on which appeared, he immediately will be able to know what you think the number is. Fishhead is busy today and he can not attend the magic show this evening.He asked you for help,but he forgot to tell you the secret of this magic.So clever are you that you have to think of it yourself.The following is the numbers on his 50 cards.
 

Card 1 :   1,3,5,7,9,11,13,15,17,19,21,23…………
Card 2：  2,3,6,7,10,11,14,15,18,19,22,23,26,27……
Card 3:   4,5,6,7,12,13,14,15,20,21,22,23,28,29,30,31……
Card 4:   8,9,10,11,12,13,14,15,24,25,26,27,28,29,30,31,40,41,42,43,44,45,46,47…
You  may find the rule，then what are the numbers on card 5? Yes, you are right!  They are 
16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,48,49……
……
……
……

题目输入：
Multiple sets of test data. The first line of each data  is ruquired to input with an integer N (0 <= N <= 50)to show this number appears on N cards.The second line is N integers ai（1<=ai<=50） which shows this number appears on the ai-th card. 
题目输出：
An integer ans(0<=ans<2^63) which shows the number that audience think about. If multiple solutions exist , please output with the minimum solution. 
输入样例：
2
1 2

输出样例：
3

提示：




题目：ProblemB(1641)
时间限制：1000 MS
空间限制：65535 KB
题目描述：
一个平面上有N个点，求平面上任意一点，使得这个点到所有点的距离的平方最小。	 
题目输入：
多组测试数据，每组数据第一行一个整数N（3<=N<=100），第二行2*N个实数，x1,y1,x2,y2……xn,yn （-100<x,y<100）。
题目输出：
一个坐标对 x,y（精确到2位小数）。
输入样例：
1
1 1
3
1 1 1 2 2 1

输出样例：
1.00 1.00
1.33 1.33

提示：
None



题目：ARR(1857)
时间限制：None
空间限制：None
题目描述：
建立一个数组类ARR，求一个整型数组所有元素的平均值，具体要求如下：（1）私有成员：int n;  //数组实际元素个数int a[100]; //存放数组元素double aver; //存放平均值（2）公有成员：ARR(int x[],int size); //构造函数，用参数size初始化n，用x数组初始化a数组void Average();//求整形数组的平均值void show();//输出数组的平均值（3）在主函数中完成对该类的测试，定义一个整型数组b,大小为n，定义一个ARR类的对象，用b数组及其元素个数初始化该对象，求其平均值并输出程序运行结果。
题目输入：
第一行输入一个t，代表t组测试数据，接下来输入一个n，代表数组b的大小，然后再输入n个数。（均小于100）
题目输出：
输出平均值
输入样例：
261 2 3 4 5 641 1 1 2
输出样例：
3.51.25
提示：
None



题目：简单的计算器(1096)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
messIDou比较的懒，上小学时数学没有好好学，导致现在计算总是算错。现在请你帮个忙，编写一个计算器计算器要能够计算包含（）+-*/的运算，要求保留三位小数(注意进位)每个表达式一行
题目输入：
第一行是n（n<=50），表示有n组数据
接着有n行输入，每行输入为一个表达式（表达式长度小于1000）
题目输出：
输出表达式的计算结果（直接用cout输出）
输入样例：
1
1+2-3*(5-4)/6
输出样例：
2.5
提示：




题目：GreedyGiftGivers(1440)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A group of NP (2 ≤ NP ≤ 10) uniquely named friends has decided to exchange gifts of money. Each of these friends might or might not give some money to any or all of the other friends. Likewise, each friend might or might not receive money from any or all of the other friends. Your goal in this problem is to deduce how much more money each person gives than they receive. The rules for gift-giving are potentially different than you might expect. Each person sets aside a certain amount of money to give and divides this money evenly among all those to whom he or she is giving a gift. No fractional money is available, so dividing 3 among 2 friends would be 1 each for the friends with 1 left over -- that 1 left over stays in the giver's "account". In any group of friends, some people are more giving than others (or at least may have more acquaintances) and some people have more money than others. Given a group of friends, no one of whom has a name longer than 14 characters, the money each person in the group spends on gifts, and a (sub)list of friends to whom each person gives gifts, determine how much more (or less) each person in the group gives than they receive.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  The single integer, NP  Lines 2..NP+1:  Each line contains the name of a group member Lines NP+2..end:  NP groups of lines organized like this: The first line in the group tells the person's name who will be giving gifts.  The second line in the group contains two numbers: The initial amount of money (in the range 0..2000) to be divided up into gifts by the giver and then the number of people to whom the giver will give gifts, NGi (0 ≤ NGi ≤ NP-1).  If NGi is nonzero, each of the next NGi lines lists the the name of a recipient of a gift.
题目输出：
The output is NP lines, each with the name of a person followed by a single blank followed by the net gain or loss (final_money_value - initial_money_value) for that person. The names should be printed in the same order they appear on line 2 of the input. All gifts are integers. Each person gives the same integer amount of money to each friend to whom any money is given, and gives as much as possible that meets this constraint. Any money not given is kept by the giver.
输入样例：
5
dave
laura
owen
vick
amr
dave
200 3
laura
owen
vick
owen
500 1
dave
amr
150 2
vick
owen
laura
0 2
amr
vick
vick
0 0
输出样例：
dave 302
laura 66
owen -359
vick 141
amr -150
提示：




题目：MessageDecoding(1543)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	Some message encoding schemes require that an encoded message be sent in two parts. The first part, called the header, contains the characters of the message. The second part contains a pattern that represents the message. You must write a program that can decode messages under such a scheme.	The heart of the encoding scheme for your program is a sequence of ``key" strings of 0's and 1's as follows:						The first key in the sequence is of length 1, the next 3 are of length 2, the next 7 of length 3, the next 15 of length 4, etc. If two adjacent keys have the same length, the second can be obtained from the first by adding 1 (base 2). Notice that there are no keys in the sequence that consist only of 1's.	The keys are mapped to the characters in the header in order. That is, the first key (0) is mapped to the first character in the header, the second key (00) to the second character in the header, the kth key is mapped to the kth character in the header. For example, suppose the header is:	AB#TANCnrtXc	Then 0 is mapped to A, 00 to B, 01 to #, 10 to T, 000 to A, ..., 110 to X, and 0000 to c.	The encoded message contains only 0's and 1's and possibly carriage returns, which are to be ignored. The message is divided into segments. The first 3 digits of a segment give the binary representation of the length of the keys in the segment. For example, if the first 3 digits are 010, then the remainder of the segment consists of keys of length 2 (00, 01, or 10). The end of the segment is a string of 1's which is the same length as the length of the keys in the segment. So a segment of keys of length 2 is terminated by 11. The entire encoded message is terminated by 000 (which would signify a segment in which the keys have length 0). The message is decoded by translating the keys in the segments one-at-a-time into the header characters to which they have been mapped.	
题目输入：
	The input file contains several data sets. Each data set consists of a header, which is on a single line by itself, and a message, which may extend over several lines. The length of the header is limited only by the fact that key strings have a maximum length of 7 (111 in binary). If there are multiple copies of a character in a header, then several keys will map to that character. The encoded message contains only 0's and 1's, and it is a legitimate encoding according to the described scheme. That is, the message segments begin with the 3-digit length sequence and end with the appropriate sequence of 1's. The keys in any given segment are all of the same length, and they all correspond to characters in the header. The message is terminated by 000.	Carriage returns may appear anywhere within the message part. They are not to be considered as part of the message.	
题目输出：
	For each data set, your program must write its decoded message on a separate line. There should not be blank lines between messages.	
输入样例：
TNM AEIOU
0010101100011
1010001001110110011
11000
$#**\
0100000101101100011100101000
输出样例：
TAN ME
##*\$
提示：
None



题目：Eloh(1741)
时间限制：3000 MS
空间限制：65535 KB
题目描述：
	In 3201, The humans have conquered the whole universe.	During the conquest ,we found lots of magical phenomena overthrown our previous cognition.		For example, the Eloh is a hole like the black hole but has its own property. And if something is around the Eloh, there is a force between them, named “EF”(Eloh Force).	Every Eloh has a circle area around it, and the Eloh is the center of the circle area.	The circle is called “EFL” (Eloh Force Line).	If there is a thing that has the mass(m) and the volume(v), the EF will satisfy the following properties:	1. In the EFL, EF = v / m and the force performs as the gravitational force.	2. Out the EFL, EF = m / v and the force performs as the repulsion force		One day, Farmer John was grazing his robot cows in the universe. The number of cows is N and every cow has its own mass(mi) and volume(vi).	Suddenly, he encountered such an Eloh. At first he and his cows are in the EFL.	Sadly, the Eloh is swept away some of his cows that stressed the most powerful EF from the Eloh. In other words, sort all the cows’EF from large to small and choose some cows from the front to the back. Luckily, he and the rest of cows escaped to the external of the EFL. To leave the Eloh quickly, he put the reminding cows packaged as a connecting body, i.e, the overall performance of the mass M = sum(mi) (the cow[i] is not swept by the Eloh) and the volume V = sum(vi) (like the previous). Because of the panic, he don’t know exactly how many cows were swept away, just know that not all been swept away, nor is the zero.	As a magical uncle grazing in the universe, Farmer John can create a wormhole through the Eloh center and the outside world. Farmer John can exchange some pair of the cows(pick some cows in the Eloh and choose the same number of cows outside the cave). The connecting body’s M and V will calculator again after exchanging.	Now, Farmer John would like to know when how many cows were swept away in the beginning, there is an exchange scheme can make his EF bigger.	To ensure that no two cows have the same density(m/v).	
题目输入：
	There are multiple test cases.	The first line of the case contains a number  N(0 < N <= 200000)	The following N lines, each of two number mi and vi.(0 < mi,vi <= 100000),  the sequence will be in density ascending order.	The input is terminated by a line containing 0.	
题目输出：
	For each case of input,  the output should consist of one line giving the number Q of the exchange schemes, following Q lines that contain a number K meaning if in the beginning, there are K cows swept away, Farmer John can find an exchange program to help him. Of course, you should output them from small to big.
输入样例：
5
1 3
3 8
4 10
1 2
5 9
0

输出样例：
2
1
2

提示：
None



题目：splitthenumber(1337)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
WAVwind’s granddaughter is fond of certain integral number, and named them her lucky number, when she meets unknown integer, she always disintegrates it to several different lucky numbers.
That is,the sum of these different lucky numbers is this unknown integer。And no two lucky number have the same value。She found there are lots of methods of doing this, but she is undergoing some bad time lately, and couldn’t work out how many methods exactly, so please give her a hand. 
题目输入：
The input consists of several test cases， end of the file
The first line contains 2 numbers M,N, M presents the number to be disintegrated, (1<=M<=10^3) N presents the amount of lucky number (1<=N<=10^3)
The second line contains N numbers, which are the lucky numbers ai (0<=ai<10^3)


题目输出：
For each test case， output a integer, denoting the number of methods of disintegrating.  The answer may be very large,please  output  the answer MOD 2011424

输入样例：
10  10
1 2 3 4 5 6 7 8 9 10

输出样例：
10
提示：




题目：ZLLY的阴谋(1194)
时间限制：3000 ms
空间限制：65535 ms
题目描述：
话说,人类文明在某年已经非常的高,以至于在整个银河系每个星球(一共有N个星球)都有基地.在每个星球之间穿梭用的是飞船.而且飞船非常的智能,两个星球直接飞行的必然是直线(54爱因斯坦).ZLLY生活在那个时代,但是他是一个非常邪恶的人,势力非常的大,在每个星球都有他的一个飞船加工厂.ZLLY一直有个非常邪恶的计划,要毁灭整个银河系,他想了好久,觉得可以利用在宇宙中飞行的飞船相撞,激发里面的宇宙能来引爆整个银河系(这个想法非常的邪恶,ZLLY在其他的星系还有居住地).但是那时的飞船都比较智能(但是每艘飞船都是一次性的,只能飞到某个目的地,然后就没用了),一个星球生产出来的飞船是永远不会相撞的,所以ZLLY想出来一个很傻的方法,他先到第一个星球,告知他的工人启动所有的飞船(他每个星球的工厂都有N-1艘飞船),飞向各个星球,然后当飞船到达某个星球的时候,就告知该星球的所有飞船飞向其他N-1个星球..背景好像太长了....这样的话一定会在某个时间相撞吧....但是,ZLLY要自己先逃走,所以请你帮他算下从这个行动开始到有飞船相撞要多少时间.注意：所有的点之间的连线没有交点，所有的在同一个星球起飞的飞船在同一时间起飞，飞船在星球停留时间忽略。
题目输入：
整数T,有T个测试
N,N个星球(3
            
题目输出：
碰撞时间 T(精确到小数点后3位)

输入样例：
1
4
0 1 2 
3 4 5
6 7 8
9 10 11

输出样例：
10.392

提示：
注意：所有的点之间的连线没有交点，所有的在同一个星球起飞的飞船在同一时间起飞，飞船在星球停留时间忽略。



题目：ProblemC(1642)
时间限制：1000 MS
空间限制：65535 KB
题目描述：
有N个男的和M个女的，每个男的都有一些暗恋的女的，每个女的也有一些暗恋的男的。请给这些人两两配对（仅限于一男一女），如果一对中两个人互相暗恋得2分，如果只有一个人暗恋另一个人，得1分。（不一定匹配完）求你能拿到的最高分数。
题目输入：
多组测试数据，每组测试数据第一行三个整数，N，M （0<N,M<=100）Q （0 <= Q <= 2*N*M）下面有Q行，每行有三个整数 O A B （A,B编号从1开始）O为1时 表示 A男暗恋B女O为2时 表示A女暗恋B男
题目输出：
一个整数，最大的分值。
输入样例：
3 3 3
1 1 2
1 2 3
2 2 3
3 3 3
1 1 2
1 2 3
2 1 3

输出样例：
2
3

提示：
None



题目：链表的排序(1858)
时间限制：None
空间限制：None
题目描述：
链表的结构体定义：struct Node{     int id;     Node *next;};给定n个数，将这n个数依次加入链表，然后按照升序排序，输出链表
题目输入：
第一行输入一个t，代表t组数据，然后输入一个n，代表n个数，接下来输入n个数（均小于1000）
题目输出：
如Sample Output格式输出链表
输入样例：
151 3 2 4 5
输出样例：
1-2-3-4-5
提示：
None



题目：危险的游戏(1097)
时间限制：5000 ms
空间限制：655350 ms
题目描述：
话说ZLLY的GF非常的刁难，经常对ZLLY做一个忠诚度的测试，比如，有一项就是让ZLLY去买可爱多，而且时间由她来决定，一旦超过她规定的时间，则今天剩下的时间就不理ZLLY了。这让ZLLY非常的痛苦，现在请你帮助下ZLLY，给他指出一条最短的路径，让他在最短的时间内完成GF的测试。
题目输入：
第一个数是整数n(n<=50)，表示有n组数据。
每组数据第一行是m(m<=5000),k(k<=m*(m-1)),v,t表示有m(位置编号从1到m)个位置,k条路,v是ZLLY的速度,t是ZLLY的GF要求达到的时间(保留到小数点后2位)。
接着是k组数据，每组数据有三个数a，b，c表示a可以到达b点，路程是c。
然后是两个数s和e，表示ZLLY现在所在的位置和有可爱多卖的位置.
题目输出：
输出从ZLLY所在位置到卖可爱多位置的最短时间
如果不能买到的话（没有路到达）后时间输出ZLLY will cry!
输入样例：
2
4 5 1.00 10.00
1 2 2
1 3 4
2 3 3
2 4 2
3 4 3
1 4
4 3 1.00 5.00
1 2 2
1 3 2
2 3 4
1 4
输出样例：
4.00
ZLLY will cry!
提示：




题目：CodeGeneration(1544)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
				Your employer needs a backend for a translator for a very SIC machine (Simplified Instructional Computer, apologies to Leland Beck). Input to the translator will be arithmetic expressions in postfix form and the output will be assembly language code.				The target machine has a single register and the following instructions, where the operand is either an identifier or a storage location.								L  		  load the operand into the register								A  		  add the operand to the contents of the register								S  		  subtract the operand from the contents of the register								M  		  multiply the contents of the register by the operand								D  		  divide the contents of the register by the operand								N  		  negate the contents of the register								ST 		  store the contents of the register in the operand location								An arithmetic operation replaces the contents of the register with the expression result. Temporary storage locations are allocated by the assembler for an operand of the form ``$n" wheren is a single digit.	
题目输入：
	The input file consists of several legitimate postfix expressions, each on a separate line. Expression operands are single letters and operators are the normal arithmetic operators (+, -, *, /) and unary negation (@).	
题目输出：
			Output must be assembly language code that meets the following requirements:				One instruction per line with the instruction mnemonic separated from the operand (if any) by one blank.				One blank line must separate the assembly code for successive expressions.				The original order of the operands must be preserved in the assembly code.				Assembly code must be generated for each operator as soon as it is encountered.				As few temporaries as possible should be used (given the above restrictions).				For each operator in the expression, the minimum number of instructions must be generated (given the above restrictions).		
输入样例：
AB+CD+EF++GH+++
AB+CD+-
输出样例：
L A
A B
ST $1
L C
A D
ST $2
L E
A F
A $2
ST $2
L G
A H
A $2
A $1

L A
A B
ST $1
L C
A D
N
A $1
提示：
None



题目：鱼儿子的无奈(1338)
时间限制：5000 ms
空间限制：65535 kb
题目描述：
鱼儿子终于上小学啦，今天老师教了加法和乘法，不过加数和乘数都是一位数。鱼头哥知道了，为了尽早把儿子训练成一个顶尖的ACMER，狠心的鱼头哥给鱼儿子出了一道难题：只运用+a和 *a 操作，使得一个数变成另一个数，且a为1~9的数字。可怜的鱼儿子瞎捣活了半天也没整出来，好不容易整出了一个答案（聪明的鱼儿子发现，不停地+1就可以得到结果了），可鱼头哥却说：“不给力啊，我要的是经过最少的步骤能得到”。这下鱼儿子傻了，无奈之下只好求你来帮忙。
题目输入：
多个case(大约100个)。每个case输入两个整数n和m,(1<=n<=m<=1000000)。其中n为鱼头哥给出的数，m是要得到的数。
题目输出：
输出使n得到m经过的最少运算步骤，如果不能得到，此例不输出。
输入样例：
1 2
2 16
输出样例：
1
1
提示：
None



题目：FridaytheThirteenth(1441)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Is Friday the 13th really an unusual event? That is, does the 13th of the month land on a Friday less often than on any other day of the week? To answer this question, write a program that will compute the frequency that the 13th of each month lands on Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, and Saturday over a given period of N years. The time period to test will be from January 1, 1900 to December 31, 1900+N-1 for a given number of years, N. N is non-negative and will not exceed 400. There are few facts you need to know before you can solve this problem: January 1, 1900 was on a Monday. Thirty days has September, April, June, and November, all the rest have 31 except for February which has 28 except in leap years when it has 29. Every year evenly divisible by 4 is a leap year (1992 = 4*498 so 1992 will be a leap year, but the year 1990 is not a leap year) The rule above does not hold for century years. Century years divisible by 400 are leap years, all other are not. Thus, the century years 1700, 1800, 1900 and 2100 are not leap years, but 2000 is a leap year. Do not use any built-in date functions in your computer language. Don't just precompute the answers, either, please.
题目输入：
There are several test cases, end by EOF, for each test case:One line with the integer N.
题目输出：
Seven space separated integers on one line. These integers represent the number of times the 13th falls on Saturday, Sunday, Monday, Tuesday, ..., Friday.
输入样例：
20
输出样例：
36 33 34 33 35 35 34
提示：




题目：MathHomework(1742)
时间限制：3000 Ms
空间限制：65535 Kb
题目描述：
	Alice has a lot of math homework to do today.	All the problems have the same form:	Please find out:		However Alice is not interested at the homework at all. Can you write a program to help	her?(As the answer may be very large,youshould only work out the ans mod 1000000007).
题目输入：
	The first line of the input contains an integer T which means the number of test cases. Then T lines follow, each line consists of six non-negative integers, a; b; c; n; k; k′.
题目输出：
	For each case, you should output one line contains an integer, the answer to the problem.	a, b, c, n ≥ 0 and fit in 32-bit signed number	k + k′≤ 10
输入样例：
1
2 0 1 3 1 1

输出样例：
10

提示：

	We amuse that 00=1


	 




题目：养老---通讯(1195)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
100年以后njust的acmers都老了，于是大家纷纷决定找一个地方去养老，经过一番讨论，终于决定在一片海域中定居。海域里共有n个岛屿，每个岛屿都有我们acmers的足迹，但是令大家失望的是，这是一片优美但却鲜有人烟的海区，在一个岛上的人需要联系其他岛上的人必须要无线连接到通讯站进行转接，而通讯站必须建在海岸线上，海岸线上的通讯站能够用电线互相连通，也就是说一个岛只要跟海岸线上的一个通讯站有无线就可以了，但是由于由于材料、经费限制和缺少经验，我们的acmer建立的通讯站只能覆盖到以通讯站自己为圆心，以d为半径的圆，现在我们想建尽量少的通讯站使得在每个岛上acmer都能联系到其他岛上的acmer（也就是每个岛都能无线连接到至少一个海岸线上的中转站），在茫茫大海中，岛可以看做一个点。现在我们假定海岸线是坐标轴的x轴，以某一点为原点，建立了一个直角坐标系，我们给定这n个岛屿的地理位置xi，yi，然后预测了d的大小，现在我们想知道最少要建立多少个通讯站。
题目输入：
多case输入。每个case第一行两个整数n(1<=n<=1000) ，d(d>=0)，分别代表岛屿的个数和通讯站能无线覆盖到的范围，接下来n行，每行两个数xi，yi，(1=
            
题目输出：
每个case输出case number，以及这个case所需要建立的最少的中转站的个数，假如无法满足条件，个数输出-1，具体的格式请看样例。
输入样例：
3 2
1 2
-3 1
2 1
1 2
0 2
0 0

输出样例：
Case 1: 2
Case 2: 1

提示：




题目：ProblemD(1643)
时间限制：1000 MS
空间限制：65535 KB
题目描述：
某熊掌公司正在招聘，所有人必须经过2轮面试，现在面试官有4位A,B,C,D。由于每个面试官时间不同，所以能面试的人数量不同。每个面试者必须由两个不同的人面试。则可以有AB,AC,AD,BC,BD,CD组合。现在给出每个面试官能面试的人数a,b,c,d，求最多能面试多少人。输出每种组合面试多少人。顺序是AB,AC,AD,BC,BD,CD。如果人数相同，则优先AB最多，如果AB相同，则优先AC最多。。。以此类推
题目输入：
每行四个整数 a,b,c,d (0<a,b,c,d<2000)
题目输出：
六个整数
输入样例：
1 2 1 2
1 1 1 1
输出样例：
1 0 0 0 1 1
1 0 0 0 0 1
提示：
None



题目：链表的插入(1859)
时间限制：None
空间限制：None
题目描述：
链表的结构体定义：struct Node{     int id;     Node *next;};给定n个数，将这n个数依次加入链表，输入一个x，在所有id=x的后面插入一个id=value，输出插入后的链表
题目输入：
第一行输入一个t，代表t组数据，然后输入一个n，代表n个数，接下来输入n个数，最后再输入一个x和一个value（均小于1000）
题目输出：
如Sample Output格式输出插入后的链表
输入样例：
161 2 3 4 5 33 6
输出样例：
1-2-3-6-4-5-3-6
提示：
None



题目：字符串问题(1098)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
给定两个字符串 A和B，我们定义一个A*B的是他们的串联。例如，如果一个A="abc"的和B ="def"，那么A*B的="abcdef"。我们定义串联的幂运算，由一个非负整数幂的定义是正常的方式：a^0 = "" (空串) ， a^(n+1) = a*(a^n).
题目输入：
每个测试案例是一个s字符串，s长度是1-10000000个字符，没有空格。当s="."时结束。
最多有100个字符串
题目输出：
求最大的n使得s由n个相同的字符串a连接而成，即s=a^n;注意s="."没有输出。
输入样例：
abcd
aaaa
ababab
.
输出样例：
1
4
3
提示：
这个问题有巨大的输入，使用scanf代替cin，以避免超过时限。



题目：GettinginLine(1545)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	Computer networking requires that the computers in the network be linked.	This problem considers a ``linear" network in which the computers are chained together so that each is connected to exactly two others except for the two computers on the ends of the chain which are connected to only one other computer. A picture is shown below. Here the computers are the black dots and their locations in the network are identified by planar coordinates (relative to a coordinate system not shown in the picture).	Distances between linked computers in the network are shown in feet.		For various reasons it is desirable to minimize the length of cable used.	Your problem is to determine how the computers should be connected into such a chain to minimize the total amount of cable needed. In the installation being constructed, the cabling will run beneath the floor, so the amount of cable used to join 2 adjacent computers on the network will be equal to the distance between the computers plus 16 additional feet of cable to connect from the floor to the computers and provide some slack for ease of installation.	The picture below shows the optimal way of connecting the computers shown above, and the total length of cable required for this configuration is (4+16)+ (5+16) + (5.83+16) + (11.18+16) = 90.01 feet.		
题目输入：
	The input file will consist of a series of data sets. Each data set will begin with a line consisting of a single number indicating the number of computers in a network. Each network has at least 2 and at most 8 computers. A value of 0 for the number of computers indicates the end of input.	After the initial line in a data set specifying the number of computers in a network, each additional line in the data set will give the coordinates of a computer in the network. These coordinates will be integers in the range 0 to 150. No two computers are at identical locations and each computer will be listed once.	
题目输出：
	The output for each network should include a line which tells the number of the network (as determined by its position in the input data), and one line for each length of cable to be cut to connect each adjacent pair of computers in the network. The final line should be a sentence indicating the total amount of cable used.	In listing the lengths of cable to be cut, traverse the network from one end to the other. (It makes no difference at which end you start.) Use a format similar to the one shown in the sample output, with a line of asterisks separating output for different networks and with distances in feet printed to 2 decimal places.
输入样例：
6
5 19
55 28
38 101
28 62
111 84
43 116
5
11 27
84 99
142 81
88 30
95 38
3
132 73
49 86
72 111
0
输出样例：
**********************************************************
Network #1
Cable requirement to connect (5,19) to (55,28) is 66.80 feet.
Cable requirement to connect (55,28) to (28,62) is 59.42 feet.
Cable requirement to connect (28,62) to (38,101) is 56.26 feet.
Cable requirement to connect (38,101) to (43,116) is 31.81 feet.
Cable requirement to connect (43,116) to (111,84) is 91.15 feet.
Number of feet of cable required is 305.45.
**********************************************************
Network #2
Cable requirement to connect (11,27) to (88,30) is 93.06 feet.
Cable requirement to connect (88,30) to (95,38) is 26.63 feet.
Cable requirement to connect (95,38) to (84,99) is 77.98 feet.
Cable requirement to connect (84,99) to (142,81) is 76.73 feet.
Number of feet of cable required is 274.40.
**********************************************************
Network #3
Cable requirement to connect (132,73) to (72,111) is 87.02 feet.
Cable requirement to connect (72,111) to (49,86) is 49.97 feet.
Number of feet of cable required is 136.99.

提示：
None



题目：Game(1339)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
幼儿园的孩子们在玩一个游戏：游戏开始时每个人有100张卡片，每次老师可以点两个人的名字，甲 乙，那么乙要将自己卡片的一半（向下取整）给甲。问M次点名后每个人手上卡片的张数（M<=100000,人数<=10000,人名为长度<=10的字符串），按照第一次被点名的先后顺序输出。
题目输入：
第一行输入一个整数M
下面M行每行两个字符串表示两个人名
题目输出：
最后每个人手上的卡片数
输入样例：
5
gangbei  wuyao
shuiren  gangbei
xiaoxiao siqi
xiaoxiao shuiren
shuiren  xiaoxiao

输出样例：
75
50
206
119
50

提示：




题目：BrokenNecklace(1442)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
You have a necklace of N red, white, or blue beads (3<=N<=350) some of which are red, others blue, and others white, arranged at random. Here are two examples for n=29:                 1 2                               1 2            r b b r                           b r r b          r         b                       b         b         r           r                     b           r        r             r                   w             r       b               r                 w               w      b                 b               r                 r      b                 b               b                 b      b                 b               r                 b       r               r                 b               r        b             r                   r             r         b           r                     r           r           r       r                         r       b             r b r                             r r w            Figure A                         Figure B                        r red bead                        b blue bead                        w white beadThe beads considered first and second in the text that follows have been marked in the picture. The configuration in Figure A may be represented as a string of b's and r's, where b represents a blue bead and r represents a red one, as follows: brbrrrbbbrrrrrbrrbbrbbbbrrrrb . Suppose you are to break the necklace at some point, lay it out straight, and then collect beads of the same color from one end until you reach a bead of a different color, and do the same for the other end (which might not be of the same color as the beads collected before this). Determine the point where the necklace should be broken so that the most number of beads can be collected.For example, for the necklace in Figure A, 8 beads can be collected, with the breaking point either between bead 9 and bead 10 or else between bead 24 and bead 25. In some necklaces, white beads had been included as shown in Figure B above. When collecting beads, a white bead that is encountered may be treated as either red or blue and then painted with the desired color. The string that represents this configuration will include the three symbols r, b and w. Write a program to determine the largest number of beads that can be collected from a supplied necklace.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  N, the number of beads Line 2:  a string of N characters, each of which is r, b, or w
题目输出：
A single line containing the maximum of number of beads that can be collected from the supplied necklace.
输入样例：
29
wwwbbrwrbrbrrbrbrwrwwrbwrwrrb
输出样例：
11
提示：
Consider two copies of the beads (kind of like being able to runaround the ends). The string of 11 is marked. wwwbbrwrbrbrrbrbrwrwwrbwrwrrb wwwbbrwrbrbrrbrbrwrwwrbwrwrrb                       ****** *****                       wwwwwb bbbbb  <-- assignments                       5 x w  6 x b  <-- 11 total



题目：ProblemE(1644)
时间限制：5000 MS
空间限制：65535 KB
题目描述：
N条生产线，M个任务，每个任务有个开始时间和终止时间，一旦任务开始，就占用一条生产线，直到任务结束。求最多能完成多少任务。
题目输入：
第一行两个整数N,M (0<N<=100 , 0 <M<=1000)下面M行，每行两个整数，s，e 。任务开始时间和结束时间 (0< s, e<=10000000)
题目输出：
一个整数，最多能完成的任务数
输入样例：
2 4
1 2
2 4
3 4
4 5
输出样例：
4

提示：
None



题目：BoringGame(1743)
时间限制：2500 Ms
空间限制：65535 Kb
题目描述：
	Zero likes to play a boring game when he feels extremely boring. This his game proceeds in a square board with n rows and n column. Each grid in the board has either of two colors black or white. In each turn, Zero chooses a grid first. Let’s assume that the grid he chooses locates in the xth row and the yth column. And then, the neighbors which are existed of this grid (x + 1, y), (x – 1, y), (x, y + 1), (x, y – 1) and itself will convert their color into another. Till the end, Zero will transform the initial board to the goal board whose grids are all white. For instance, Here is the way to attain his goal. In his first turn, he selects (2, 2). And then he selects (1, 1) in the second turn. After that, he reaches his goal.	 	Zero reckons this mission, however, is too simple and naïve. So he prefers to accomplish this assignment in minimal turns. He doesn’t know whether the turns he needs are the minimal turns, because of that he needs you to tell him the minimal turns of these initial boards.
题目输入：
	There are several test cases in the input file. The first line of the input file contains an integer m(m <= 106), then m cases follow.	The first line of each test case contains an integer n(1 <= n <= 8), which is the length of a side of the square board.	Then the next line contains n integer a[i](0 <= a[i] <= 2n, 1 <= i <= n), which is the statement of the ith row respectively. The definition of a statement can be illustrated as n-length binary numbers, zero represents white and one represents black. For example, when n is equal to 4 and a[0] is equal to 5 = (0101)2, you can consider that the condition in the first line of this board is white, black, white, black.
题目输出：
	For each test case, output the minimal turns. If the initial board doesn’t contain a way to reach the goal board, please output -1.
输入样例：
2
3
4 3 2
4
1 0 0 0

输出样例：
2
-1

提示：
None



题目：红果果的A星(1196)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
给一张图,已知起点和终点,求出从起点到终点的第K短的路的长度边是无向的
题目输入：
多case
第一行N,M(N个点(从1开始标),M条边)(1<=N<=1000,0<=M<=100000)
M行  每行 A,B,T   A点和B点之间边长T(T<100)
最后一行 S,T,K  起点S 终点T  求第K短长度(k<1000)

题目输出：
求出第K短路长度
没有的话输出-1

输入样例：
2 2
1 2 5
2 1 4
1 2 2

输出样例：
5

提示：




题目：链表的删除(1860)
时间限制：None
空间限制：None
题目描述：
链表的结构体定义：struct Node{     int id;     Node *next;};给定n个数，将这n个数依次加入链表，然后输入一个x，删除id=x的所有节点，然后将删除节点后的链表输出
题目输入：
第一行输入一个t，代表t组数据，然后输入一个n，代表n个数，接下来输入n个数，最后再输入一个x（均小于1000）
题目输出：
如Sample Output格式输出删除节点后的链表
输入样例：
161 2 3 4 5 33
输出样例：
1-2-4-5
提示：
None



题目：社团的统计(1099)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
在我们的大学里有许许多多的社团，很难掌握所有人参加了什么社团，现在xiaoyoulei在团委打杂，需要统计有多少个社团在我们学校存在。他知道学校有n(0 < n <= 50000)个学生，他去问每一个学生参加什么社团是不可能的。而且，许多同学也不想告诉他，一种方法解决这些问题，要求m(0 <= m <= n(n-1)/2)对同学，并询问他们是否在同一个社团（例如，他们可能互相知道，如果他们都出席同一社团会议）。从这些数据，你可能不知道每个人是否参加，但你可以得到的，究竟可能最多有多少社团同学们参加了。现在假设每个学生最多一个参加一个社团。xiaoyoulei很懒，希望你能帮他搞定。
题目输入：
输入包含多组测试数据，每一组数据开始一行是俩个整数n和m。接下来的m行每行包括2个整数i和j，表示i和j参加了同一个社团，同学们从1到n被标号，输入以n=m=0结束。
题目输出：
对于每个测试用例，输出在一行，形式"Case x: max"；x表示第几组测试数据(从1开始)，max是社团的最多可能数量。
输入样例：
10 9
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
1 10
10 4
2 3
4 5
4 8
5 8
0 0
输出样例：
Case 1: 1
Case 2: 7
提示：
Case 2: 7
1;  6;  7;  9;  10; 可能每个人在不同社团（可能5个不同社团）
2,3;  2,3在同一个社团
4,5,8; 4,5,8在同一个社团
所以最多可能存在有7个社团



题目：MothEradication(1546)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	 		Entomologists in the Northeast have set out traps to determine the influx of Jolliet moths into the area. They plan to study eradication programs that have some potential to control the spread of the moth population.	The study calls for organizing the traps in which moths have been caught into compact regions, which will then be used to test each eradication program. A region is defined as the polygon with the minimum length perimeter that can enclose all traps within that region. For example, the traps (represented by dots) of a particular region and its associated polygon are illustrated below.	 	You must write a program that can take as input the locations of traps in a region and output the locations of traps that lie on the perimeter of the region as well as the length of the perimeter.		
题目输入：
		The input file will contain records of data for several regions. The first line of each record contains the number (an integer no more than 150000) of traps for that region. Subsequent lines of the record contain 2 real numbers that are the x- and y-coordinates of the trap locations. Data within a single record will not be duplicated. End of input is indicated by a region with 0 traps.	
题目输出：
		Output for a single region is displayed on at least 3 lines:		One blank line must separate output from consecutive input records.	
输入样例：
3
1 2
4 10
5 12.3
6
0 0
1 1
3.1 1.3
3 4.5
6 2.1
2 -3.2
7
1 0.5
5 0
4 1.5
3 -0.2
2.5 -1.5
0 0
2 2
0
输出样例：
Region #1:
(1.0,2.0)-(4.0,10.0)-(5.0,12.3)-(1.0,2.0)
Perimeter length = 22.10

Region #2:
(0.0,0.0)-(3.0,4.5)-(6.0,2.1)-(2.0,-3.2)-(0.0,0.0)
Perimeter length = 19.66

Region #3:
(0.0,0.0)-(2.0,2.0)-(4.0,1.5)-(5.0,0.0)-(2.5,-1.5)-(0.0,0.0)
Perimeter length = 12.52
提示：
None



题目：Kth出现(1340)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
给出两个字符串W和T，求W在T中第K次出现的位置（可重叠，T中位置从0开始编号）。
如果不能出现，输出-1 
T的长度不超过106,
W的长度不超过104 
1<=K<=106
题目输入：
以文件末尾结束。第一行为字符串W，第二行为T，第三行为K
题目输出：
W在T中第K次出现的起始位置
输入样例：
abab
ababab
2

输出样例：
2
提示：




题目：MilkingCows(1443)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Three farmers rise at 5 am each morning and head for the barn to milk three cows. The first farmer begins milking his cow at time 300 (measured in seconds after 5 am) and ends at time 1000. The second farmer begins at time 700 and ends at time 1200. The third farmer begins at time 1500 and ends at time 2100. The longest continuous time during which at least one farmer was milking a cow was 900 seconds (from 300 to 1200). The longest time no milking was done, between the beginning and the ending of all milking, was 300 seconds (1500 minus 1200). Your job is to write a program that will examine a list of beginning and ending times for N (1 <= N <= 5000) farmers milking N cows and compute (in seconds): The longest time interval at least one cow was milked. The longest time interval (after milking starts) during which no cows were being milked.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  The single integer  Lines 2..N+1:  Two non-negative integers less than 1000000, the starting and ending time in seconds after 0500
题目输出：
A single line with two integers that represent the longest continuous time of milking and the longest idle time.
输入样例：
3
300 1000
700 1200
1500 2100
输出样例：
900 300
提示：




题目：ProblemF(1645)
时间限制：1000 MS
空间限制：65535 KB
题目描述：
给出两个字串A，B。将A字串转化为B字串，转化一共有两种。删除n个字符，费用为2.增加n个字符，费用为n+2.求把A变为B最小代价。
题目输入：
第一行一个整数N（0<N<=50）表示有N个case每个case两行字串A,B（字串长度小于2000，字符仅包含小写字母）
题目输出：
一个整数W，最小费用
输入样例：
2
dsafsadfadf
fdfd
aaaaaaaa
bbbbbbbb

输出样例：
7
12

提示：
None



题目：好斗的猴子(1197)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
从前,在一个森林里有N只好斗的猴子。开始,它们互相不认识。互不认识的猴子间是无法避免争斗的，而且争斗只会发生在两只互不认识的猴子之间。决斗结束后,这两只猴子和它们各自的朋友们通过这场决斗互相间都认识了，争斗便不会再发生在这一大群猴子中的任意两只之间发生。
由于决斗比较激烈,所以同一时间内不会有两场决斗同时发生。
经过N-1次决斗后,这N只猴子间互相都认识了,文有多少种可能的决斗过程。
例如:N=3,有6种不同的过程：12->13,12->23,13->12,13->32,23->21,23->31
输入将包含多组case,以文件尾结束。
输出可能的决斗过程种数。
题目输入：
输入将包含多组case,以文件尾结束。
题目输出：
输出可能的决斗过程种数
输入样例：
4

输出样例：
96

提示：




题目：类的继承(1861)
时间限制：None
空间限制：None
题目描述：
定义一个Person类class Person{
	private:
		char name[20],sex;
	public:
		Person(char *p,char s,char *d){
		
		}
		char* getName(){
			
		}
		char getSex(){
			
		}
};学生也属于Person类，不过它还有一个学号（Id）请你设计一个学生（Student）类，它由Person类继承而来，然后输出学生信息class Student: public Person{
	//？
};
题目输入：
第一行输入一个t，代表t组数据，然后输入name，sex，Id;
题目输出：
按照Sample Output格式输出
输入样例：
2Joe m 20150106Jan f 20150107
输出样例：
Joe m 20150106Jan f 20150107
提示：
None



题目：Robot(1744)
时间限制：2000 Ms
空间限制：65535 Kb
题目描述：
	A robot is a mechanical or virtual artificial agent, usually an electro-mechanical machine that is guided by a computer program or electronic circuitry. Robots can be autonomous or semi-autonomous and range from humanoids such as Honda's Advanced Step in Innovative Mobility (ASIMO) and Tosy's TOSY Ping Pong Playing Robot (TOPIO) to industrial robots, collectively programmed 'swarm' robots, and even microscopic nano robots. By mimicking a lifelike appearance or automating movements, a robot may convey a sense of intelligence or thought of its own.	Robots have replaced humans in the assistance of performing those repetitive and dangerous tasks which humans prefer not to do, or are unable to do due to size limitations, or even those such as in outer space or at the bottom of the sea where humans could not survive the extreme environments.	After many years, robots have become very intellective and popular. Glad Corporation is a big company that produces service robots. In order to guarantee the safety of production, each robot has an unique number (each number is selected from 1 to N and will be recorded when the robot is produced).	But one day we found that N+1 robots have been produced in the range of 1 to N , that's to say one number has been used for 2 times. Now the president of Glad Corporation hopes to find the reused number as soon as possible.
题目输入：
	Multiple cases, end with EOF.	In each case, The first line has one number N, which represents the maximum number. The next line has N +1 numbers. (All numbers are between 1 to N, and only two of them are the same.) (1 <= N <= 10 ^ 3)
题目输出：
	Each case, output a line with the reused number.	There are no black lines between cases.
输入样例：
2
1 2 1
1
1 1

输出样例：
1
1

提示：
None



题目：三阶魔方(1341)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
拧三阶魔方时，有个公式为：U,  R,  U’,  R’,   U’,  F’,   U,    F  
U的意思为顺手拧上面，R的意思为顺手拧右面，F为顺手拧前面，相应的U’,R’,F’为逆手拧。
顺手拧（右手），效果为




1

2

3


4

5

6


7

8

9
 
变为：




7

4

1


8

5

2


9

6

3
 
起初，魔方六面每面颜色均一样，任选一面对着自己为前面，运用上述公式。请编程输出最少运用多少次此公式可将魔方还原为每面颜色一样，如果总不能达到要求，输出Impossible.(一旦初始时对着自己的面确定，之后每次运用公式都不能旋转魔方，即总是这面对着自己)
题目输入：
没有输入数据
题目输出：
这个不能告诉你~你猜
输入样例：
// 木有输入数据
输出样例：
/\d/
提示：




题目：网站导航(1100)
时间限制：1000 ms
空间限制：65535 ms
题目描述：


集训队STsky（“圣情天空”）准备做一个浏览器，其中有有一项功能是网站导航：可以通过向后和向前移动到之前打开过网页。STsky狡猾的想了下，把这个功能交给他们的dreaming3000去完成，现在dreaming3000忙于fishhhead交给他们的任务，没有时间去做，于是他们要你发出SOS。希望你能够帮他们完成。在这个问题里，你要解决如下操作命令：BACK:回退，使得当前页的后一个网页成为当前网页。如果已经到了最后了，该命令将被忽略。FORWARD:前进，使得当前页的前一个网页成为当前网页。如果已经到了最前面了，该命令将被忽略。VISIT:打开一个网页。QUIT:退出浏览器。假设最初的浏览器在加载网页的网址是http://www.njustacm.org/

 

题目输入：
输入是一个命令序列。该命令的关键字 BACK, FORWARD, VISIT, and QUIT（都在大写）。网址没有空格，并且最多70个字符。你可以假设，用户不会访问多于1000个网站。
题目输出：
对于不是QUIT命令。如果该命令没有被忽略，输出当前网页的网址。否则，输出"Ignored"。每项命令的输出应输出在自己的一行。QUIT命令没有输出。
输入样例：
VISIT http://acm.ashland.edu/
VISIT http://acm.baylor.edu/acmicpc/
BACK
BACK
BACK
FORWARD
VISIT http://www.ibm.com/
BACK
BACK
FORWARD
FORWARD
FORWARD
QUIT
输出样例：
http://acm.ashland.edu/
http://acm.baylor.edu/acmicpc/
http://acm.ashland.edu/
http://www.njustacm.org/
Ignored
http://acm.ashland.edu/
http://www.ibm.com/
http://acm.ashland.edu/
http://www.njustacm.org/
http://acm.ashland.edu/
http://www.ibm.com/
Ignored
提示：




题目：BudgetTravel(1547)
时间限制：3000 ms
空间限制：65565 ms
题目描述：
	An American travel agency is sometimes asked to estimate the minimum cost of traveling from one city to another by automobile. The travel agency maintains lists of many of the gasoline stations along the popular routes. The list contains the location and the current price per gallon of gasoline for each station on the list.	In order to simplify the process of estimating this cost, the agency uses the following rules of thumb about the behavior of automobile drivers.	A driver never stops at a gasoline station when the gasoline tank contains more than half of its capacity unless the car cannot get to the following station (if there is one) or the destination with the amount of gasoline in the tank.	A driver always fills the gasoline tank completely at every gasoline station stop.	When stopped at a gasoline station, a driver will spend $2.00 on snacks and goodies for the trip.	A driver needs no more gasoline than necessary to reach a gasoline station or the city limits of the destination. There is no need for a ``safety margin."	A driver always begins with a full tank of gasoline.	The amount paid at each stop is rounded to the nearest cent (where 100 cents make a dollar).	You must write a program that estimates the minimum amount of money that a driver will pay for gasoline and snacks to make the trip.	
题目输入：
	Program input will consist of several data sets corresponding to different trips. Each data set consists of several lines of information. The first 2 lines give information about the origin and destination. The remaining lines of the data set represent the gasoline stations along the route, with one line per gasoline station. The following shows the exact format and meaning of the input data for a single data set.	Line 1:	One real number - the distance from the origin to the destination	Line 2:	Three real numbers followed by an integer	The first real number is the gallon capacity of the automobile's fuel tank.	The second is the miles per gallon that the automobile can travel.	The third is the cost in dollars of filling the automobiles tank in the origination city.	The integer (less than 51) is the number of gasoline stations along the route.	Each remaining line:	Two real numbers	The first is the distance in miles from the origination city to the gasoline station.	The second is the price (in cents) per gallon of gasoline sold at that station.	All data for a single data set are positive. Gasoline stations along a route are arranged in nondescending order of distance from the origin. No gasoline station along the route is further from the origin than the distance from the origin to the destination. There are always enough stations appropriately placed along the each route for any car to be able to get from the origin to the destination.	The end of data is indicated by a line containing a single negative number.	
题目输出：
	For each input data set, your program must print the data set number and a message indicating the minimum total cost of the gasoline and snacks rounded to the nearest cent. That total cost must include the initial cost of filling the tank at the origin. Sample input data for 2 separate data sets and the corresponding correct output follows.	
输入样例：
475.6
11.9 27.4 14.98 6
102.0 99.9
220.0 132.9
256.3 147.9
275.0 102.9
277.6 112.9
381.8 100.9
516.3
15.7 22.1 20.87 3
125.4 125.9
297.9 112.9
345.2 99.9
-1
输出样例：
Data Set #1
minimum cost = $27.31
Data Set #2
minimum cost = $38.09

提示：
None



题目：ProblemG(1646)
时间限制：1000 MS
空间限制：65535 KB
题目描述：
设B={b1,b2,…,bn} 和 W={w1,w2,…,wn}为平面上黑点和白点的两个集合。一黑点bi=(xi, yi ) 与一白点wj=(xj, yj ) 匹配当且仅当xi≤xj 和yi≤yj 。找出黑白点之间的最大匹配数目。黑点和白点各自的数量不超过100000；平面为（0,0）到（10000，10000）的矩形中的整数点
题目输入：
黑棋个数  白棋个数黑棋点的坐标x   黑棋点的坐标y……白棋点的坐标x   白棋点的坐标y……
题目输出：
最大匹配数
输入样例：
2 2
1 0
0 1
1 1
0 0

输出样例：
1

提示：
None



题目：Transformations(1444)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A square pattern of size N x N (1 <= N <= 10) black and white square tiles is transformed into another square pattern. Write a program that will recognize the minimum transformation that has been applied to the original pattern given the following list of possible transformations: #1: 90 Degree Rotation: The pattern was rotated clockwise 90 degrees. #2: 180 Degree Rotation: The pattern was rotated clockwise 180 degrees. #3: 270 Degree Rotation: The pattern was rotated clockwise 270 degrees. #4: Reflection: The pattern was reflected horizontally (turned into a mirror image of itself by reflecting around a vertical line in the middle of the image). #5: Combination: The pattern was reflected horizontally and then subjected to one of the rotations (#1-#3). #6: No Change: The original pattern was not changed. #7: Invalid Transformation: The new pattern was not obtained by any of the above methods. In the case that more than one transform could have been used, choose the one with the minimum number above.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  A single integer, N  Line 2..N+1:  N lines of N characters (each either `@' or `-'); this is the square before transformation Line N+2..2*N+1:  N lines of N characters (each either `@' or `-'); this is the square after transformation
题目输出：
A single line containing the the number from 1 through 7 (described above) that categorizes the transformation required to change from the `before' representation to the `after' representation.
输入样例：
3
@-@
---
@@-
@-@
@--
--@
输出样例：
1
提示：




题目：Badnews(1198)
时间限制：5000 ms
空间限制：65535 ms
题目描述：

The offerof master will be lost if bingbing(who we usually call him as “dengshen”) do not pay $5000 to the teacher's Office in Hangzhou. He borrow the money from fishhead,  However, this is not so easy as it sounds, since heis chased by the Police. Moreover, it is 106 miles to Hangzhou, it is dark and he is wearing sunglasses.
As heisin a hurry, you should help them find the safest way to Hangzhou. In this problem, the safest way is considered to be the route which maximises the probability that heis not caught. 
题目输入：
The input file contains several test cases.
Each test case starts with two integers n and m (2 ≤ n ≤ 100 , 1 ≤ m ≤ n*(n-1)/2). n is the number of intersections, m is the number of streets to be considered.
The next m lines contain the description of the streets. Each street is described by a line containing 3 integers a, b and p (1 ≤ a, b ≤ n , a ≠ b, 1 ≤ p ≤ 100): a and b are the two end points of the street and p is the probability in percent that the Blues Brothers will manage to use this street without being caught. Each street can be used in both directions. You may assume that there is at most one street between two end points. 
The last test case is followed by a zero. 

题目输出：
For each test case, calculate the probability of the safest path from intersection 1 (the Palace Hotel) to intersection n (the Honorable Richard J. Daley Plaza in Hangzhou). You can assume that there is at least one path between intersection 1 and n.
Print the probability as a percentage with exactly 6 digits after the decimal point. The percentage value is considered correct if it differs by at most 10-6 from the judge output. Adhere to the format shown below and print one line for each test case. 

输入样例：
5 7
5 2 100
3 5 80
2 3 70
2 1 50
3 4 90
4 1 85
3 1 70
0

输出样例：
61.200000 percent
Hint
The safest path for the sample input is 1 -> 4 -> 3 -> 5

提示：




题目：骆驼驮包(1342)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
有p个人带着x个小包和y个大包准备穿过沙漠。所有人都不愿意徒步旅行，因此需要一些骆驼把他们自己和所有大包小包驮在背上。每匹骆驼可以背的物体只能是下列四种组合之一（因此不能同时背大包和小包）：不超过3个小包；不超过2个大包；1个人和不超过2个小包；1个人和1个大包；最少需要多少骆驼？
题目输入：
多组测试数据，每组数据第一行输入三个非负整数p，x，y。1≤p≤1000000000, 0≤x，y≤1000000000。输入直到文件结尾。
题目输出：
每组数据输出一行一个正整数Ans，最少需要的骆驼数。
输入样例：
1 0 0
1 2 2
1 3 1

输出样例：
1
2
2

提示：
None



题目：ScriptZ(1745)
时间限制：20000 Ms
空间限制：65535 Kb
题目描述：
	Recently, Programmer Zero have made a new script programming language, named Script Z. He is so proud of his new language, that he wrote many programs in Script Z. Unfortunately, he found his script works strangely, and he had no idea what happened. So he wants you to write a Script Z Interpreter for him.	 Here are some information about Script Z:	   1. Variable: All variable names start with symbol $, and the name of the variable should only contains letters (upper case and lower case), numbers and underlines (_). The first character of the number can be any legal character for the variable. For example, $a $c $t $0 $2 $_ are all legal variable names, while $0-a, $0%b are illegal ones. Variables can be assigned many times during the processing of the script. The length of variable name is no larger than 32. (Does not include the first $ symbol, so the max length of variable name will be 33 with symbol $).	2. Constant: All constant names must start with letters (upper case and lower case), and should only contains letters (upper case or lower case), numbers and underlines (_). For example, A B A10 B_123 are legal constant names, while 5A 4_b are illegal ones. Constants can be assigned at most once. The length of constant name is no larger than 32.	3. Whitespaces: Spaces (' ', ord(' ') == 32) and tabs ('\t', ord('\t') == 9).	4. Lines: All lines are terminated with character LF('\n', ord('\n') == 10). Each line should be a statement or a blank line.	5. Statement: There will be exactly one statement in one line (except blank lines). The whitespaces at the beginning and the end of the statement should be ignored.	6. Blank lines: One line that contains only whitespaces or no character.	7. Data Types:	 Integer: All integer contains only numbers ([0-9]). The length of integer is not larger than 100.	 String: All string values are quoted with double quotes ("), and there won’t be any other double quotes in the string value. All characters in the string are printable . The length of string (without double quotes) is not larger than 100. (The length is not larger than 102 if with double quotes.)	 There are 5 kinds of statement in Script Z:	1. Assignment:	$Variable = Value	Constant = Value	     Notice: there may be none or any number of whitespaces before and after the equal sign (=).	     The value can be either an integer or a string, and won’t be a reference of variable or constant.	     The following assignment are legal:	$a = 1	$b = 2	$b = 3	$_ = "a"	$ok = "true"	$long = 123456789012345678901234567890	CONST = 1	CONST_STRING = "sample"	EMPTY = ""	     And these are illegal:	$a = $b	CONST_STRING = a	BOOLEAN = false	FLOAT = 1.5	EMPTY =	2. Output:	Print $Variable	Print Constant	     There are at least one whitespace between Print and variable or constant. For each output statement, your program should print the value of the variable or the constant. No double quotes are needed if the value is string. If the variable is undefined, you should print NULL, and if the constant is undefined, you should print the name of the constant. And also remember to take a look of error reporting part.	3. Dump:	Dump $Variable	Dump Constant	     There are at least one whitespace between Dump and variable or constant. For each dump statement, your program should print the type and the value of the variable or the constant. Double quotes are needed if the value is string. If the variable is undefined, you should print NULL, and if the constant is undefined, you should regard the constant name as a string to be the value of the constant. And also remember to take a look of error reporting part. Use the format in sample output.	4. Error reporting:	Errmsg ON|OFF	     There are at least one whitespace between Errmsg and ON or OFF. Errmsg ON turns on the error reporting while Errmsg OFF turns off. Error reporting is turned on if not specified. If error reporting is turned on, after each statement, you should:	       (1) You should print one line if there are undefined variable in Print or Dump statement:	NOTICE: Undefined Variable ${var_name}.	       You should replace ${var_name} with the name of variable.	       (2) You should print one line if there are undefined constant in Print or Dump statement:	NOTICE: Undefined Constant {const_name}.	       You should replace {const_name} with the name of constant.	       (3) You should print one line if an assignment are tring to assign an assigned constant:	WARNING: Constant {const_name} Already Defined!	       You should replace {const_name} with the name of constant. And you should ignore this assign statement even if the error reporting is turned off (The value of the constant should not be changed).	       5. Terminate:	Panic	       Your program should print one line and exit after this statement:	Script was KILLED.	        You should ignore all statements after the terminate statement.
题目输入：
	Input contains multiple test cases. The first line of the input contains exactly one integer T, which means the number of test cases. (T <= 10)	For each test case, the first line contains exactly one integer N, which means the lines of the script. (N <= 100000)	The next N lines, contains the statement of the script. Each line is no longer than 256 characters.	You are guaranteed that all statement, variable name, constant name are legal.
题目输出：
	For each test case, print the output of the script.	Use one blank line to split test cases, no blank line should exist at the end of the last test case. (Only one line terminator '\n')
输入样例：
2
13
Errmsg ON
$a = 1
$b = 2
$c = 3
Print $a
Print $d
Dump $c
Errmsg OFF
Print $_
Print OK
Panic
Errmsg ON
Print A
13
Errmsg ON
$A = 3
$B = 5
Print $a
Print $B
A = 5
A = 10
Print A
Errmsg OFF
B = ""
B = "A"
Dump B
Dump C

输出样例：
1
NULL
NOTICE: Undefined Variable $d.
integer: 3
NULL
OK
Script was KILLED.

NULL
Notice: Undefined Variable $a.
5
WARNING: Constant A Already Defined!
5
string: ""
string: "C"

提示：

	The problem itself is easy of course. But some of the test cases of this problem are strange and annoying. Be careful! 




题目：象棋--马(1101)
时间限制：2000 ms
空间限制：65535 ms
题目描述：
中国象棋中的“马”是一个让人着迷的棋子，它走位风骚，杀人于无形之中，象棋高手都对马运用纯熟。众所周知，“马”走“日”子形，现在有一张m*m棋盘，已知“马”的位置，以及想要去的位置，请找出最短的步数完成。
题目输入：
第一行为n（n<=50）,表示有n组测试数据
每组测试数据中含5个正整数m(m<1000),x1,y1,x2,y2;
马的起始位置(x1,y1),目标位置(x2,y2);
题目输出：
所需要的最短步数
输入样例：
3
9
1 1
2 3
11
1 1
3 3
12
1 1
3 4
输出样例：
1
4
3
提示：




题目：PalindromicSquares(1445)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Palindromes are numbers that read the same forwards as backwards. The number 12321 is a typical palindrome. Given a number base B (2 <= B <= 20 base 10), print all the integers N (1 <= N <= 300 base 10) such that the square of N is palindromic when expressed in base B; also print the value of that palindromic square. Use the letters 'A', 'B', and so on to represent the digits 10, 11, and so on. Print both the number and its square in base B.
题目输入：
There are several test cases, end by EOF, for each test case:A single line with B, the base (specified in base 10).
题目输出：
Lines with two integers represented in base B. The first integer is the number whose square is palindromic; the second integer is the square itself.
输入样例：
10
输出样例：
1 1
2 4
3 9
11 121
22 484
26 676
101 10201
111 12321
121 14641
202 40804
212 44944
264 69696
提示：




题目：萌萌买西瓜(1647)
时间限制：2000 MS
空间限制：32768 KB
题目描述：
一年一度的水果杯又来了，马上轮到笑有泪专场了，可是笑有泪要忙着实习，没空去买水果，他就让萌萌姐帮他买西瓜。笑有泪说了，钱不是问题，你买多少西瓜都行，但是我有两个条件：1.为了鼓励大家过题，过题数越多的人吃越大的西瓜，过题越少的人吃越小的西瓜，为了突出差距，要求最大的西瓜重量必须比最小的西瓜重M1，即（maxWeight-minWeight>=M1）；2.同时为了兼顾公平，不能太打击过题少的人，要求最大的西瓜不能比最小的西瓜重超过M2，即（maxWeight-minWeight<=M2）；萌萌姐一听开心了，心想我用个贪心算法不就行了嘛，笑有泪，你这次要破财咯:）。可是，聪明的笑有泪怎么可能没有看出萌萌姐的诡计，笑有泪又提出了最后一个条件：你买西瓜不能给老板添加麻烦，不可以东挑一个西挑一个，你只能买相邻挨着的西瓜。萌萌姐一下子傻眼了，想了三天三夜都没想出来，最后不得不求助于njust acmer们，并且答应只要做出来就送一个西瓜！
题目输入：
	多cases；	第一行有三个integers,n,M1,M2，n代表西瓜的个数，1<=n<=100000,0<=m,k<=1000000。	接下来一行有n个integers（W0,W1,W2,……）(0<=Wi<=1000000)，代表n个西瓜的重量（注意n个西瓜的有序性）。
题目输出：
	输出两个数：最多能买的西瓜数，西瓜的总重量（相同西瓜数输出最大总重值）。
输入样例：
3 0 0
1 1 1
5 3 5
1 2 3 4 5

输出样例：
3 3
5 15

提示：
None



题目：类和对象(1862)
时间限制：None
空间限制：None
题目描述：
设计一个类Person表示人，类的定义为：class Person{
	private:
		char name[20],sex,Id[20];
	public:
		void setPerson(char *p,char s,char *d){
		
		}
		char* getName(){
			
		}
		char getSex(){
			
		}
		char* getId(){
			
		}
};然后将人的信息按照格式输出。PS:字符串之间的copy，比如要将字符串a的值赋值给字符串b使用strcpy(b,a)
题目输入：
第一行输入一个t，代表t组数据，然后输入name，sex，Id;
题目输出：
按照Sample Output格式输出
输入样例：
2Joe m 20150106Jan f 20150107
输出样例：
The sex of Joe is mThe Id of Joe is 20150106The sex of Jan is fThe Id of Jan is 20150107
提示：
None



题目：Championmatch(1199)
时间限制：10000 ms
空间限制：65535 ms
题目描述：

Snow really loves football. Every year he spent lots of money on season's footballmatch. Of course, after spending so much money, he wants to see certain teams play each other. He worked out a complete list of games he wants to see. Now it is your task to distribute these games into rounds according to following rules:
1、In each round, each of the remaining football team plays at most one game 
2、If the number of remaining teams is an even number, every team plays exactly one game 
3、If the number of remaining teams is an odd number, there is one and only one team which plays no game (it advances with a wildcard to the next round) 
4、The winner of each game advances to the next round, the loser is kicked out from the tournament 
5、If there is only one team left, this team is declared the winner of the tournament 
As the induction, in such a tournament with n teams, there are exactly n - 1 games required until a winner is determined. 
Obviously, after round 1, teams may already have been kicked out which should take part in another game. To prevent this, for each game you also have to tell which team should win. 
题目输入：
The input file contains several test cases. Each test case starts with an integer n (2 ≤ n ≤ 1000), the number of teams participating in the tournament. The following n lines contain the names of the teams participating in the tournament. You can assume that each team name consists of up to 25 letters of the English alphabet ('a' to 'z' or 'A' to 'Z').
Then follow n - 1 lines, describing the games the sheikh would like to see (in any order). Each line consists of the two names of the teams which take part in that game. You can assume that it is always possible to find a tournament schedule consisting of the given games.
The last test case is followed by a zero. 

题目输出：
For each test case, write the game schedule, distributed in rounds.
For each round, first write "Round #X" (where X is the round number) in a line by itself. Then write the games scheduled in this round in the form: "A defeats B", where A is the name of the advancing team and B is the name of the team being kicked out. You may write the games of a round in any order. If a wildcard is needed for the round, write "A advances with wildcard" after the last game of the round, where A is the name of the team which gets the wildcard. After the last round, write the winner in the format shown below. Print a blank line after each test case.



输入样例：
3
A
B
C
A B
B C
5
A
B
C
D
E
A B
C D
A E
C E
0

输出样例：
Round #1
B defeats A
C advances with wildcard
Round #2
C defeats B
Winner: C

Round #1
A defeats B
C defeats D
E advances with wildcard
Round #2
E defeats A
C advances with wildcard
Round #3
E defeats C
Winner: E

提示：




题目：班聚(1343)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
在大学，班级聚会是常有的事。昨天，计科三班的同学们又班聚了。大家都知道，大学聚会大家都基本不吃菜的，都是一瓶瓶地灌酒，酒灌多了人就醉了。班长想知道这次班聚后多少人醉了。
    假设每个人都有一个固定的座位，酒量也是一定的。每个人会给某一桌敬酒，如果有人想去敬酒，却发现已经有人在敬酒了，那么他会等一等。所以，任一时刻只会有一个人出去敬酒。
题目输入：
多组测试数据，以文件末尾结束。对于每组测试数据
第一行一个整数N，表示有N个桌子
	接下来N行，每行开头一个整数M，表示这桌有M个人，接下来有M个整数，表示这桌每个人的编号（所有编号均不相同，不同桌也没有编号相同的人,编号连续，最大编号<=1000000）。
	然后为sigma(M)个整数，表示每个人的最大酒量，按编号从小到大顺序给出。
	接下来为一个整数K，表示K次敬酒
	下面有K组数据，每组两个值  a 和 b，表示编号为a的人给b桌的所有人敬酒(桌子编号按输入顺序依次为1~N)。
	(1<=N<=100, 1<=M<=100,1<=K<=100)

题目输出：
喝醉酒的人数
输入样例：
3
5 1  2  3  4  5
5 6  7  8  9  10
4 11  12  13  14
3  3  3  3  3  3  3  3  3  3  3  3  3  3
3
1 2
8 1
14  2

输出样例：
1
提示：
样例中，1先给2桌敬酒，8被敬了一杯。然后8向1桌敬酒，8喝了第二杯。最后14向2桌敬酒，8喝了第三杯。 由于每个人的酒量都是3，只有8喝到了3杯，只有他醉了，所以本例输出1.



题目：SimilarNumber(1746)
时间限制：5000 Ms
空间限制：65535 Kb
题目描述：
	We can call two numbers “similar” if their lengths are equal and we can make a number ‘’similar’’ through swapping some digits of itself. For instance, 123 is similar to 321 but 12 is not similar to 120.	A sequence can be called “similar sequence” if this sequence has only one pair of ‘’similar’’ numbers.	Now, Zero writes a series of integers and he needs you to answer his queries online. For each query, he gives you two integers l and r, which represent the two endpoints of a segment. He wants to know how many successive subsequences are “similar sequences”.
题目输入：
	There are multiple test cases.	In the first line of every test case there are two integers n (0<n<=100000) and m (0<=m<=100000), meaning that the sequence contains n integers and m queries.	   The next line contains n integers a[i] (1<=i<=n, a[i] <= 109), which represent the intergers in the sequence.	After that, there are m lines, each line containing two integers l and r.	Zero thinks that it is too simple for him to solve this problem, so he sets a variable k. In the beginning of each test case, k = 0. For each query, he sets l = l + k and r = r - k, Zero guarantees that 0<l<=r<=n, then make k the answer of this query.	The input ends with EOF.
题目输出：
	For each query, output an integer, and there is no blank line after each test.
输入样例：
5 5
2 2 2 2 2 
1 4
1 8
1 4
1 6
-1 5

输出样例：
3
1
1
3
0

提示：
None



题目：DualPalindromes(1446)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
A number that reads the same from right to left as when read from left to right is called a palindrome. The number 12321 is a palindrome; the number 77778 is not. Of course, palindromes have neither leading nor trailing zeroes, so 0220 is not a palindrome. The number 21 (base 10) is not palindrome in base 10, but the number 21 (base 10) is, in fact, a palindrome in base 2 (10101). Write a program that reads two numbers (expressed in base 10): N (1 <= N <= 15) S (0 < S < 10000) and then finds and prints (in base 10) the first N numbers strictly greater than S that are palindromic when written in two or more number bases (2 <= base <= 10). Solutions to this problem do not require manipulating integers larger than the standard 32 bits.
题目输入：
There are several test cases, end by EOF, for each test case:A single line with space separated integers N and S.
题目输出：
N lines, each with a base 10 number that is palindromic when expressed in at least two of the bases 2..10. The numbers should be listed in order from smallest to largest.
输入样例：
3 25
输出样例：
26
27
28
提示：




题目：DongDong’sProblem(1200)
时间限制：1000 ms
空间限制：65535 ms
题目描述：

A fan of order n is a graph on the vertices {0,1,… , n} with 2n-1 edges defined as follows: vertex 0 is connected by an edge to each of the other n vertices, and vertex k is connected by an edge to vertex k+1, for 1<=k<n. For example, here is the fan of order 4, which has five vertices and seven edges.
How many spanning trees fn are in such a graph? As you know,a spanning tree is a subgraph containing all the vertices, and containing enough edges to make the subgraph connected yet not so many that it has a cycle.


题目输入：
The input contains multiple test cases.The first line contains the number of test cases.For each test case, there is one integer n (1<=n<=1,000,000,000) in a line, indicate a fan of order n.
题目输出：
 For each test case, print one line with one integer: Thenumber of different spanning tree in the fan, moduled by 1,000,000,007.
输入样例：
3
1
2
100

输出样例：
1
3
349361645

提示：




题目：链表的创建(1863)
时间限制：None
空间限制：None
题目描述：
链表的结构体定义：struct Node{     int id;     Node *next;};给定n个数，将这n个数依次加入链表，然后输出
题目输入：
第一行输入一个t，代表t组数据，然后输入一个n，代表n个数，接下来输入n个数（均小于1000）
题目输出：
如Sample Output格式输出链表
输入样例：
151 2 3 4 5
输出样例：
1-2-3-4-5
提示：
None



题目：Yetanotherendoftheworld(1747)
时间限制：5000 Ms
空间限制：65535 Kb
题目描述：
	In the year 3013, it has been 1000 years since the previous predicted rapture. However, the Maya will not play a joke any more and the Rapture finally comes in. Fortunately people have already found out habitable planets, and made enough airships to convey all the human beings in the world. A large amount of airships are flying away the earth. People all bear to watch as this planet on which they have lived for millions of years. Nonetheless, scientists are worrying about anther problem…	As we know that long distance space travels are realized through the wormholes, which are given birth by the distortion of the energy fields in space. Airships will be driven into the wormholes to reach the other side of the universe by the suction devices placed in advance. Each wormhole has its configured attract parameters, X, Y or Z. When the value of ID%X is in [Y,Z], this spaceship will be sucked into the wormhole by the huge attraction. However, the spaceship would be tear into piece if its ID meets the attract parameters of two wormholes or more at the same time.	All the parameters are carefully adjusted initially, but some conservative, who treat the Rapture as a grain of truth and who are reluctant to abandon the treasure, combine with some evil scientists and disrupt the parameters. As a consequence, before the spaceships fly into gravity range, we should know whether the great tragedy would happen or not. Now the mission is on you.
题目输入：
Multiple test cases, ends with EOF.In each case, the first line contains an integer N(N<=1000), which means the number of the wormholes. Then comes N lines, each line contains three integers X,Y,Z(0<=Y<=Z<X<2*10^9).
题目输出：
If there exists danger, output “Cannot Take off”, else output “Can Take off”.
输入样例：
2
7 2 3
7 5 6
2
7 2 2
9 2 2
输出样例：
Can Take off
Cannot Take off

提示：
None



题目：MixingMilk(1447)
时间限制：1000 ms
空间限制：65535 ms
题目描述：
Since milk packaging is such a low margin business, it is important to keep the price of the raw product (milk) as low as possible. Help Merry Milk Makers get the milk they need in the cheapest possible manner. The Merry Milk Makers company has several farmers from which they may buy milk, and each one has a (potentially) different price at which they sell to the milk packing plant. Moreover, as a cow can only produce so much milk a day, the farmers only have so much milk to sell per day. Each day, Merry Milk Makers can purchase an integral amount of milk from each farmer, less than or equal to the farmer's limit. Given the Merry Milk Makers' daily requirement of milk, along with the cost per gallon and amount of available milk for each farmer, calculate the minimum amount of money that it takes to fulfill the Merry Milk Makers' requirements. Note: The total milk produced per day by the farmers will be sufficient to meet the demands of the Merry Milk Makers.
题目输入：
There are several test cases, end by EOF, for each test case:Line 1:  Two integers, N and M. The first value, N, (0 <= N <= 2,000,000) is the amount of milk that Merry Milk Makers' want per day. The second, M, (0 <= M <= 5,000) is the number of farmers that they may buy from.  Lines 2 through M+1:  The next M lines each contain two integers, Pi and Ai. Pi (0 <= Pi <= 1,000) is price in cents that farmer i charges.Ai (0 <= Ai <= 2,000,000) is the amount of milk that farmer i can sell to Merry Milk Makers per day.
题目输出：
A single line with a single integer that is the minimum price that Merry Milk Makers can get their milk at for one day.
输入样例：
100 5
5 20
9 40
3 10
8 80
6 30
输出样例：
630
提示：




题目：EconomicCybercall(1201)
时间限制：1000 ms
空间限制：65535 ms
题目描述：

The phone Cyber bought a long time ago(he lost it recently T-T) has a built-in memory that keeps track of all the calls you receive. It stores the date (month and day) and the time (hour and minute) of each call along with the caller's number. Only a limited number of calls can be stored (memory was still expensive then). 
You discover that the limit is almost reached and therefore plan to delete some entries from the store. In choosing the entries to delete you have to consider two restrictions: 
There are some (important) entries you want to keep. 
You want to be able to recover the year (which the phone does notstore) of each call you keep. The recovery procedure is described below. 
Calculate the minimal number of entries that must be kept to satisfy these requirements. 
Recovery of years
Given a list of timestamps (consisting of month, day, hour, and minute) of calls, you find out the year of each call by the following procedure: 
1.         The last call in the list occurred in the current year. 
2.         You compare its timestamp t to the timestamp t' of the previous call. If t'<t, you assume that both calls occurred in the same year. If t'≥t, you assume that the previous call occured the year before. 
3.         You iterate backwards through the list and reason as in 2. at each step. 
Note that this procedure is not correct in general, but you may assume that it is for the input you get, and you have to ensure that it gives the same result for the shortened store. 
Due to an error in the phone's software no calls have been stored on February 29.
 
题目输入：
The input consists of several test cases. Every test case starts with the number of entries n in the store, where 1≤n≤1000. Each of the next n lines contains an entry. 
Every entry has the format mm:dd:HH:MM number ±, describing the month mm, day dd, hour HH, minute MM, and number (having 1-16 digits) of each call, followed by + marking a call you definitively want to keep and by - marking the other calls. The entries come directly from the store of the phone, that is, they are sorted by time of reception of the corresponding call (the last entry is the most recent). 
You may assume that the recovery procedure described above yields the correct year of each call.
The last test case is followed by a 0. 

题目输出：
For each test case, output the minimal number of entries that must be kept to satisfy the requirements stated above. In particular, the recovery procedure described above must yield for each remaining entry the same year as derived from the corresponding input. 


输入样例：
7
12:31:23:59 0123456789012345 +
07:21:19:00 1337 -
01:01:00:00 0987654321 -
07:21:14:00 1337 -
11:11:11:11 11111111111 +
01:01:00:00 0123456789 +
01:01:00:00 0987654321 -
0

输出样例：
6
提示：




题目：类和对象(1864)
时间限制：None
空间限制：None
题目描述：
创建一个Date类，里面有三个私有成员：year，month，day然后类里实现三个成员函数：void setDate(int y,int m,int d){}bool isLeapYear(){}void print(){}对于每个对象判断是不是闰年，然后输出
题目输入：
第一行输入一个t，代表t组数据，然后输入year，month，day
题目输出：
先按照格式输出Date类，如果是闰年输出"is a leapyear"，否则输出"is not leapyear"
输入样例：
22000 10 12009 4 3
输出样例：
2000/10/1 is a leapyear2009/4/3 is not leapyear
提示：
PS:class Date{
	private:
		int year,month,day;
	public:
		void setDate(int y,int m,int d){
			
		}
		bool isLeapYear(){
			
		}
		void print(){
			
		}
};



题目：链表的查找(1865)
时间限制：None
空间限制：None
题目描述：
在B原有的基础上，在链表里对一个id=x的值进行查找，如果链表里存在id=x的值，就输出YES，否则输出NO。
题目输入：
第一行输入一个t，代表t组数据，然后输入一个n，代表n个数，接下来输入n个数，最后再输入一个m，代表m个查询，然后输入m个数（均小于1000）
题目输出：
对于每一个查询输出查询结果
输入样例：
151 2 3 4 532 4 6
输出样例：
YESYESNO
提示：
None



题目：链表的插入(1866)
时间限制：None
空间限制：None
题目描述：
在B原有的基础上，在id=x的后面插入一个id=value，输出插入后的链表
题目输入：
第一行输入一个t，代表t组数据，然后输入一个n，代表n个数，接下来输入n个数，最后再输入一个x和一个value（均小于1000）
题目输出：
如Sample Output格式输出插入后的链表
输入样例：
151 2 3 4 53 6
输出样例：
1-2-3-6-4-5
提示：
None



题目：链表的删除(1867)
时间限制：None
空间限制：None
题目描述：
在B原有的基础上，删除id=x的节点，然后将删除节点后的链表输出
题目输入：
第一行输入一个t，代表t组数据，然后输入一个n，代表n个数，接下来输入n个数，最后再输入一个x（均小于1000）
题目输出：
如Sample Output格式输出删除节点后的链表
输入样例：
151 2 3 4 53
输出样例：
1-2-4-5
提示：
None



题目：encrypt(1868)
时间限制：None
空间限制：None
题目描述：
将一段明文加密。加密的规则如下：将每个字符的ascii码的值减去24作为每个字符加密后的值，例如'a'的ascii码的值为97，那么加密后就变成了73。"73"就是'a'的密文。现在请你编写程序，对一段文字加密。请定义并使用如下函数： 
void encrypt(char *plain, char *cipher) 
{ 
    //把原文字符串plain加密后存入字符串cipher 
} 
题目输入：
第一行输入一个t，代表t组数据，接下来输入一串字符串，只包含数字和字母，最长为200.
题目输出：
输出加密后的字符串。
输入样例：
2
a
zero12
输出样例：
73
987790872526
提示：
直接输出密文当然是最简单的方法，不过本题要求你将密文存入字符串(以备程序的其它模块使用）。



题目：FourInagesStrategy(1869)
时间限制：None
空间限制：None
题目描述：
小F在祖屋中意外发现一本上古时代传承下来的秘籍，名为《四象阵法》，他按捺不住内心的激动，翻开秘籍，一字一句地读了起来，“用四块元石作为阵基摆放在空间四处位置，如果四块元石形成一个正方形，则阵法激活，有杀敌困敌之效”，小F走遍五湖四海，终于集齐了四块元石，并将四块元石放置在四个坐标点上，可是他不知道阵法是否能够成功激活，于是，由你来告诉他答案。
题目输入：
第一行只有一个整数<math><semantics><annotation encoding="application/x-tex">T\left(T\leq 10000 \right)</annotation></semantics></math>T(T≤100)，表示测试数据组数。接下来有<math><semantics><annotation encoding="application/x-tex">T</annotation></semantics></math>T行，每行包括12个整数表示四块元石的坐标<math><semantics><annotation encoding="application/x-tex">\left|x \right|,\left|y \right|,\left|z \right|\leq 100000</annotation></semantics></math>∣x∣,∣y∣,∣z∣≤1000。输入保证没有重点。
题目输出：
每组数据输出一行ans，如果阵法能够激活，<math><semantics><annotation encoding="application/x-tex">ans</annotation></semantics></math>ans为Yes，否则为No。
输入样例：
2
0 0 0 0 1 0 1 0 0 1 1 0
1 1 1 2 2 2 3 3 3 4 4 4
输出样例：
Yes
No
提示：
None



题目：Easy(1870)
时间限制：None
空间限制：None
题目描述：
给定一个字符串，求输出给定一段位置的子串。请定义并使用如下函数： 
void getSub(char *str,char *s,int a,int b)
{
	//从字符串str里面截取出s	
}
题目输入：
第一行读入一个整数T(1≤T≤100)，表示有T组数据。
接下来T行每行读入一个仅包含英文小写字母的字符串(∣S∣≤100)。                                                                                                                  再读入一个a和b，(0<=a<=b<∣S∣)                      
题目输出：
输出每组数组子字符串。
输入样例：
2
abcdefg
0 3
aabbccddee
1 4
输出样例：
abcd
abbc
提示：
PS:自己写截取函数，不要使用STL里面的函数，注意尾0，s[i]=0就是将第i位置成尾0



题目：poglovesszh(1871)
时间限制：None
空间限制：None
题目描述：
pog拥有很多字符串，它喜欢将两个长度相等字符串交错拼在一起，如abcd与efgh，那么交错拼在一起就成了aebfcgdh啦！
szh觉得这并不好玩，因此它将第二个字符串翻转了一遍，如efgh变成了hgfe，然后再将这两个字符串交错拼在一起，因此abcd与efgh就成了ahbgcfde啦！
现在问题来了，pog手里有一个由szh亲手拼好的字符串，它想还原出原来的两个字符串，出于szh对pog的爱，szh帮助pog还原出了原来的两个字符串。请定义并使用如下函数： 
void decompose(char *str,char *a,char *b)
{
	//将字符串str还原成字符串a和字符串b	
}
题目输入：
第一行读入一个整数<math><semantics><annotation encoding="application/x-tex">T(1 \leq T \leq 100)</annotation></semantics></math>T(1≤T≤100)，表示有<math><semantics><annotation encoding="application/x-tex">T</annotation></semantics></math>T组数据。
接下来<math><semantics><annotation encoding="application/x-tex">T</annotation></semantics></math>T行每行读入一个长度为偶数且仅包含英文小写字母的字符串<math><semantics><annotation encoding="application/x-tex">(|S| \leq 100)</annotation></semantics></math>(∣S∣≤100)。
题目输出：
对于每组数组，输出两行，表示原来的两个字符串。
输入样例：
1
aabbca
输出样例：
abc
aba
提示：
注意字符串a和字符串b的位置不要搞反了



题目：Numbers(1872)
时间限制：None
空间限制：None
题目描述：
给n个数，从中选3个位置不同的数A,B和C，问是否有一种情况满足A-B=C.请定义并使用如下函数： 
bool check(int *a,int n)
{
    //判断是否存在
}
题目输入：
第一行输入一个t，代表t组数据，每组数据第一行包含一个整数n，随后一行n个整数<math><semantics><annotation encoding="application/x-tex">{A}_{1},{A}_{2}....{A}_{n}</annotation></semantics></math>A​1​​,A​2​​....A​n​​.（<math><semantics><annotation encoding="application/x-tex">3\leq n\leq 100</annotation></semantics></math>3≤n≤100,<math><semantics><annotation encoding="application/x-tex">0\leq {A}_{i}\leq 1000</annotation></semantics></math>0≤A​i​​≤1000)
题目输出：
对于每组数据如果符合条件输出"YES"，否则输出"NO".
输入样例：
3                                                                                                                                                        3
3 1 2
3
1 0 2
4
1 1 0 2
输出样例：
YES
NO
YES
提示：
None



题目：冒泡排序(1873)
时间限制：None
空间限制：None
题目描述：
给定一个大小为n的数组，请使用冒泡排序方法对数组从小到大进行排序。（要求使用数组的指针和函数）PS：函数格式：void BubbleSort(int *a,int n){       }
题目输入：
第一行输入一个t（t<1000），接下来先输入一个n，然后再输入n个数（均不大于1000）
题目输出：
输出数组
输入样例：
231 3 244 3 2 1
输出样例：
1 2 31 2 3 4
提示：
None



题目：字符串转换(1874)
时间限制：None
空间限制：None
题目描述：
给定一个字符串，要求将大写字母变成小写字母，再将字符串输出（要求使用指针）PS：不要使用cin.getline(),注意行末有换行
题目输入：
第一行输入一个t（小于100），接下来每一行输入一个字符串str（长度小于1000）
题目输出：
输出处理后的字符串
输入样例：
2FontSizeADS
输出样例：
fontsizeads
提示：
None



题目：最小值(1875)
时间限制：None
空间限制：None
题目描述：
给定一个大小为n的数组，求最小值（要求使用指针）
题目输入：
第一行输入一个t（t<1000），接下来先输入一个n，然后再输入n个数（均不大于1000）
题目输出：
输出最小值
输入样例：
231 3 244 3 2 1
输出样例：
11
提示：
None



题目：成绩管理(1876)
时间限制：None
空间限制：None
题目描述：
编写一个程序，管理学生的考试成绩，要记录姓名，成绩。现在，你已经知道了班上n个同学的姓名和成绩，你需要做如下的一些查询：1：输入一个学生的姓名，查询他的成绩2：输入一个分数段[a,b]，查询在这个分数段有多少个同学。
题目输入：
第一行输入一个t（t<10），接下来先输入一个n，然后接下来n行，每一行输入学生姓名和成绩，再输入一个m，接下来又m行，每行输入有两种情况，第一种： 1  姓名 （输入一个学生的姓名，查询他的成绩）第二种： 2 a b （输入一个分数段[a,b]，查询在这个分数段有多少个同学）(n<100,m<100,0<=a<b<=100,姓名的长度小于20);
题目输出：
对于相应的查询，输出结果
输入样例：
15Ane 80Tom 70Jean 50Steanf 78Hony 8541 Hony2 70 801 Jean2 10 20
输出样例：
853500
提示：
None



题目：统计数字(1877)
时间限制：None
空间限制：None
题目描述：
输入一个字符串，串里只含有数字和字母，如：abc123def456he789将其中连续的数字作为一个整数，依次存放到另一个整型数组b中。如对以上的输入，将123存放到b[0],456存放到b[1]，789存放到b[2]，统计字符串中的整数个数，并输出这些整数。要求：在主函数中完成输入和输出，设计一个函数，把指向字符串的指针和指向整数的指针作为函数形参
题目输入：
第一行输入一个t（小于100），接下来每一行输入一个字符串str（长度小于1000）
题目输出：
先输入字符串中整数的个数，然后输出所有整数
输入样例：
2abc123def456he789afdjsk1sa2sf3sfs4
输出样例：
3123 456 78941 2 3 4
提示：
None



题目：★★★★★(1878)
时间限制：None
空间限制：None
题目描述：
任意给定一个数组a[],我们对数组有两种操作：1、将前n-1个数从小到大排序2、将后n-1个数从小到大排序现在，你有一个数组，长度为n，你每一次可以执行上面的操作之一，请问最少需要几次操作可以将一个数组按照升序的方式排列好
题目输入：
第一行输入一个t（t<1000），接下来输入一个n代表数组的长度，接下来输入n个数
题目输出：
输出最少操作次数
输入样例：
251 2 3 5 466 4 3 1 2 5
输出样例：
12
提示：
样例解释：1、执行第2个操作，将后n-1个数排序就可以得到升序的数列了，所以答案是12、先执第1个操作，将前n-1个数排序，再执行第2个操作，将后n-1个数排序就可以得到升序的数列了，所以答案是2



题目：★★★★(1879)
时间限制：None
空间限制：None
题目描述：
求两个在不同进制下的数之和
题目输入：
第一行输入一个t（t<1000），接下来每一行输入一个a和p，代表a在p进制下的数，一个b和一个q，代表b在q进制下的数（1<a,b<10000，1<p,q<11）
题目输出：
输入a+b在十进制下的和
输入样例：
210 2 12 356 10 32 10
输出样例：
888
提示：
样例解释：1、10在2进制下是2，12在3进制下是5，所以2+5=72、都是在10进制下，所以56+32=88PS：将任意进制转换成十进制的方法：例如：1234  在5进制下转换为10进制下的数：1*(5^3)+2*(5^2)+3*(5^1)+4*(5^0)=194



题目：★★★(1880)
时间限制：None
空间限制：None
题目描述：
任意输入一个数组，将数组的数据反向排列后输出（使用指针在函数间传递一维数组，注意空格和换行，不要多空格，也不要少了换行）
题目输入：
第一行输入一个t（t<1000），接下来先输入一个n，然后再输入n个数（均不大于1000）
题目输出：
输入反向排列后的数组
输入样例：
241 2 3 455 4 3 2 1
输出样例：
4 3 2 11 2 3 4 5
提示：
PS:例如数组大小为n的输出格式参考int a[n];for (int i=0;i<n-1;i++)       cout<<a[i]<<" ";cout<<a[n-1]<<endl;PS:例如数组大小为n的输出格式参考int a[n];for (int i=n-1;i>0;i--)       cout<<a[i]<<" ";cout<<a[0]<<endl;



题目：★★(1881)
时间限制：None
空间限制：None
题目描述：
任意输入三个数，按照大小顺序输出这三个数（使用指针变量作为函数参数，注意空格和换行，不要多空格，也不要少了换行）
题目输入：
第一行输入一个t（t<1000），接下来每一行输入一个a和一个b，一个c（不大于1000）
题目输出：
按照降序的顺序排列
输入样例：
21 2 33 1 2
输出样例：
3 2 13 2 1
提示：
None



题目：★(1882)
时间限制：None
空间限制：None
题目描述：
任意输入两个数，按大小顺序输出这两个数（使用指针，注意空格和换行，不要多空格，也不要少了换行）
题目输入：
第一行输入一个t（t<1000），接下来每一行输入一个a和一个b（不大于1000）
题目输出：
先输出最大值，再输入最小值
输入样例：
21 25 3
输出样例：
2 15 3
提示：
None



题目：感恩节—数组之“ThanksgivingDay”(1883)
时间限制：None
空间限制：None
题目描述：
感恩节来临之际，某同学给老师发了一封只含有“Thanksgiving Day”这几个字母和空格的邮件（有很多个“Thanksgiving Day”），由于文件出错，导致这些字符的顺序都发生了改变，并且有某些字符缺失，导致老师看不出有多少个“Thanksgiving Day”，老师想知道该同学给老师发了多少个“Thanksgiving Day”，现在向你求助，希望你聪明的你可以告诉老师这封邮件里有多少个“Thanksgiving Day”（保证只含有“Thanksgiving Day”这些字母和空格，有些字母可能无法组成”Thanksgiving Day“）
题目输入：
第一行输入一个t，代表有t组测试数据，接下来t行，每行都含有一个字符串str，代表邮件(长度不超过1000)
题目输出：
输出邮件内含有多少个“Thanksgiving Day”
输入样例：
4Thanksgiving Day Thanksgiving DayThanksgiving DThanksgiving DayaThanksgiving DayyThanksgivingThanksgiving DayDayyan gnahnDng sigk asgnsTggvvThaiiDgsgngg gDshivnyh snDaDgyiingkiTnTyDasDyiTgDh
输出样例：
2312
提示：
第三个样例，可以转换为“Thanksgiving DayThanksgivingDay”，最后一个“Thanksgiving Day”缺失一个空格，所有无法组成第二个“Thanksgiving Day”，所以只有一个“Thanksgiving Day”参考代码规范：#include <iostream>
#include <stdio.h>
#include <string.h>
using namespace std;
#define N 1000
int main(){
	int t;
	char s[N];
	cin>>t;
	getchar();	//C语言上的
	while (t--){
		cin.getline(s,N);	}
	return 0;
}



题目：感恩节—数组之二维数组(1884)
时间限制：None
空间限制：None
题目描述：
输入一个二维数组，求二维数组中最大值
题目输入：
第一行输入一个t, 表示有t组数据，然后n,m代表输入一个n行m列的数组，接下来n行，每行输入m个数（1<t<1000,1<n,m<100）
题目输出：
输出最大值
输入样例：
22 31 2 34 5 63 31 1 11 1 11 1 1
输出样例：
61
提示：
None



题目：感恩节—数组之字符数组处理(1885)
时间限制：None
空间限制：None
题目描述：
感恩节来临，当老师对字符串进行了逐个输出后，发现某些空格缺失了，所以老师现在要将字符数组中的空格替换为#，然后再将这个字符数组输出（字符数组长度不超过1000）
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入字符数组s[]（1<t<1000）
题目输出：
输出处理后的字符数组s[]
输入样例：
1Thanksgiving Day
输出样例：
Thanksgiving#Day
提示：
PS:不要用getchar，使用cin.getline参考代码规范：#include <iostream>
#include <stdio.h>//C语言
#include <string.h>
using namespace std;
#define N 1000
int main(){
	int t;
	char s[N];
	cin>>t;cin.getline(s,N);
	//getchar();	//C语言上的，用来获取换行'\n'
	while (t--){
		cin.getline(s,N);                //剩下自己考虑
	}
	return 0;
}



题目：感恩节—数组之字符串遍历(1886)
时间限制：None
空间限制：None
题目描述：
感恩节来临，老师得到一个字符串s，现在老师想对这个字符串进行输出，需要依次输出每一个字符。（s的长度不超过1000）
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入字符串s（1<t<1000）
题目输出：
依次输出每一个字符
输入样例：
1ThanksgivingDay
输出样例：
ThanksgivingDay
提示：
参考代码规范：#include <iostream>
#include <string.h>
using namespace std;
#define N 1000+1
int main(){
	int t;
	char s[N];
	cin>>t;
	while (t--){
		cin>>s;
		//剩下自己补充
	}
	return 0;
}



题目：感恩节—函数之计算平均成绩(1887)
时间限制：None
空间限制：None
题目描述：
又到了感恩节这一天，祝老师感恩节快乐！老师想了解同学们在vc++这门课的学习情况，于是对大家5次训练得分的平均分作为检验方式，然而班上的人数比较多，每一个人的成绩都去计算太麻烦，于是老师想通过一个函数调用程序来快速计算。老师将5次训练分数存储在一个数组a[]中，老师希望你能设计一个以数组a[]为形参的函数，用来计算平均成绩。
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入5个数（1<t<1000）
题目输出：
输出每个学生的平均成绩(只保留整数，四舍五入)PS：对于a/b的结果进行四舍五入的方法：a/b+(a%b>b/2?1:0)例如:[19/5] = 19/5+(19%5>5/2?1:0) = 3 + (4>2?1:0) = 3+1=4[17%5] = 17/5+(17%5>5/2?1:0) = 3 + (2>2?1:0) = 3+0=3
输入样例：
35 5 5 5 54 4 3 4 43 3 3 4 4
输出样例：
543
提示：
/*******************************************************************************************************************************************************************************/关注我的新浪微博：JinbaoSite ，题解我会在周五晚上发布在这个微博上/******************************************************************************************************************************************************************************/参考代码规范：#include <iostream>
using namespace std;
#define N 5int Cal(int a[]){     return ?;   //自己考虑}
int main(){
	int t;
	int a[N];
	cin>>t;
	while (t--){
		for (int i=0;i<5;i++){
			cin>>a[i];
		}                int ans=Cal(a);                cout<<ans<<endl;
	}
	return 0;
}



题目：Fib数列(1892)
时间限制：None
空间限制：None
题目描述：
某数列a[]满足，a[0]=1，a[1]=1，a[n]=a[0]+a[1]+...+a[n-1]，现在让你求第n项是什么？(本题用函数递归调用做,数列为等比数列)
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入一个正整数n（1<=n<=30）
题目输出：
输出第n项
输入样例：
3234
输出样例：
248
提示：
样例说明：n=2: a[2]=a[1]+a[0]=1+1=2;n=3: a[3]=a[2]+a[1]+a[0]=2+1+1=4;n=4; a[4]=a[3]+a[2]+a[1]+a[0]=4+2+1+1=8;



题目：素数的个数(1893)
时间限制：None
空间限制：None
题目描述：
给定整数a和整数b，求在[a,b]内有多少个素数(本题素数的判断用函数调用)
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入一个a和一个b（1<=a<=b<=1000）
题目输出：
输出在[a,b]内有素数的个数
输入样例：
21 1011 20
输出样例：
44
提示：
样例解释：（1）在[1,10]内素数有2,3,5,7,所以有4个素数（2）在[11,20]内素数有11,13,17,19，所以有4个素数PS：素数：一个大于1的自然数，除了1和它本身外，不能被其他自然数的整数。



题目：次数统计(1894)
时间限制：None
空间限制：None
题目描述：
给定一个数组a[],求数组中出现次数最多的数，它出现的次数是多少？
题目输入：
第一行输入一个t, 表示有t组数据，然后输入一个n，接下来一行输入n个数，数组内的值在[0,1000]。（1<n<1000000）
题目输出：
输出出现次数最多的数的次数
输入样例：
1101 2 3 4 5 1 2 1 2 3
输出样例：
3
提示：
样例解释：1出现的次数:32出现的次数:33出现的次数:24出现的次数:15出现的次数:1所以出现次数最多的数的次数是3



题目：求差(1895)
时间限制：None
空间限制：None
题目描述：
给定整数a和b，求a，b之差(要求使用函数求绝对值)PS：不要出现cin>>endl;这是错误的语句
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入输入a，b（1<a,b<1000）
题目输出：
输出a和b的差
输入样例：
23 2100 899
输出样例：
1799
提示：
样例说明：|3-2|=1|100-899|=|-799|=799



题目：MIN(1896)
时间限制：None
空间限制：None
题目描述：
给定一个一维数组，求数组内的最小值是多少？
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入输入一个n，接下来一行输入n个数（1<n<10000）
题目输出：
输出最小值
输入样例：
251 5 3 2 482 2 2 2 2 1 2 2
输出样例：
11
提示：
None



题目：二项式求解(1897)
时间限制：1000ms
空间限制：63746KB
题目描述：
给定a，b，c，请你判断a*x^2 + b*x + c = 0 是否有实数解？
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入一个a，一个b和一个c （1<t<1000 , 1<= a , b , c <= 1000）
题目输出：
如果二项式有解，输出“YES”，否则输出“NO”
输入样例：
31 2 11 1 11 4 4
输出样例：
YESNOYES
提示：
样例解释：（1）x^2 + 2*x + 1 = 0 可以化简为 (x+1)^2 = 0，所以存在x=-1的解；（2）x^2 + x + 1 = 0 可以化简为 (x+1/2)^2 + 3/4 = 0，所以不存在解；（3）x^2 + 4*x + 4 = 0 可以化简为 (x+2)^2 = 0，所以存在x=-2的解；PS:#include <iostream>
using namespace std;
int main(){
	/*              核心代码填写处        */	return 0;
}



题目：筛选求和(1898)
时间限制：1000ms
空间限制：63574KB
题目描述：
给你一个n和m，求1-n不被m整除的所有数之和
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入一个n和一个m （1<t<1000 , 1<= n,m <=10000）
题目输出：
输出1-n不被m整除的所有数之和
输入样例：
210 513 3
输出样例：
4061
提示：
样例解释：（1）1+2+3+4+6+7+8+9 = 40（2）1+2+4+5+7+8+10+11+13=61



题目：直角三角形(1899)
时间限制：1000ms
空间限制：64735KB
题目描述：
给你一个整数a和一个整数b，希望你可以找到一个整数c，使得a,b,c作为直角三角形的三条边;（本题请用函数调用做）
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入一个a和一个b （1<t<1000 , 1<= a , b <=1000）
题目输出：
如果可以找到一个c使得a,b,c作为直角三角形的三条边，那就输出c的值，如果不能找到c，那就输出”NO“
输入样例：
33 41 112 13
输出样例：
5NO5
提示：
样例解释：(1)3^2 + 4^2 = 5^2，所以存在c=5满足条件(2)找不到，输出”NO“(3)5^2 + 12^2 = 13^2，所以存在c=5满足条件



题目：Fibonaccisequence(1900)
时间限制：1000ms
空间限制：32679KB
题目描述：
有这样一个数列a[]，a[0]=1，a[1]=1，a[n]=a[n-1]+3*a[n-2]，现在让你求第n项是什么？（本题用函数递归调用做）
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入一个正整数n（1<=n<=26）
题目输出：
输出第n项
输入样例：
41234
输出样例：
14719
提示：
None



题目：数位和(1901)
时间限制：1000ms
空间限制：32768KB
题目描述：
给你两个数a和b，求a到b的所有数位之和PS：a和b都是三位数
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入一个a和一个b（1<t<100,100<=a,b<=999）
题目输出：
输出所有数位之和
输入样例：
2100 105200 210
输出样例：
2168
提示：
样例说明：（1）(1+0+0) + (1+0+1) + (1+0+2) + (1+0+3) + (1+0+4) + (1+0+5) = 21（2）(2+0+0) + (2+0+1) + (2+0+2) + (2+0+3) + (2+0+4) + (2+0+5) + (2+0+6) + (2+0+7) + (2+0+8) + (2+0+9) + (2+1+0) = 68



题目：A+B(1902)
时间限制：1000ms
空间限制：32768KB
题目描述：
给定A和B，求A+B
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入一个A和一个B（1<=A,B<=1000000）
题目输出：
输出A + B （注意输出格式，不要多空格，不要少换行）
输入样例：
241 18467
6334 26500
输出样例：
41 + 18467 = 18508
6334 + 26500 = 32834
提示：
示例代码（注意书写格式）：#include <iostream>
using namespace std;
int main(){
	int t,a,b;        cin>>t;
	while (t--){                cin>>a>>b;
		cout<<a<<" + "<<b<<" = "<<a+b<<endl;
	}
	return 0;
}或者：#include <iostream>
using namespace std;
int main(){
	int t,a,b;        cin>>t;
	for (int i=1;i<=t;i++)       {                cin>>a>>b;
		cout<<a<<" + "<<b<<" = "<<a+b<<endl;
	}
	return 0;
}注：（1）必须以下面格式作为提交：#include <iostream>
using namespace std;
int main(){
	/*              核心代码填写处        */	return 0;
}不能使用#include <iostream.h>以及#include<stdafx.h>（2）注意输入输出格式，不要少了空格和换行;例如本题，输出格式中，“+”、“=”的前面和后面都有一个空格，输出A+B后，要注意换行。（3）常见提交结果显示：Accepted                           说明答案对了
Wrong Answer                  说明错了
Time Limit Exceeded       超时
Memory Limit Exceeded  超内存
Compilation Error             编译错误
Presentation Error            格式错误 一般是空格和换行的问题



题目：阶乘和(1903)
时间限制：1000ms
空间限制：32760KB
题目描述：
给定一个n，求1!+2!+3!+..+n!;
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入一个n（1<=n<=10）
题目输出：
输出阶乘和
输入样例：
31
2
3
输出样例：
1
3
9
提示：
样例说明：1!=1;1!+2!=1+2=3;1!+2!+3!=1+2+6=9;注意：所有存在代码完全一样的，全部无效，不计算分值。



题目：猴子吃桃(1904)
时间限制：1000ms
空间限制：32679KB
题目描述：
一只猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个；第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半加一个。到第N天早上想再吃时，见只剩下一个桃子了。问：第一天共摘了多少个桃子？
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入正整数N（1<=N<=20）
题目输出：
输出桃子的个数
输入样例：
41
2
3
4
输出样例：
1
4
10
22
提示：
样例说明：对N=4解释：第1天早上有22个，吃掉一半，再吃掉一个，剩下10个；第2天早上有10个，吃掉一半，再吃掉一个，剩下4个；第3天早上有4个，吃掉一半，在吃掉一个，剩下1个；第4天早上有1个；注意：所有存在代码完全一样的，全部无效，不计算分值。



题目：打印菱形(1905)
时间限制：1000ms
空间限制：32679KB
题目描述：
当N=1时，菱形为*当N=2时，菱形为 *
***
 *当N=3时，菱形为  *
 ***
*****
 ***
  *当N=4时，菱形为   *
  ***
 *****
*******
 *****
  ***
   *从其中找出规律，对于任意的N，打印出相应的菱形；
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入一个正整数N（1<=N<=20）
题目输出：
将菱形打印出来
输入样例：
41
2
3
4
输出样例：
*
 *
***
 *
  *
 ***
*****
 ***
  *
   *
  ***
 *****
*******
 *****
  ***
   *
提示：
注意：不要输出多余的空格注意：所有存在代码完全一样的，全部无效，不计算分值。



题目：矩形(1906)
时间限制：1000ms
空间限制：32679KB
题目描述：
给你一个高为n ，宽为m列的网格，计算出这个网格中有多少个矩形，下图为高为2，宽为4的网格.
题目输入：
第一行输入一个t, 表示有t组数据，然后每行输入n,m,分别表示网格的高和宽 ( n < 20, m < 20).
题目输出：
输出网格中有多少个矩形.
输入样例：
21 2
2 4
输出样例：
3
30
提示：
样例说明：在1 X 2的网格中有1 X 1 的矩形2个，1 X 2 的矩形1个，所以总共有3个矩形；注意：所有存在代码完全一样的，全部无效，不计算分值。



题目：数组一(1907)
时间限制：None
空间限制：None
题目描述：
有一个长度为n（不超过1000）的数组，现在需要你对他们的所有值（在-1000到1000之间）求和ps:不要在一个题目上浪费大量的时间，后面的题目不见得会更难做，学会取舍。
题目输入：
第一行输入一个t（小于100），接下来每一行输入一个n，再输入n个数
题目输出：
输出这些数之和
输入样例：
251 2 3 5 631 2 3
输出样例：
176
提示：
常见错误:1.数组的大小太小了，数组需要开到10002.在求和时，每一次求和,用来记录答案的数要重新清0。



题目：数组二(1908)
时间限制：None
空间限制：None
题目描述：
有一个长度为n（不超过1000）的数组，现在求最大值和最小值之差？
题目输入：
第一行输入一个t（小于100），接下来每一行输入一个n，再输入n个数（在-1000到1000之间）
题目输出：
输入最大值减最小值
输入样例：
251 2 3 5 631 2 3
输出样例：
52
提示：
None



题目：函数一(1909)
时间限制：None
空间限制：None
题目描述：
对于任意一个数x（0<=x<=1000），判断x是不是素数，要求判断一个数是不是素数用函数bool isprime(int x){        return ?;//自己考虑}来判断
题目输入：
第一行输入一个t（小于100），接下来每一行输入一个x
题目输出：
如果是素数，输出“YES”，否则输出“NO”
输入样例：
33611
输出样例：
YESNOYES
提示：
None



题目：函数二(1910)
时间限制：None
空间限制：None
题目描述：
已知f[0]=0f[1]=1f[2]=1f[3]=f[2]+f[1]+f[0]...f[n]=f[n-1]+f[n-2]+f[n-3]任意给定一个n（1<n<20），求f[n]的值；(要求使用函数调用)
题目输入：
第一行输入一个t（小于100），接下来每一行输入一个n
题目输出：
输出f[n];
输入样例：
35911
输出样例：
781274
提示：
None



题目：数组三(1911)
时间限制：None
空间限制：None
题目描述：
现在有一个二维数组a[][]，现在从二维数组里面选两个数，要求两个数不在同一行，也不在同一列，求这两个数之和最大是多少？
题目输入：
第一行输入一个t（小于100），接下来t组数据中，先输入n，m（小于50）代表二维数组的行和列，接下来n行，每行输入m个数（小于1000）
题目输出：
输出两个数之和的最大值
输入样例：
14 41 2 3 45 6 7 84 3 2 18 7 6 5
输出样例：
16
提示：
None



题目：数组四(1912)
时间限制：None
空间限制：None
题目描述：
给定一个字符串，要求将小写字母变成大写字母，再将字符串输出
题目输入：
第一行输入一个t（小于100），接下来每一行输入一个字符串str（长度小于1000）
题目输出：
输出处理后的字符串
输入样例：
1FontSize
输出样例：
FONTSIZE
提示：
不要使用cin.getline()



题目：综合二(1913)
时间限制：None
空间限制：None
题目描述：
按照如下规则打印菱形n=1：0n=2:  1101  1n=3:    0  21221012  212    0n=4:      3    323  321233210123  32123    323      3输入一个n（1<=n<=10），输出菱形
题目输入：
第一行输入一个t（小于11），接下来每一行输入一个n
题目输出：
输出菱形
输入样例：
3234
输出样例：
  1101  1    0  21221012  212    0      3    323  321233210123  32123    323      3
提示：
None



题目：综合一(1914)
时间限制：None
空间限制：None
题目描述：
给定a，b，c，求a，b，c三个数的最小公倍数和最大共约数之和
题目输入：
第一行输入一个t（小于100）, 表示有t组数据，然后每行输入a,b,c(小于1000)
题目输出：
最小公倍数和最大共约数之和
输入样例：
22 3 43 6 9
输出样例：
1321
提示：
None



题目：数位之和(1915)
时间限制：1.0s
空间限制：256.0MB
题目描述：
给定一个十进制整数n，输出n的各位数字之和。
题目输入：
输入一个整数n。
题目输出：
输出一个整数，表示答案。
输入样例：
20151220
输出样例：
13
提示：
样例说明
　　20151220的各位数字之和为2+0+1+5+1+2+2+0=13。
评测用例规模与约定
　　所有评测用例满足：0 ≤ n ≤ 1000000000。



题目：消除类游戏(1916)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　消除类游戏是深受大众欢迎的一种游戏，游戏在一个包含有n行m列的游戏棋盘上进行，棋盘的每一行每一列的方格上放着一个有颜色的棋子，当一行或一列上有连续三个或更多的相同颜色的棋子时，这些棋子都被消除。当有多处可以被消除时，这些地方的棋子将同时被消除。
　　现在给你一个n行m列的棋盘，棋盘中的每一个方格上有一个棋子，请给出经过一次消除后的棋盘。
　　请注意：一个棋子可能在某一行和某一列同时被消除。
题目输入：
　　输入的第一行包含两个整数n, m，用空格分隔，分别表示棋盘的行数和列数。
　　接下来n行，每行m个整数，用空格分隔，分别表示每一个方格中的棋子的颜色。颜色使用1至9编号。
题目输出：
　　输出n行，每行m个整数，相邻的整数之间使用一个空格分隔，表示经过一次消除后的棋盘。如果一个方格中的棋子被消除，则对应的方格输出0，否则输出棋子的颜色编号。
输入样例：
4 5
2 2 3 1 2
3 4 5 1 4
2 3 2 1 3
2 2 2 4 44 5
2 2 3 1 2
3 1 1 1 1
2 3 2 1 3
2 2 3 3 3
输出样例：
2 2 3 0 2
3 4 5 0 4
2 3 2 0 3
0 0 0 4 42 2 3 0 2
3 0 0 0 0
2 3 2 0 3
2 2 0 0 0
提示：
样例说明
　　棋盘中第4列的1和第4行的2可以被消除，其他的方格中的棋子均保留。样例说明
　　棋盘中所有的1以及最后一行的3可以被同时消除，其他的方格中的棋子均保留。
评测用例规模与约定
　　所有的评测用例满足：1 ≤ n, m ≤ 30。



题目：画图(1917)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　用 ASCII 字符来画图是一件有趣的事情，并形成了一门被称为 ASCII Art 的艺术。例如，下图是用 ASCII 字符画出来的 CSPRO 字样。
　　..____.____..____..____...___..
　　./.___/.___||.._.\|.._.\./._.\.
　　|.|...\___.\|.|_).|.|_).|.|.|.|
　　|.|___.___).|..__/|.._.<|.|_|.|
　　.\____|____/|_|...|_|.\_\\___/.
　　本题要求编程实现一个用 ASCII 字符来画图的程序，支持以下两种操作：
　　 画线：给出两个端点的坐标，画一条连接这两个端点的线段。简便起见题目保证要画的每条线段都是水平或者竖直的。水平线段用字符 - 来画，竖直线段用字符 | 来画。如果一条水平线段和一条竖直线段在某个位置相交，则相交位置用字符 + 代替。
　　 填充：给出填充的起始位置坐标和需要填充的字符，从起始位置开始，用该字符填充相邻位置，直到遇到画布边缘或已经画好的线段。注意这里的相邻位置只需要考虑上下左右 4 个方向，如下图所示，字符 @ 只和 4 个字符 * 相邻。
　　.*.
　　*@*
　　.*.
题目输入：
　　第1行有三个整数m, n和q。m和n分别表示画布的宽度和高度，以字符为单位。q表示画图操作的个数。
　　第2行至第q + 1行，每行是以下两种形式之一：
　　 0 x1 y1 x2 y2：表示画线段的操作，(x1, y1)和(x2, y2)分别是线段的两端，满足要么x1 = x2 且y1 ≠ y2，要么 y1 = y2 且 x1 ≠ x2。
　　 1 x y c：表示填充操作，(x, y)是起始位置，保证不会落在任何已有的线段上；c 为填充字符，是大小写字母。
　　画布的左下角是坐标为 (0, 0) 的位置，向右为x坐标增大的方向，向上为y坐标增大的方向。这q个操作按照数据给出的顺序依次执行。画布最初时所有位置都是字符 .（小数点）。
题目输出：
　　输出有n行，每行m个字符，表示依次执行这q个操作后得到的画图结果。
输入样例：
4 2 3
1 0 0 B
0 1 0 2 0
1 0 0 A16 13 9
0 3 1 12 1
0 12 1 12 3
0 12 3 6 3
0 6 3 6 9
0 6 9 12 9
0 12 9 12 11
0 12 11 3 11
0 3 11 3 1
1 4 2 C
输出样例：
AAAA
A--A................
...+--------+...
...|CCCCCCCC|...
...|CC+-----+...
...|CC|.........
...|CC|.........
...|CC|.........
...|CC|.........
...|CC|.........
...|CC+-----+...
...|CCCCCCCC|...
...+--------+...
................
提示：
　　所有的评测用例满足：2 ≤ m, n ≤ 100，0 ≤ q ≤ 100，0 ≤ x < m（x表示输入数据中所有位置的x坐标），0 ≤ y < n（y表示输入数据中所有位置的y坐标）。



题目：送货(1918)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　为了增加公司收入，F公司新开设了物流业务。由于F公司在业界的良好口碑，物流业务一开通即受到了消费者的欢迎，物流业务马上遍及了城市的每条街道。然而，F公司现在只安排了小明一个人负责所有街道的服务。
　　任务虽然繁重，但是小明有足够的信心，他拿到了城市的地图，准备研究最好的方案。城市中有n个交叉路口，m条街道连接在这些交叉路口之间，每条街道的首尾都正好连接着一个交叉路口。除开街道的首尾端点，街道不会在其他位置与其他街道相交。每个交叉路口都至少连接着一条街道，有的交叉路口可能只连接着一条或两条街道。
　　小明希望设计一个方案，从编号为1的交叉路口出发，每次必须沿街道去往街道另一端的路口，再从新的路口出发去往下一个路口，直到所有的街道都经过了正好一次。
题目输入：
　　输入的第一行包含两个整数n, m，表示交叉路口的数量和街道的数量，交叉路口从1到n标号。
　　接下来m行，每行两个整数a, b，表示和标号为a的交叉路口和标号为b的交叉路口之间有一条街道，街道是双向的，小明可以从任意一端走向另一端。两个路口之间最多有一条街道。
题目输出：
　　如果小明可以经过每条街道正好一次，则输出一行包含m+1个整数p1, p2, p3, ..., pm+1，表示小明经过的路口的顺序，相邻两个整数之间用一个空格分隔。如果有多种方案满足条件，则输出字典序最小的一种方案，即首先保证p1最小，p1最小的前提下再保证p2最小，依此类推。
　　如果不存在方案使得小明经过每条街道正好一次，则输出一个整数-1。
输入样例：
4 5
1 2
1 3
1 4
2 4
3 44 6
1 2
1 3
1 4
2 4
3 4
2 3
输出样例：
1 2 4 1 3 4-1
提示：
样例说明
　　城市的地图和小明的路径如下图所示。样例说明　　城市的地图如下图所示，不存在满足条件的路径。
 评测用例规模与约定
　　前30%的评测用例满足：1 ≤ n ≤ 10, n-1 ≤ m ≤ 20。
　　前50%的评测用例满足：1 ≤ n ≤ 100, n-1 ≤ m ≤ 10000。
　　所有评测用例满足：1 ≤ n ≤ 10000，n-1 ≤ m ≤ 100000。




题目：矩阵(1919)
时间限制：1.0s
空间限制：256.0MB
题目描述：
　　创造一个世界只需要定义一个初状态和状态转移规则。
　　宏观世界的物体运动规律始终跟物体当前的状态有关，也就是说只要知道物体足够多的状态信息，例如位置、速度等，我们就能知道物体之后任意时刻的状态。
　　现在小M创造了一个简化的世界。
　　这个世界中，时间是离散的，物理规律是线性的：世界的初始状态可以用一个m维向量b(0)表示，状态的转移方式用m×m的矩阵A表示。
　　若已知这个世界当前的状态是b，那么下一时刻就等于b左乘状态转移矩阵A，即Ab。
　　这个世界中，物体的状态也是离散的，也就是说可以用整数表示。再进一步，整数都可以用二进制编码拆分为有限位0和1。因此，这里的矩阵A和向量b的每个元素都是0或1，矩阵乘法中的加法运算视为异或运算（xor），乘法运算视为与运算（and）。
　　具体地，设矩阵A第i行第j列的元素为ai, j，向量b的第i个元素为bi。那么乘法Ab所得的第k个元素为
　　(ak,1 and b1) xor (ak,2 and b2) xor ⋯ xor (ak,m and bm)
　　矩阵和矩阵的乘法也有类似的表达。
　　小M发现，这样的矩阵运算也有乘法结合律，例如有A(Ab)=(AA)b=A2b。
　　为了保证自己创造的世界维度不轻易下降，小M保证了矩阵A可逆，也就是说存在一个矩阵A-1，使得对任意向量d，都有A-1Ad=d。
　　小M想了解自己创造的世界是否合理，他希望知道这个世界在不同时刻的状态。
　　具体地，小M有n组询问，每组询问会给出一个非负整数k，小M希望你帮他求出Akb。
题目输入：
　　输入第一行包含一个整数m，表示矩阵和向量的规模。
　　接下来m行，每行包含一个长度为m的01串，表示矩阵A。
　　接下来一行，包含一个长度为m的01串，表示初始向量b(0)。（b(0)是列向量，这里表示它的转置）
　　注意：01串两个相邻的数字之间均没有空格。
　　接下来一行，包含一个正整数n，表示询问的个数。
　　最后n行，每行包含一个非负整数k，表示询问Akb(0)。
　　注意：k可能为0，此时是求A0b(0) =b(0)。
题目输出：
　　输出n行，每行包含一个01串，表示对应询问中Akb(0)的结果。
　　注意：01串两个相邻的数字之间不要输出空格。
输入样例：
3
110
011
111
101
10
0
2
3
14
1
1325
6
124124
151
12312
输出样例：
101
010
111
101
110
010
100
101
001
100
提示：
评测用例规模与约定
　　本题使用10个评测用例来测试你的程序。
　　对于评测用例1，m = 10，n = 100，k ≤ 103。
　　对于评测用例2，m = 10，n = 100，k ≤ 104。
　　对于评测用例3，m = 30，n = 100，k ≤ 105。
　　对于评测用例4，m = 180，n = 100，k ≤ 105。
　　对于评测用例5，m = 10，n = 100，k ≤ 109。
　　对于评测用例6，m = 30，n = 100，k ≤ 109。
　　对于评测用例7，m = 180，n = 100，k ≤ 109。
　　对于评测用例8，m = 600，n = 100，k ≤ 109。
　　对于评测用例9，m = 800，n = 100，k ≤ 109。
　　对于评测用例10，m = 1000，n = 100，k ≤ 109。



题目：偷吃糖果(1920)
时间限制：1000Ms
空间限制：65536KB
题目描述：
小鱼喜欢吃糖果。他有两盒糖果，两盒糖果分别仅由小写字母组成的字符串s和字符串t构成。其中'a'到'z'表示具体的某种糖果类别。
他原本打算送给他喜欢的女生，但是要送给女孩子的话两盒糖果不能有差别(即字符串s和t完全相同)。所以，他决定偷吃几块，他吃糖果的策略是每次选出一盒糖果中两个连续的同种类别的糖果，然后吃掉其中一块。该策略可以使用多次。
例如一盒糖果是'rrrjj'，他可以把这盒糖果变成'rrjj'或者'rrrj'。现在你要告诉小鱼，经过他多次偷吃糖果之后，两盒糖果能否送给他喜欢的女孩子。如果可以输出'Yes'，如果不行输出'No'。
题目输入：
第一行一个T，表示T组测试数据。每组测试数据格式如下。
第一行表示字符串s，第二行表示字符串t。
1 ≤ T ≤ 100
Each character of s, t will be between 'a' and 'z'.
1 ≤ length of string s ≤ 1000
1 ≤ length of string t ≤ 1000
题目输出：
对于每组测试数据，输出Yes，或者No。
输入样例：
2
rrrjj
rrrj
rj
jr
输出样例：
Yes
No
提示：
题目中的第一个样例：第一盒糖果：rrrjj -> rrjj -> rjj -> rj第二盒糖果：rrrj -> rrj -> rj



题目：banana(1921)
时间限制：1000ms
空间限制：65536KB
题目描述：
给出两个点P、Q，点A绕着点P顺时针旋转，线段BC绕着点Q顺时针旋转。点A与线段BC的角速度相等，问在旋转的过程中有没有可能某一瞬间点A在线段BC上。
题目输入：
第一行输入一个整数T（1 <= T <= 100），表示有T组数据，
对于每组数据，有2行。第一行表示点P和点A的坐标；第二行表示点Q，和线段两个端点B，C的坐标（-200 <= 对于所有的x、y <= 200）。
题目输出：
如果可能相交，则输出yes，否则输出no。
输入样例：
2
0.0000000000 0.0000000000 -3.0000000000 -3.0000000000
5.0000000000 5.0000000000 6.0000000000 6.0000000000 8.0000000000 8.0000000000
0.0000000000 0.0000000000 -2.0000000000 -2.0000000000
5.0000000000 5.0000000000 6.0000000000 6.0000000000 7.0000000000 7.0000000000
输出样例：
yes
no
提示：
None



题目：count_prime(1922)
时间限制：1000ms
空间限制：65536KB
题目描述：
给定你一个数n，请你统计出在[a,b]这个区间中和n互质的数的个数。
两个数互质当且仅当他们除了1之外没有其他的公共因子或者他们最大的公共因子是1。1和任何数是互素的。
题目输入：
第一行输入一个整数T（1 <= T <= 100），表示T组测试数据。
接下来T行，每行3个整数a，b，n（1 <= a <=b <=10^15, 1<= n <= 10^9），用空格隔开。
题目输出：
输出一个整数表示和n互质的数的个数。
输入样例：
2
1 10 2
3 10 5
输出样例：
5
6
提示：
None



题目：triple(1923)
时间限制：3000MS
空间限制：65536KB
题目描述：
给出一个整数n，表示1，2，...，n。从这n个数中任意选择3个不同的数字x，y，z，问x，y，z的最大公约数等于m的方案有多少种？（注意：(1,2,3)，(1,3,2)，(2,1,3)，(2,3,1)，(3,1,2)，(3,2,1)属于同一种方案）
题目输入：
第一行输入一个整数T（1 <= T <= 100），表示有T组数据，
接下来T行，每行2个整数n, m（1 <= m <= n <= 10^5）
题目输出：
输出一个整数表示答案
输入样例：
15 1
输出样例：
10
提示：
None



题目：sad(1924)
时间限制：8000MS
空间限制：65536KB
题目描述：
金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算”。今天一早金明就开始做准备，但是他想买的东西太多了，共N件。于是，他决定分组买这些东西。他把每件物品规定了一个重要度C，此外他还从因特网上查到了每件物品的价格（都是整数元）F，并且给每件物品都编了号，为1到N。金明的分组规则如下：
1、每一组中的物品编号必须连续，即要类似这样分：(1,2,....i),(i+1,i+1,...j)....(k,k+1...n)
2、对于任意一对编号（i,j  i<j且1<=i,j<=n），如果物品i被分在p组，j被分在在q组中，且（p<q），那么必须要有Fi>Cj。
3、对于每一组K，金明定义这一组中物品的重要度的最大值为这一组的重要度Mi，这一组中物品所有物品价格之和为这一组的价格Si。在妈妈的限制下，所有的组的Mi之和不能超过一个上限limit。
而金明在分组的过程中则希望所有的Si中的最大值又要尽量小，这样妈妈就不会太在意钞票这个问题了，哈哈哈哈，现在的问题是
请你帮助金明设计一个满足要求的分组单。
题目输入：
多组测试数据。
对于每一组测试数据:
第一行包括两个正整数N,limit（0<=N<=10^5,limit<=2^31-1）
接下来的N行每行包括两个正整数Ci,Fi分别表示第i件物品的价格和重要度
（0<=Ci,Fi<=10000）
题目输出：
为了简单起见，金明不需要你输出整个分组单啦，输出你的分组中最大的S就行了。
如果没有合适的方案请输出 -1
每个Case占一行
输入样例：
4 6
4 3
3 5
2 5
2 4
输出样例：
9
提示：
n=0输出0



题目：sequence(1925)
时间限制：1000MS
空间限制：65536KB
题目描述：
将一个给定的数列，拆分成K个不降序列，每个数出现且只出现一次，且在各序列中各个数相对于原数列的相对顺序不变。
如7 6 9 8 10可以拆成 7 9 10和6 8。求最小的K值。
题目输入：
第一行输入一个整数T（1 <= T <= 100），表示接下来T组测试数据，
每组两行，第一行为n，代表数列长度（1<=n<=10000）
接下来一行有n个数，空格分隔（每个数<=50000）。
题目输出：
对每组数据输出一个最小的K值。
输入样例：
2
5
7 6 9 8 10
5
5 4 3 2 1
输出样例：
2
5
提示：
None



题目：琪露诺的算术教室(1926)
时间限制：1000ms
空间限制：65536KB
题目描述：
给出一个非负整数A，将这个数字的最低位移动到最高位（原来的最高位变为次高位，次低位变成最低位），得到非负整数B，发现B恰好是A的k倍。现给出A的最低位的值n，和倍数k，求最小的非负整数B。
题目输入：
第一行输入一个正整数T(1 <= T <= 1000)，表示有T组测试数据。
对于每组测试数据：输入两个整数n,k(0<=n<=9 , 0<=k<=9)。
题目输出：
对于每组测试数据，输出一个非负整数B，若无解，请输出-1。
输入样例：
1
2 2
输出样例：
210526315789473684
提示：
None



题目：谁才是最强战舰！(1927)
时间限制：1000MS
空间限制：65536KB
题目描述：
依阿华来到镇守府的第一件事情，就是找大和solo！
然而这并不是什么好消息，说不定，镇守府，甚至佐伯湾就这么消失了。。。
于是，提督君想了一个简单的游戏，来分出她们的胜负。游戏规则如下：这里有N堆石子，每堆石子有a[i]（1<=i<=N）个，每人轮流从其中的某一堆石子中拿出任意个石子（只能在其中一堆拿，不能不拿），大和先手，谁拿出了最后一个石子，谁输。若大和必胜，输出“Yamato_Saikou!”，若依阿华必胜，输出“Meidikeji_Shijiediyi!”，若两边都无法必胜，输出“Sayonara_Konosekai!”.
题目输入：
第一行输入一个正整数T(1 <= T <= 1000)，表示有T组测试数据。
对于每组测试数据：
第一行一个正整数，N（N<=1000），表示有N堆石子。
第二行N个整数a[i]（1<=a[i]<=1000），表示每堆石子的数量。
题目输出：
若大和必胜，输出“Yamato_Saikou!”，若依阿华必胜，输出“Meidikeji_Shijiediyi!”，若两边都无法必胜，输出“Sayonara_Konosekai!”.
输入样例：
3
1
5
2
1 231 1 1
输出样例：
Yamato_Saikou!
Yamato_Saikou!
Meidikeji_Shijiediyi!
提示：
None



题目：puzzle(1928)
时间限制：1000MS
空间限制：65536KB
题目描述：
小明在玩一个闯关游戏，共n关，必须按顺序通过，每一关会遇到两个数字（可能一样），他要选择其中一个，如果要选的这个数字是他之前选过的就直接过了这关。
但是他如果在某一关选了数字X，那就不能在经过另一关时选择数字Y当X+Y=2*n-1时，如果在某一关没有数可选的时候游戏结束，问在闯关游戏中小明最多可以通过几关。
题目输入：
第一行输入一个整数T（1 <= T <= 100），表示接下来T组测试数据，
每组测试数据第一行一个整数n（900<=n<=1000）
接下来n行每行两个整数a,b代表每关遇到的数字（0<=a,b<=2*n-1）
题目输出：
每组测试数据输出一个整数，小明最多的过关数。
输入样例：
2
3
0 0
1 1
2 2
3
0 0
1 1
5 5
输出样例：
3
2
提示：
None



题目：water1(1929)
时间限制：1000MS
空间限制：65536KB
题目描述：
听说全球气候变暖，冰川融化，海水淹大地。着实好奇要融化多少冰川会淹没我的宿舍，哦不，淹没南京，反正NJUST应该总会是第一批被淹的。
现将问题简化成一个二维坐标系的模型。有N个矩形块区域，每个区域有海拔（H）和宽度（W），区域按照顺序给出，比如有3个区域，第一个区域宽度为1，海拔为2，第二个区域宽度为5，海拔为6，第三个区域宽度为3，海拔为4，从图像上看就是像这样：（Y轴是海拔）

8 
7 
6  +++++
5  +++++
4  ++++++++
3  ++++++++
2 +++++++++
1 +++++++++
  123456789

假设最左边和最右边都是无限高的墙。
为了简化问题，假设水流下来的速度是每秒一个单位的水，并且总是往区域一降水（某沿海地区）。
现在请问要淹没所有的区域至少要多少时间（秒）？淹没的定义是，所有的区域表面至少覆盖一层水。如果没有区域则至少要放一滴水。
上图例子中，淹没完如下：

8
7 wwwwwwwww
6 w+++++www
5 w+++++www
4 w++++++++
3 w++++++++
2 +++++++++
1 +++++++++
  123456789

所以需要19秒。
题目输入：
多CASE，测试数据以EOF结尾，对于每个CASE：
第一行一个整数N（0 <= N <= 10^5）。
接下去N行每行对应两个整数H（1 <= H <= 10^5）,W（1 <= W <= 10^5）分别对应第N个区域的海拔和宽度。
题目输出：
一个整数，表示所需要的时间。
输入样例：
3
2 1 
6 5
4 3
输出样例：
19
提示：
None



题目：异或最大值(1930)
时间限制：1000ms
空间限制：65536KB
题目描述：
小明对异或很感兴趣，遇到了这样一个问题：对于给定的非负整数串A1, A2, ..., AN，能否找到他的
一个子串Ai1, Ai2, ..., Aik (1 <= i1 < i2 < ... < ik <= N)使得Ai1 XOR Ai2 XOR ... XOR Aik的值最大。
题目输入：
第一行输入一个整数T（1 <= T <= 100），表示T组测试数据。
接下来每组数据，第一行为整数n表示序列中数的个数（n<=110），下一行有n个整数 A1, A2, ..., AN (0 <= Ai <= 10^9)。
题目输出：
输出一个整数，表示序列的最大子串异或值。
输入样例：
1
3
11 9 5
输出样例：
14
提示：
None



